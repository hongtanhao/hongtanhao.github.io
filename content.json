{"meta":{"title":"wang xiaofeng's blog","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"在项目中使用非关系型数据库MongoDB","date":"2019-09-10T00:28:35.171Z","updated":"2019-07-22T01:36:52.496Z","comments":true,"path":"mongodb的基本使用案例.html","permalink":"http://yoursite.com/mongodb的基本使用案例.html","excerpt":"","text":"需要保证mongodb数据库服务正常运行。 安装mongoose模块 1npm install mongoose --save 使用（以express为例） 1234567891011121314var mongoose = require('mongoose');exports.index = function(req, res) &#123; var db = mongoose.createConnection('localhost', 'test'); var schema = mongoose.Schema(&#123;name: 'String'&#125;); var User = db.model('User', schema); var user = new User(&#123;name: 'tom'&#125;); user.save(function(err) &#123; if(err)// .... res.end(); &#125;); user.find(&#123;'name': 'tom'&#125;, function(err, docs) &#123; res.render('index', &#123;title: docs&#125;); &#125;);&#125;"},{"title":"","date":"2019-10-23T01:07:21.732Z","updated":"2019-10-23T01:07:21.732Z","comments":true,"path":"test.html","permalink":"http://yoursite.com/test.html","excerpt":"","text":"vue 进阶系列之全局 API 的使用 .todo-list { margin: 100px auto; width: 500px; text-align: center; font-family: '微软雅黑'; } .display-item li{ text-align: left; padding-left: 1rem; color: #bbbbbb; } .input-todo-item>input { width: 300px; height: 35px; border: 1px solid #bbb; border-radius: 4px; padding: 0 1rem; } .input-todo-item>input:focus { border-radius: 4px; } .input-todo-item>button { line-height: 35px; color: #ffffff; background-color: red; outline: none; opacity: .6; border-radius: 4px; border: none; padding: 0 1rem; cursor: pointer; } .input-todo-item>button:hover { opacity: 1; } .disableBtn { background-color: #bbb !important; opacity: 1 !important; } .samll-widget { display: inline-block; height: 20px; width: 30px; line-height: 20px; text-align: center; color: #ffffff; transition: all 1s; /* border: 1px solid #eee; */ border-radius: 2px; margin-left: 1rem; opacity: .5; cursor: pointer; } .samll-widget:hover { opacity: 1; } // 定义 组件 html 片段 const inputTpl = ` ` // 定义 组件 html 片段 const disTpl = ` x o ` // 定义 TodoList html 片段 const tpl = ` ` /** global API * @Vue.compile(template) * 功能： 在 render 函数中编译模板字符串 * params: */ const widget = Vue.compile(``) Vue.component('small-widget', { props: { type: { type: String }, index: { type: String } }, computed: { color () { if (this.type === 'delete') { return 'red' } else if (this.type === 'remind') { return 'yellow' } else { return 'green' } } }, mounted () { this.$refs['small-widget'].style.backgroundColor = this.color }, methods: { handleClick () { this.$emit('onClickWidget') // console.log('fsafasfsafsafa' ,this.$parent.$parent.$data) } }, render: widget.render }) /** global API * @Vue.extend(options) * 功能： 使用基础 Vue 构造器，创建一个“子类” * params: 一个包含组件选项的对象。 */ const DisplayItem = Vue.extend({ template: disTpl, props: { disList: { type: Array } }, methods: { deleteItem(index) { this.$emit('onDeleteItem', index) } } }) /** global API * @Vue.component(id, [definition]) * 功能： 注册或获取全局组件 * params: {string} id, {Function | Object} [definition] */ // 使用构造器创建组件 Vue.component('display-item', DisplayItem) // 使用模板选项创建组件 Vue.component('input-item', { template: inputTpl, data() { return { inputValue: '', add: 'add' } }, computed: { disableAddBtn() { return !this.inputValue } }, // watch 监听的属性只有当其发生变化后才触发，因此首次不会触发的 // watch: { // disableAddBtn (newV, oldV) { // if (newV) { // this.$refs['addbtn'].style.backgroundColor = \"#bbb\" // } else { // this.$refs['addbtn'].style.backgroundColor = \"red\" // } // } // }, methods: { addClick() { console.log(this.disableAddBtn) if (this.disableAddBtn) return this.$emit('onAddItem', this.inputValue) // 实例方法/事件 } } }) // 使用render函数创建组件 Vue.component('todo-list', { render: function (createElement) { return createElement('div', {'class': {'todo-list': true}}, [ createElement('input-item', { on: { onAddItem: this.$parent.addItemToList }, }, this.$slots.default), createElement('display-item', { props: { disList: this.$parent.$data.todoLists }, on: { onDeleteItem: this.$parent.deleteItemFromList }, }, this.$slots.default), ]) } }) const TodoList = new Vue({ props: { data: { type: Object } }, data() { return { todoLists: [ { text: '这个周末去song' } ] } }, methods: { deleteItemFromList (index) { this.todoLists.splice(index, 1) } }, render: function (createElement) { return createElement('todo-list') } }) /** global API * @Vue.mixin(id, [definition]) * 功能： 定义一个全局混入 * params: {string} id {Function | Object} [definition] */ Vue.mixin({ created: function () { var myOption = this.$options.myOption console.log('[myOption]', myOption) } }) /** global API * @Vue.directive(id, [definition]) * 功能： 注册或获取一个全局指令 * params: {string} id {Function | Object} [definition] */ Vue.directive('focus', { inserted (el, binding, vNode) { el.focus() } }) /** global API * @Vue.vue(plugin) * 功能： 安装 Vue.js 插件 * params: {Object | Function} plugin */ Vue.use({ install(Vue) { let message = (context, options) => { let res = Vue.compile('') let Message = Vue.extend({ render: res.render }) new Message().$mount(context) } Vue.prototype.$message = message } }) /** global API * @Vue.filter(id, [definition]) * 功能： 注册或获取全局过滤器。 * params: {string} id {Function | Object} [definition] */ Vue.filter('capitalize', function (value) { if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) }) /** global API * @Vue.set(target, propertyName/index, value ) * 功能： 向响应式对象中添加一个属性 * params: 一个包含组件选项的对象。 */ Vue.set(TodoList, 'key', { text: '这个周末去song' }) // 此处列举vue实例属性 console.log(TodoList.$data) // rw 代理data对象 // => {__ob__: Observer} // todoLists: (...) // __ob__: Observer {value: {…}, dep: Dep, vmCount: 1} // get todoLists: ƒ reactiveGetter() // set todoLists: ƒ reactiveSetter(newVal) // __proto__: Object console.log(TodoList.$options) // onlyread // => {components: {…}, directives: {…}, filters: {…}, _base: ƒ, template: \"↵ \", …} console.log(TodoList.$el) // onlyread Vue // => undefined console.log(TodoList.$root) // => 当前vue实例 console.log(TodoList.$props) // => {} // data: (...) // get data: ƒ reactiveGetter() // set data: ƒ reactiveSetter(newVal) // __proto__: Object console.log(TodoList.$parent) // onlyread // => 父实例，如果当前实例有的话 console.log(TodoList.$children) // onlyread // => 当前实例的直接子组件 // [] // 0: VueComponent {_uid: 1, _isVue: true, $options: {…}, _renderProxy: Proxy, _self: VueComponent, …} // 1: VueComponent {_uid: 2, _isVue: true, $options: {…}, _renderProxy: Proxy, _self: VueComponent, …} // length: 2 // __proto__: Array(0) console.log(TodoList.$refs) // onlyread // => 一个对象，持有注册过 ref 特性 的所有 DOM 元素和组件实例。 console.log(TodoList.$scopedSlots) // onlyread // => 用来访问作用域插槽 console.log(TodoList.$slots) // onlyread // => 用来访问被插槽分发的内容 console.log(TodoList.$listeners) // onlyread // => 包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器 console.log(TodoList.$attrs) // onlyread // => 包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外) console.log(TodoList.$isServer) // => 当前 Vue 实例是否运行于服务器 let list = TodoList.$data.todoLists list = list.map(item => { TodoList.$set(item, 'isCompleted', true) return item }) TodoList.addItemToList = value => { list.push({ isCompleted: false, text: value }) TodoList.$data.todoLists = list } /** instance API (实例方法) * @vm.$mount(id, [definition]) * 功能： 挂载一个未挂载的实例 * params: {Element | string} [elementOrSelector] {boolean} [hydrating] */ TodoList.$mount('#mount-point')"},{"title":"about","date":"2018-02-01T20:03:11.000Z","updated":"2018-02-01T03:03:12.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"","date":"2019-09-10T00:28:34.495Z","updated":"2018-02-01T08:13:20.000Z","comments":true,"path":"javascript-knowhow-master/README.html","permalink":"http://yoursite.com/javascript-knowhow-master/README.html","excerpt":"","text":"JavaScript思维导图 JS基本概念 JS操作符 JS基本语句 JS数组用法 Date用法 JS字符串用法 JS编程风格 JS编程实践"}],"posts":[{"title":"vue 进阶系列之实例方法","slug":"vue进阶系列之实例方法","date":"2019-10-23T01:07:09.956Z","updated":"2019-10-23T01:07:09.956Z","comments":true,"path":"2019/10/22/vue进阶系列之实例方法/","link":"","permalink":"http://yoursite.com/2019/10/22/vue进阶系列之实例方法/","excerpt":"继vue 进阶系列之指令后，再写 vue 进阶系列之实例方法","text":"继vue 进阶系列之指令后，再写 vue 进阶系列之实例方法 基于一个简单的TodoList来演示vue实例方法的使用 请仔细阅读注释处所涉及到的api的使用方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt; vue 进阶系列之全局 API 的使用&lt;/title&gt; &lt;style&gt; .todo-list &#123; margin: 100px auto; width: 500px; text-align: center; font-family: '微软雅黑'; &#125; .display-item li&#123; text-align: left; padding-left: 1rem; color: #bbbbbb; &#125; .input-todoo-item&gt;input &#123; width: 300px; height: 35px; border: 1px solid #bbb; border-radius: 4px; padding: 0 1rem; &#125; .input-todoo-item&gt;input:focus &#123; border-radius: 4px; &#125; .input-todoo-item&gt;button &#123; line-height: 35px; color: #ffffff; background-color: red; outline: none; opacity: .6; border-radius: 4px; border: none; padding: 0 1rem; cursor: pointer; &#125; .input-todoo-item&gt;button:hover &#123; opacity: 1; &#125; .disableBtn &#123; background-color: #bbb !important; opacity: 1 !important; &#125; .samll-widget &#123; display: inline-block; height: 20px; width: 30px; line-height: 20px; text-align: center; color: #ffffff; transition: all 1s; /* border: 1px solid #eee; */ border-radius: 2px; margin-left: 1rem; opacity: .5; cursor: pointer; &#125; .samll-widget:hover &#123; opacity: 1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"mount-point\"&gt; &lt;div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; // 定义 &lt;input-item/&gt;组件 html 片段 const inputTpl = `&lt;div class=\"input-todoo-item\"&gt; &lt;input v-focus type=\"text\" v-model=\"inputValue\"/&gt; &lt;button ref=\"addbtn\" @click=\"addClick\" :disabled=\"disableAddBtn\" :class=\"&#123;disableBtn: disableAddBtn&#125;\"&gt; &#123;&#123; add | capitalize&#125;&#125; &lt;/button&gt; &lt;/div&gt; ` // 定义 &lt;display-item&gt;组件 html 片段 const disTpl = `&lt;div class=\"display-item\"&gt; &lt;ul&gt; &lt;li v-for=\"(item, index) in disList\" :key=\"index\" :style=\"&#123;textDecorationLine: item.isCompleted ? 'line-through' : 'none'&#125;\"&gt; &#123;&#123;item.text&#125;&#125; &lt;small-widget type=\"delete\" index=\"index\" @onClickWidget=\"deleteItem(index)\"&gt; &lt;template v-slot:widget&gt;x&lt;/template&gt; &lt;/small-widget&gt; &lt;small-widget type=\"finished\" index=\"index\"&gt; &lt;template v-slot:widget&gt;o&lt;/template&gt; &lt;/small-widget&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;` // 定义 TodoList html 片段 const tpl = `&lt;div class=\"todo-list\"&gt; &lt;input-item @onAddItem=\"addItemToList\"/&gt; &lt;display-item :disList=\"todoLists\"/&gt; &lt;/div&gt;` const widget = Vue.compile(`&lt;span ref=\"small-widget\" class=\"samll-widget\" @click=\"handleClick\"&gt;&lt;slot name=\"widget\"&gt;&lt;/slot&gt;&lt;/span&gt;`) Vue.component('small-widget', &#123; props: &#123; type: &#123; type: String &#125;, index: &#123; type: String &#125; &#125;, computed: &#123; color () &#123; if (this.type === 'delete') &#123; return 'red' &#125; else if (this.type === 'remind') &#123; return 'yellow' &#125; else &#123; return 'green' &#125; &#125; &#125;, mounted () &#123; this.$refs['small-widget'].style.backgroundColor = this.color &#125;, methods: &#123; handleClick () &#123; /** global API * @vm.$emit(target, propertyName/index, value ) * 功能： 触发当前实例上的事件。附加参数都会传给监听器回调。 * params: &#123;string&#125; eventName [...args] */ this.$emit('onClickWidget') &#125; &#125;, render: widget.render &#125;) const DisplayItem = Vue.extend(&#123; template: disTpl, props: &#123; disList: &#123; type: Array &#125; &#125;, methods: &#123; deleteItem(index) &#123; this.$emit('onDeleteItem', index) &#125; &#125; &#125;) // 使用构造器创建组件 Vue.component('display-item', DisplayItem) // 使用模板选项创建组件 Vue.component('input-item', &#123; template: inputTpl, data() &#123; return &#123; inputValue: '', add: 'add' &#125; &#125;, computed: &#123; disableAddBtn() &#123; return !this.inputValue &#125; &#125;, methods: &#123; addClick() &#123; console.log(this.disableAddBtn) if (this.disableAddBtn) return this.$emit('onAddItem', this.inputValue) // 实例方法/事件 &#125; &#125; &#125;) // 使用render函数创建组件 Vue.component('todo-list', &#123; render: function (createElement) &#123; return createElement('div', &#123;'class': &#123;'todo-list': true&#125;&#125;, [ createElement('input-item', &#123; on: &#123; onAddItem: this.$parent.addItemToList &#125;, &#125;, this.$slots.default), createElement('display-item', &#123; props: &#123; disList: this.$parent.$data.todoLists &#125;, on: &#123; onDeleteItem: this.$parent.deleteItemFromList &#125;, &#125;, this.$slots.default), ]) &#125; &#125;) const TodoList = new Vue(&#123; props: &#123; data: &#123; type: Object &#125; &#125;, data() &#123; return &#123; todoLists: [ &#123; text: '这个周末去song' &#125; ] &#125; &#125;, methods: &#123; deleteItemFromList (index) &#123; this.todoLists.splice(index, 1) &#125; &#125;, render: function (createElement) &#123; return createElement('todo-list') &#125; &#125;) Vue.mixin(&#123; created: function () &#123; var myOption = this.$options.myOption console.log('[myOption]', myOption) &#125; &#125;) Vue.directive('focus', &#123; inserted (el, binding, vNode) &#123; el.focus() &#125; &#125;) Vue.use(&#123; install(Vue) &#123; let message = (context, options) =&gt; &#123; let res = Vue.compile('&lt;div&gt;&#123;&#123;options.text&#125;&#125;&lt;/div&gt;') let Message = Vue.extend(&#123; render: res.render &#125;) new Message().$mount(context) &#125; Vue.prototype.$message = message &#125; &#125;) Vue.filter('capitalize', function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125;) Vue.set(TodoList, 'key', &#123; text: '这个周末去song' &#125;) let list = TodoList.$data.todoLists list = list.map(item =&gt; &#123; TodoList.$set(item, 'isCompleted', true) return item &#125;) TodoList.addItemToList = value =&gt; &#123; list.push(&#123; isCompleted: false, text: value &#125;) TodoList.$data.todoLists = list &#125; /** global API * @vm.$mount(target, propertyName/index, value ) * 功能： 将一个处在未挂载状态的组件挂载到dom树种 * params: 一个包含组件选项的对象。 */ TodoList.$mount('#mount-point') &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}],"keywords":[]},{"title":"vue 进阶系列之全局API","slug":"vue进阶系列之全局API","date":"2019-10-23T01:07:05.572Z","updated":"2019-10-23T01:07:05.572Z","comments":true,"path":"2019/10/22/vue进阶系列之全局API/","link":"","permalink":"http://yoursite.com/2019/10/22/vue进阶系列之全局API/","excerpt":"继vue 进阶系列之指令后，再写 vue 进阶系列之全局 API","text":"继vue 进阶系列之指令后，再写 vue 进阶系列之全局 API 基于一个简单的TodoList来演示全局API的使用, 在使用到全局API的地方会有注释标明 请仔细阅读注释处所涉及到的api的使用方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt; vue 进阶系列之全局 API 的使用&lt;/title&gt; &lt;style&gt; .todo-list &#123; margin: 100px auto; width: 500px; text-align: center; font-family: '微软雅黑'; &#125; .display-item li&#123; text-align: left; padding-left: 1rem; color: #bbbbbb; &#125; .input-todo-item&gt;input &#123; width: 300px; height: 35px; border: 1px solid #bbb; border-radius: 4px; padding: 0 1rem; &#125; .input-todo-item&gt;input:focus &#123; border-radius: 4px; &#125; .input-todo-item&gt;button &#123; line-height: 35px; color: #ffffff; background-color: red; outline: none; opacity: .6; border-radius: 4px; border: none; padding: 0 1rem; cursor: pointer; &#125; .input-todo-item&gt;button:hover &#123; opacity: 1; &#125; .disableBtn &#123; background-color: #bbb !important; opacity: 1 !important; &#125; .samll-widget &#123; display: inline-block; height: 20px; width: 30px; line-height: 20px; text-align: center; color: #ffffff; transition: all 1s; /* border: 1px solid #eee; */ border-radius: 2px; margin-left: 1rem; opacity: .5; cursor: pointer; &#125; .samll-widget:hover &#123; opacity: 1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"mount-point\"&gt; &lt;div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; // 定义 &lt;input-item/&gt;组件 html 片段 const inputTpl = `&lt;div class=\"input-todo-item\"&gt; &lt;input v-focus type=\"text\" v-model=\"inputValue\"/&gt; &lt;button ref=\"addbtn\" @click=\"addClick\" :disabled=\"disableAddBtn\" :class=\"&#123;disableBtn: disableAddBtn&#125;\"&gt; &#123;&#123; add | capitalize&#125;&#125; &lt;/button&gt; &lt;/div&gt; ` // 定义 &lt;display-item&gt;组件 html 片段 const disTpl = `&lt;div class=\"display-item\"&gt; &lt;ul&gt; &lt;li v-for=\"(item, index) in disList\" :key=\"index\" :style=\"&#123;textDecorationLine: item.isCompleted ? 'line-through' : 'none'&#125;\"&gt; &#123;&#123;item.text&#125;&#125; &lt;small-widget type=\"delete\" index=\"index\" @onClickWidget=\"deleteItem(index)\"&gt; &lt;template v-slot:widget&gt;x&lt;/template&gt; &lt;/small-widget&gt; &lt;small-widget type=\"finished\" index=\"index\"&gt; &lt;template v-slot:widget&gt;o&lt;/template&gt; &lt;/small-widget&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;` // 定义 TodoList html 片段 const tpl = `&lt;div class=\"todo-list\"&gt; &lt;input-item @onAddItem=\"addItemToList\"/&gt; &lt;display-item :disList=\"todoLists\"/&gt; &lt;/div&gt;` /** global API * @Vue.compile(template) * 功能： 在 render 函数中编译模板字符串 * params: */ const widget = Vue.compile(`&lt;span ref=\"small-widget\" class=\"samll-widget\" @click=\"handleClick\"&gt;&lt;slot name=\"widget\"&gt;&lt;/slot&gt;&lt;/span&gt;`) Vue.component('small-widget', &#123; props: &#123; type: &#123; type: String &#125;, index: &#123; type: String &#125; &#125;, computed: &#123; color () &#123; if (this.type === 'delete') &#123; return 'red' &#125; else if (this.type === 'remind') &#123; return 'yellow' &#125; else &#123; return 'green' &#125; &#125; &#125;, mounted () &#123; this.$refs['small-widget'].style.backgroundColor = this.color &#125;, methods: &#123; handleClick () &#123; this.$emit('onClickWidget') // console.log('fsafasfsafsafa' ,this.$parent.$parent.$data) &#125; &#125;, render: widget.render &#125;) /** global API * @Vue.extend(options) * 功能： 使用基础 Vue 构造器，创建一个“子类” * params: 一个包含组件选项的对象。 */ const DisplayItem = Vue.extend(&#123; template: disTpl, props: &#123; disList: &#123; type: Array &#125; &#125;, methods: &#123; deleteItem(index) &#123; this.$emit('onDeleteItem', index) &#125; &#125; &#125;) /** global API * @Vue.component(id, [definition]) * 功能： 注册或获取全局组件 * params: &#123;string&#125; id, &#123;Function | Object&#125; [definition] */ // 使用构造器创建组件 Vue.component('display-item', DisplayItem) // 使用模板选项创建组件 Vue.component('input-item', &#123; template: inputTpl, data() &#123; return &#123; inputValue: '', add: 'add' &#125; &#125;, computed: &#123; disableAddBtn() &#123; return !this.inputValue &#125; &#125;, methods: &#123; addClick() &#123; console.log(this.disableAddBtn) if (this.disableAddBtn) return this.$emit('onAddItem', this.inputValue) // 实例方法/事件 &#125; &#125; &#125;) // 使用render函数创建组件 Vue.component('todo-list', &#123; render: function (createElement) &#123; return createElement('div', &#123;'class': &#123;'todo-list': true&#125;&#125;, [ createElement('input-item', &#123; on: &#123; onAddItem: this.$parent.addItemToList &#125;, &#125;, this.$slots.default), createElement('display-item', &#123; props: &#123; disList: this.$parent.$data.todoLists &#125;, on: &#123; onDeleteItem: this.$parent.deleteItemFromList &#125;, &#125;, this.$slots.default), ]) &#125; &#125;) const TodoList = new Vue(&#123; props: &#123; data: &#123; type: Object &#125; &#125;, data() &#123; return &#123; todoLists: [ &#123; text: '这个周末去song' &#125; ] &#125; &#125;, methods: &#123; deleteItemFromList (index) &#123; this.todoLists.splice(index, 1) &#125; &#125;, render: function (createElement) &#123; return createElement('todo-list') &#125; &#125;) /** global API * @Vue.mixin(id, [definition]) * 功能： 定义一个全局混入 * params: &#123;string&#125; id &#123;Function | Object&#125; [definition] */ Vue.mixin(&#123; created: function () &#123; var myOption = this.$options.myOption console.log('[myOption]', myOption) &#125; &#125;) /** global API * @Vue.directive(id, [definition]) * 功能： 注册或获取一个全局指令 * params: &#123;string&#125; id &#123;Function | Object&#125; [definition] */ Vue.directive('focus', &#123; inserted (el, binding, vNode) &#123; el.focus() &#125; &#125;) /** global API * @Vue.vue(plugin) * 功能： 安装 Vue.js 插件 * params: &#123;Object | Function&#125; plugin */ Vue.use(&#123; install(Vue) &#123; let message = (context, options) =&gt; &#123; let res = Vue.compile('&lt;div&gt;&#123;&#123;options.text&#125;&#125;&lt;/div&gt;') let Message = Vue.extend(&#123; render: res.render &#125;) new Message().$mount(context) &#125; Vue.prototype.$message = message &#125; &#125;) /** global API * @Vue.filter(id, [definition]) * 功能： 注册或获取全局过滤器。 * params: &#123;string&#125; id &#123;Function | Object&#125; [definition] */ Vue.filter('capitalize', function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125;) /** global API * @Vue.set(target, propertyName/index, value ) * 功能： 向响应式对象中添加一个属性 * params: 一个包含组件选项的对象。 */ Vue.set(TodoList, 'key', &#123; text: '这个周末去song' &#125;) let list = TodoList.$data.todoLists list = list.map(item =&gt; &#123; TodoList.$set(item, 'isCompleted', true) return item &#125;) TodoList.addItemToList = value =&gt; &#123; list.push(&#123; isCompleted: false, text: value &#125;) TodoList.$data.todoLists = list &#125; TodoList.$mount('#mount-point') &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}],"keywords":[]},{"title":"vue 进阶系列之实例属性","slug":"vue进阶系列之实例属性","date":"2019-10-23T01:06:58.968Z","updated":"2019-10-23T01:06:58.968Z","comments":true,"path":"2019/10/22/vue进阶系列之实例属性/","link":"","permalink":"http://yoursite.com/2019/10/22/vue进阶系列之实例属性/","excerpt":"vue 进阶系列之实例属性, 沿用进阶系列之全局 API 的实例","text":"vue 进阶系列之实例属性, 沿用进阶系列之全局 API 的实例 vue 进阶系列之实例属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt; vue 进阶系列之全局 API 的使用&lt;/title&gt; &lt;style&gt; .todo-list &#123; margin: 100px auto; width: 500px; text-align: center; &#125; .display-item &#123; text-align: left; &#125; .input-todo-item&gt;input &#123; width: 300px; height: 35px; border: 1px solid #bbb; border-radius: 4px; padding-left: 1rem; &#125; .input-todo-item&gt;input:focus &#123; border-radius: 4px; &#125; .input-todo-item&gt;button &#123; line-height: 35px; color: #ffffff; background-color: red; outline: none; opacity: .6; border-radius: 4px; border: none; padding: 0 1rem; &#125; .input-todo-item&gt;button:hover &#123; opacity: 1; &#125; .disableBtn &#123; background-color: #bbb !important; opacity: 1 !important; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"mount-point\"&gt; &lt;div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const inputTpl = `&lt;div class=\"input-todo-item\"&gt; &lt;input type=\"text\" v-model=\"inputValue\"/&gt; &lt;button ref=\"addbtn\" @click=\"addClick\" :disabled=\"disableAddBtn\" :class=\"&#123;disableBtn: disableAddBtn&#125;\"&gt; add &lt;/button&gt; &lt;/div&gt; ` const disTpl = `&lt;div class=\"display-item\"&gt; &lt;ul&gt; &lt;li v-for=\"(item, index) in disList\" :key=\"index\" :style=\"&#123;textDecorationLine: item.isCompleted ? 'line-through' : 'none'&#125;\" @click=\"deleteItem\"&gt; &#123;&#123;item.text&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;` const tpl = `&lt;div class=\"todo-list\"&gt; &lt;input-item @onAddItem=\"addItemToList\"/&gt; &lt;display-item :disList=\"todoLists\"/&gt; &lt;/div&gt;` const DisplayItem = Vue.extend(&#123; template: disTpl, props: &#123; disList: &#123; type: Array &#125; &#125;, methods: &#123; deleteItem() &#123; &#125; &#125; &#125;) Vue.component('display-item', DisplayItem) Vue.component('input-item', &#123; template: inputTpl, data() &#123; return &#123; inputValue: '' &#125; &#125;, computed: &#123; disableAddBtn() &#123; return !this.inputValue &#125; &#125;, methods: &#123; addClick() &#123; console.log(this.disableAddBtn) if (this.disableAddBtn) return this.$emit('onAddItem', this.inputValue) // 实例方法/事件 &#125; &#125; &#125;) const TodoList = new Vue(&#123; template: tpl, props: &#123; data: &#123; type: Object &#125; &#125;, data() &#123; return &#123; todoLists: [ &#123; text: '这个周末去song' &#125; ] &#125; &#125; &#125;) let list = TodoList.$data.todoLists list = list.map(item =&gt; &#123; TodoList.$set(item, 'isCompleted', true) return item &#125;) TodoList.addItemToList = value =&gt; &#123; list.push(&#123; isCompleted: false, text: value &#125;) TodoList.$data.todoLists = list &#125; TodoList.$mount('#mount-point') // 此处列举vue实例属性 console.log(TodoList.$data) // rw 代理data对象 // =&gt; &#123;__ob__: Observer&#125; // todoLists: (...) // __ob__: Observer &#123;value: &#123;…&#125;, dep: Dep, vmCount: 1&#125; // get todoLists: ƒ reactiveGetter() // set todoLists: ƒ reactiveSetter(newVal) // __proto__: Object console.log(TodoList.$options) // onlyread // =&gt; &#123;components: &#123;…&#125;, directives: &#123;…&#125;, filters: &#123;…&#125;, _base: ƒ, template: \"&lt;div class=\"todo-list\"&gt;&lt;input-item @o…play-item :disList=\"todoLists\"/&gt;↵ &lt;/div&gt;\", …&#125; console.log(TodoList.$el) // onlyread Vue // =&gt; undefined console.log(TodoList.$root) // =&gt; 当前vue实例 console.log(TodoList.$props) // =&gt; &#123;&#125; // data: (...) // get data: ƒ reactiveGetter() // set data: ƒ reactiveSetter(newVal) // __proto__: Object console.log(TodoList.$parent) // onlyread // =&gt; 父实例，如果当前实例有的话 console.log(TodoList.$children) // onlyread // =&gt; 当前实例的直接子组件 // [] // 0: VueComponent &#123;_uid: 1, _isVue: true, $options: &#123;…&#125;, _renderProxy: Proxy, _self: VueComponent, …&#125; // 1: VueComponent &#123;_uid: 2, _isVue: true, $options: &#123;…&#125;, _renderProxy: Proxy, _self: VueComponent, …&#125; // length: 2 // __proto__: Array(0) console.log(TodoList.$refs) // onlyread // =&gt; 一个对象，持有注册过 ref 特性 的所有 DOM 元素和组件实例。 console.log(TodoList.$scopedSlots) // onlyread // =&gt; 用来访问作用域插槽 console.log(TodoList.$slots) // onlyread // =&gt; 用来访问被插槽分发的内容 console.log(TodoList.$listeners) // onlyread // =&gt; 包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器 console.log(TodoList.$attrs) // onlyread // =&gt; 包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外) console.log(vm.$isServer) // =&gt; 当前 Vue 实例是否运行于服务器 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}],"keywords":[]},{"title":"从一个todoList来体验vue的神秘感","slug":"从一个todoList来体验vue的神秘感","date":"2019-10-23T00:53:52.024Z","updated":"2019-10-23T00:53:52.024Z","comments":true,"path":"2019/10/22/从一个todoList来体验vue的神秘感/","link":"","permalink":"http://yoursite.com/2019/10/22/从一个todoList来体验vue的神秘感/","excerpt":"从一个 todoList 来体验 vue 的神秘感","text":"从一个 todoList 来体验 vue 的神秘感 请纵情体验使用 vue 来玩 todoList 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt; vue 进阶系列之全局 API 的使用&lt;/title&gt; &lt;style&gt; .todo-list &#123; margin: 100px auto; width: 500px; text-align: center; font-family: '微软雅黑'; &#125; .display-item li&#123; text-align: left; padding-left: 1rem; color: #bbbbbb; &#125; .input-tod-item&gt;input &#123; width: 300px; height: 35px; border: 1px solid #bbb; border-radius: 4px; padding: 0 1rem; &#125; .input-tod-item&gt;input:focus &#123; border-radius: 4px; &#125; .input-tod-item&gt;button &#123; line-height: 35px; color: #ffffff; background-color: red; outline: none; opacity: .6; border-radius: 4px; border: none; padding: 0 1rem; cursor: pointer; &#125; .input-tod-item&gt;button:hover &#123; opacity: 1; &#125; .disableBtn &#123; background-color: #bbb !important; opacity: 1 !important; &#125; .samll-widget &#123; display: inline-block; height: 20px; width: 30px; line-height: 20px; text-align: center; color: #ffffff; transition: all 1s; /* border: 1px solid #eee; */ border-radius: 2px; margin-left: 1rem; opacity: .5; cursor: pointer; &#125; .samll-widget:hover &#123; opacity: 1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"mount-point\"&gt; &lt;div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; // 定义 &lt;input-item/&gt;组件 html 片段 const inputTpl = `&lt;div class=\"input-tod-item\"&gt; &lt;input v-focus type=\"text\" v-model=\"inputValue\"/&gt; &lt;button ref=\"addbtn\" @click=\"addClick\" :disabled=\"disableAddBtn\" :class=\"&#123;disableBtn: disableAddBtn&#125;\"&gt; &#123;&#123; add | capitalize&#125;&#125; &lt;/button&gt; &lt;/div&gt; ` // 定义 &lt;display-item&gt;组件 html 片段 const disTpl = `&lt;div class=\"display-item\"&gt; &lt;ul&gt; &lt;li v-for=\"(item, index) in disList\" :key=\"index\" :style=\"&#123;textDecorationLine: item.isCompleted ? 'line-through' : 'none'&#125;\"&gt; &#123;&#123;item.text&#125;&#125; &lt;small-widget type=\"delete\" index=\"index\" @onClickWidget=\"deleteItem(index)\"&gt; &lt;template v-slot:widget&gt;x&lt;/template&gt; &lt;/small-widget&gt; &lt;small-widget type=\"finished\" index=\"index\"&gt; &lt;template v-slot:widget&gt;o&lt;/template&gt; &lt;/small-widget&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;` // 定义 TodoList html 片段 const tpl = `&lt;div class=\"todo-list\"&gt; &lt;input-item @onAddItem=\"addItemToList\"/&gt; &lt;display-item :disList=\"todoLists\"/&gt; &lt;/div&gt;` /** global API * @Vue.compile(template) * 功能： 在 render 函数中编译模板字符串 * params: */ const widget = Vue.compile(`&lt;span ref=\"small-widget\" class=\"samll-widget\" @click=\"handleClick\"&gt;&lt;slot name=\"widget\"&gt;&lt;/slot&gt;&lt;/span&gt;`) Vue.component('small-widget', &#123; props: &#123; type: &#123; type: String &#125;, index: &#123; type: String &#125; &#125;, computed: &#123; color () &#123; if (this.type === 'delete') &#123; return 'red' &#125; else if (this.type === 'remind') &#123; return 'yellow' &#125; else &#123; return 'green' &#125; &#125; &#125;, mounted () &#123; this.$refs['small-widget'].style.backgroundColor = this.color &#125;, methods: &#123; handleClick () &#123; this.$emit('onClickWidget') // console.log('fsafasfsafsafa' ,this.$parent.$parent.$data) &#125; &#125;, render: widget.render &#125;) /** global API * @Vue.extend(options) * 功能： 使用基础 Vue 构造器，创建一个“子类” * params: 一个包含组件选项的对象。 */ const DisplayItem = Vue.extend(&#123; template: disTpl, props: &#123; disList: &#123; type: Array &#125; &#125;, methods: &#123; deleteItem(index) &#123; this.$emit('onDeleteItem', index) &#125; &#125; &#125;) /** global API * @Vue.component(id, [definition]) * 功能： 注册或获取全局组件 * params: &#123;string&#125; id, &#123;Function | Object&#125; [definition] */ // 使用构造器创建组件 Vue.component('display-item', DisplayItem) // 使用模板选项创建组件 Vue.component('input-item', &#123; template: inputTpl, data() &#123; return &#123; inputValue: '', add: 'add' &#125; &#125;, computed: &#123; disableAddBtn() &#123; return !this.inputValue &#125; &#125;, // watch 监听的属性只有当其发生变化后才触发，因此首次不会触发的 // watch: &#123; // disableAddBtn (newV, oldV) &#123; // if (newV) &#123; // this.$refs['addbtn'].style.backgroundColor = \"#bbb\" // &#125; else &#123; // this.$refs['addbtn'].style.backgroundColor = \"red\" // &#125; // &#125; // &#125;, methods: &#123; addClick() &#123; console.log(this.disableAddBtn) if (this.disableAddBtn) return this.$emit('onAddItem', this.inputValue) // 实例方法/事件 &#125; &#125; &#125;) // 使用render函数创建组件 Vue.component('todo-list', &#123; render: function (createElement) &#123; return createElement('div', &#123;'class': &#123;'todo-list': true&#125;&#125;, [ createElement('input-item', &#123; on: &#123; onAddItem: this.$parent.addItemToList &#125;, &#125;, this.$slots.default), createElement('display-item', &#123; props: &#123; disList: this.$parent.$data.todoLists &#125;, on: &#123; onDeleteItem: this.$parent.deleteItemFromList &#125;, &#125;, this.$slots.default), ]) &#125; &#125;) const TodoList = new Vue(&#123; props: &#123; data: &#123; type: Object &#125; &#125;, data() &#123; return &#123; todoLists: [ &#123; text: '这个周末去song' &#125; ] &#125; &#125;, methods: &#123; deleteItemFromList (index) &#123; this.todoLists.splice(index, 1) &#125; &#125;, render: function (createElement) &#123; return createElement('todo-list') &#125; &#125;) /** global API * @Vue.mixin(id, [definition]) * 功能： 定义一个全局混入 * params: &#123;string&#125; id &#123;Function | Object&#125; [definition] */ Vue.mixin(&#123; created: function () &#123; var myOption = this.$options.myOption console.log('[myOption]', myOption) &#125; &#125;) /** global API * @Vue.directive(id, [definition]) * 功能： 注册或获取一个全局指令 * params: &#123;string&#125; id &#123;Function | Object&#125; [definition] */ Vue.directive('focus', &#123; inserted (el, binding, vNode) &#123; el.focus() &#125; &#125;) /** global API * @Vue.vue(plugin) * 功能： 安装 Vue.js 插件 * params: &#123;Object | Function&#125; plugin */ Vue.use(&#123; install(Vue) &#123; let message = (context, options) =&gt; &#123; let res = Vue.compile('&lt;div&gt;&#123;&#123;options.text&#125;&#125;&lt;/div&gt;') let Message = Vue.extend(&#123; render: res.render &#125;) new Message().$mount(context) &#125; Vue.prototype.$message = message &#125; &#125;) /** global API * @Vue.filter(id, [definition]) * 功能： 注册或获取全局过滤器。 * params: &#123;string&#125; id &#123;Function | Object&#125; [definition] */ Vue.filter('capitalize', function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125;) /** global API * @Vue.set(target, propertyName/index, value ) * 功能： 向响应式对象中添加一个属性 * params: 一个包含组件选项的对象。 */ Vue.set(TodoList, 'key', &#123; text: '这个周末去song' &#125;) // 此处列举vue实例属性 console.log(TodoList.$data) // rw 代理data对象 // =&gt; &#123;__ob__: Observer&#125; // todoLists: (...) // __ob__: Observer &#123;value: &#123;…&#125;, dep: Dep, vmCount: 1&#125; // get todoLists: ƒ reactiveGetter() // set todoLists: ƒ reactiveSetter(newVal) // __proto__: Object console.log(TodoList.$options) // onlyread // =&gt; &#123;components: &#123;…&#125;, directives: &#123;…&#125;, filters: &#123;…&#125;, _base: ƒ, template: \"&lt;div class=\"todo-list\"&gt;&lt;input-item @o…play-item :disList=\"todoLists\"/&gt;↵ &lt;/div&gt;\", …&#125; console.log(TodoList.$el) // onlyread Vue // =&gt; undefined console.log(TodoList.$root) // =&gt; 当前vue实例 console.log(TodoList.$props) // =&gt; &#123;&#125; // data: (...) // get data: ƒ reactiveGetter() // set data: ƒ reactiveSetter(newVal) // __proto__: Object console.log(TodoList.$parent) // onlyread // =&gt; 父实例，如果当前实例有的话 console.log(TodoList.$children) // onlyread // =&gt; 当前实例的直接子组件 // [] // 0: VueComponent &#123;_uid: 1, _isVue: true, $options: &#123;…&#125;, _renderProxy: Proxy, _self: VueComponent, …&#125; // 1: VueComponent &#123;_uid: 2, _isVue: true, $options: &#123;…&#125;, _renderProxy: Proxy, _self: VueComponent, …&#125; // length: 2 // __proto__: Array(0) console.log(TodoList.$refs) // onlyread // =&gt; 一个对象，持有注册过 ref 特性 的所有 DOM 元素和组件实例。 console.log(TodoList.$scopedSlots) // onlyread // =&gt; 用来访问作用域插槽 console.log(TodoList.$slots) // onlyread // =&gt; 用来访问被插槽分发的内容 console.log(TodoList.$listeners) // onlyread // =&gt; 包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器 console.log(TodoList.$attrs) // onlyread // =&gt; 包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外) console.log(TodoList.$isServer) // =&gt; 当前 Vue 实例是否运行于服务器 let list = TodoList.$data.todoLists list = list.map(item =&gt; &#123; TodoList.$set(item, 'isCompleted', true) return item &#125;) TodoList.addItemToList = value =&gt; &#123; list.push(&#123; isCompleted: false, text: value &#125;) TodoList.$data.todoLists = list &#125; /** instance API (实例方法) * @vm.$mount(id, [definition]) * 功能： 挂载一个未挂载的实例 * params: &#123;Element | string&#125; [elementOrSelector] &#123;boolean&#125; [hydrating] */ TodoList.$mount('#mount-point') &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}],"keywords":[]},{"title":"vue 进阶系列之指令","slug":"vue进阶系列之指令","date":"2019-10-22T18:13:30.123Z","updated":"2019-10-22T18:13:30.123Z","comments":true,"path":"2019/10/22/vue进阶系列之指令/","link":"","permalink":"http://yoursite.com/2019/10/22/vue进阶系列之指令/","excerpt":"本文章是基于vue 2做总结案例，主要展示了在SPA中怎么使用。 如何构建SPA 参考文档vuejs","text":"本文章是基于vue 2做总结案例，主要展示了在SPA中怎么使用。 如何构建SPA 参考文档vuejs 指令v-text 作用： 更新元素的 textContent 12345678910111213&lt;!--#ps: 请和插值语法&#123;&#123;msg&#125;&#125;比较学习 --&gt;&lt;template&gt; &lt;div v-text=\"msg\"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; msg: \"just do it\" &#125;; &#125; &#125;;&lt;/script&gt; v-text vs Mustache 语法12# 同： 都是更新元素的textContent# 异： 当网速很慢或者下面的JavaScript写错时，会直接将&#123;&#123;msg&#125;&#125;渲染到页面而使用v-text=\"message\" 如果出错是不显示的 v-html 作用： 操作元素中的HTML标签 12345678910111213&lt;!-- #ps: 请和`v-text`比较学习 --&gt;&lt;template&gt; &lt;div v-html=\"msg\"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; msg: \"&lt;img src='img/1.ipg'\"/&gt; &#125; &#125; &#125;&lt;/script&gt; v-text vs v-html12# 同： 如果只是用来渲染 `textContent`， 则效果相同# 异： v-text会将元素当成纯文本输出，v-html会将元素当成HTML标签解析后输出 v-show 作用： 根据表达式之真假值，切换元素的 display CSS 属性 12345678910111213&lt;!-- #ps: 请和`v-if`比较学习 --&gt;&lt;template&gt; &lt;div v-show=\"isShow\"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; isShow: false &#125;; &#125; &#125;;&lt;/script&gt; v-if 作用： 根据表达式的值的真假条件渲染元素 12345678910111213&lt;!-- #ps: 请和`v-if`比较学习 --&gt;&lt;template&gt; &lt;div v-if=\"isShow\"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; isShow: true &#125;; &#125; &#125;;&lt;/script&gt; v-show vs v-if12# 同： 根据表达式值的真假都可以达到隐藏和显示节点的效果# 异： v-show改变的是css 的display属性。v-if在切换时元素及它的数据绑定 / 组件被销毁并重建 v-else 限制：前一兄弟元素必须有 v-if 或 v-else-if。 12345678910111213141516&lt;!-- #ps: 前面必须有兄弟元素使用了 v-if 或者 v-else-if 才可 --&gt;&lt;template&gt; &lt;div&gt; &lt;div v-if=\"isShow\"&gt; &lt;div v-else&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; isShow: true &#125; &#125;&#125;&lt;/script&gt; v-for 作用： 基于源数据多次渲染元素或模板块 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!-- #ps: 源数据类型可以是 number、Array、Object--&gt;&lt;template&gt; &lt;div&gt; &lt;!-- 源数据是number --&gt; &lt;ul&gt; &lt;li v-for=\"item in n\" :key=\"item\"&gt; &#123;&#123;item&#125;&#125; &lt;/li&gt; &lt;ul&gt; &lt;!-- 源数据是Object --&gt; &lt;ul&gt; &lt;li v-for=\"(value, name, index) in student\" :key=\"item\"&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125; &lt;/li&gt; &lt;ul&gt; &lt;!-- 源数据是Array --&gt; &lt;!-- 当它们处于同一节点，v-for 的优先级比 v-if 更高 --&gt; &lt;ul&gt; &lt;li v-for=\"(item, index) in schedules\" :key=\"index\" v-if=\"item.isShow\"&gt; &#123;&#123;item.goal&#125;&#125; &lt;/li&gt; &lt;ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; n: 7, student: &#123; name: 'zhangsan', sex: 'male', nation: 'china' &#125; schedules: [ &#123; goal: '一周时间刷一边vue官网', isShow: true &#125;, &#123; goal: '用10天时间刷一边react官网', isShow: true &#125;, &#123; goal: '用半月时间熟悉vue 和 react全家桶', isShow: false &#125; ] &#125; &#125;&#125;&lt;/script&gt; 源数据更新123456789101112# 变异方法：push()pop()shift()unshift()splice()sort()reverse()# 非变异方法filter()concat()slice() 12345678910111213export defult &#123; mounted () &#123; // 变异方法的使用 this.schedules.push(&#123; goal: \"学习js算法基础知识\", isShow: false &#125;) // 非变异方法的使用 this.schedules = this.schedules.filter(item =&gt; &#123; return item.isShow &#125;) &#125;&#125; 注意Vue 不能检测以下数组的变动： 1234# 当你利用索引直接设置一个数组项时this.schedules[indexOfItem] = newValue# 可以这样解决this.$set(this.schedules, indexOfItem, newValue) 1234# 当你修改数组的长度时this.schedules.length = newLength# 可以这样解决：this.schedules.splice(newLength) Vue 不能检测对象属性的添加或删除： 1234567891011121314var vm = new Vue(&#123; data: &#123; student: &#123; name: \"zhangsan\", sex: \"male\", nation: \"china\" &#125; &#125;&#125;);// `vm.student.name` 现在是响应式的vm.student.age = 27;// `vm.student.age` 不是响应式的// 可以这样解决：this.$set(this.student, \"age\", 27); v-model 作用: 实现双向数据绑定 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;template&gt; &lt;div&gt; &lt;form&gt; &lt;div action=\"/login\" method=\"post\"&gt; &lt;label&gt;用户名：&lt;label&gt; &lt;input v-model.trim=\"userName\" type=\"text\" placeholder=\"请输入用户名\"&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;密码：&lt;label&gt; &lt;input v-model.lazy.trim=\"userPassword\" type=\"password\" placeholder=\"请输入密码\"&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;是否关联第三放帐号：&lt;label&gt; &lt;input v-model=\"isRelationThirdPartAccNo\" value=\"true\" type=\"radio\"/&gt;是 &lt;input v-model=\"isRelationThirdPartAccNo\" value=\"false\" type=\"radio\"/&gt;否 &lt;/div&gt; &lt;div v-if=\"isRelationThirdPartAccNo === 'true'\"&gt; &lt;input v-model=\"thirdPartAccNos\" value=\"wechat\" type=\"checbox\"/&gt;微信 &lt;input v-model=\"thirdPartAccNos\" value=\"email\" type=\"checbox\"/&gt;邮箱 &lt;input v-model=\"thirdPartAccNos\" value=\"qq\" type=\"checbox\"/&gt;qq &lt;/div&gt; &lt;div&gt; &lt;label&gt;地址：&lt;/label&gt; &lt;select v-model=\"province\"&gt; &lt;option disabled value=\"\"&gt;请选择您所在省&lt;/option&gt; &lt;option v-for=\"(item, index) in provinces\" :value=\"item.code\"&gt;&#123;&#123;item.text&#125;&#125;&lt;/option&gt; &lt;/select&gt;-- &lt;select v-model=\"city\"&gt; &lt;option disabled value=\"\"&gt;请选择您所在市区&lt;/option&gt; &lt;option v-for=\"(item, index) in cities\" :value=\"item.code\"&gt;&#123;&#123;item.text&#125;&#125;&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;详细地址：&lt;/label&gt; &lt;textarea v-model=\"address\"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; userName: '', userPassword: '', isRelationThirdPartAccNo: '', thirdPartAccNos: [], province: '', provinces: [ &#123; code: '620',// 省份代码 text: '甘肃' &#125;, &#123; code: '320',// 省份代码 text: '江苏' &#125; ], city: '', cities: [], address: '' &#125;， computed: &#123; cities () &#123; if (this.province === '320') &#123; return [ &#123; value: '3201', text: '南京' &#125;, &#123; value: '3202', text: '苏州' &#125;, &#123; value: '3201', text: '常州' &#125; ] &#125; &#125; &#125;&#125;&lt;/script&gt; v-on 作用： 绑定事件监听器 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;!-- 方法处理器 --&gt; &lt;button v-on:click=\"doThis\"&gt;&lt;/button&gt; &lt;!-- 动态事件 (2.6.0+) --&gt; &lt;button v-on:[event]=\"doThis\"&gt;&lt;/button&gt; &lt;!-- 内联语句 --&gt; &lt;button v-on:click=\"doThat('hello', $event)\"&gt;&lt;/button&gt; &lt;!-- 缩写 --&gt; &lt;button @click=\"doThis\"&gt;&lt;/button&gt; &lt;!-- 动态事件缩写 (2.6.0+) --&gt; &lt;button @[event]=\"doThis\"&gt;&lt;/button&gt; &lt;!-- 停止冒泡 --&gt; &lt;button @click.stop=\"doThis\"&gt;&lt;/button&gt; &lt;!-- 阻止默认行为 --&gt; &lt;button @click.prevent=\"doThis\"&gt;&lt;/button&gt; &lt;!-- 阻止默认行为，没有表达式 --&gt; &lt;form @submit.prevent&gt;&lt;/form&gt; &lt;!-- 串联修饰符 --&gt; &lt;button @click.stop.prevent=\"doThis\"&gt;&lt;/button&gt; &lt;!-- 键修饰符，键别名 --&gt; &lt;input @keyup.enter=\"onEnter\" /&gt; &lt;!-- 键修饰符，键代码 --&gt; &lt;input @keyup.13=\"onEnter\" /&gt; &lt;!-- 点击回调只会触发一次 --&gt; &lt;button v-on:click.once=\"doThis\"&gt;&lt;/button&gt; &lt;!-- 对象语法 (2.4.0+) --&gt; &lt;button v-on=\"&#123; mousedown: doThis, mouseup: doThat &#125;\"&gt;&lt;/button&gt;&lt;/template&gt; v-bind 作用：动态地绑定一个或多个特性，或一个组件 prop 到表达式。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt;&lt;!-- 绑定一个属性 --&gt;&lt;img v-bind:src=\"imageSrc\"&gt;&lt;!-- 动态特性名 (2.6.0+) --&gt;&lt;button v-bind:[key]=\"value\"&gt;&lt;/button&gt;&lt;!-- 缩写 --&gt;&lt;img :src=\"imageSrc\"&gt;&lt;!-- 动态特性名缩写 (2.6.0+) --&gt;&lt;button :[key]=\"value\"&gt;&lt;/button&gt;&lt;!-- 内联字符串拼接 --&gt;&lt;img :src=\"'/path/to/images/' + fileName\"&gt;&lt;!-- class 绑定 --&gt;&lt;div :class=\"&#123; red: isRed &#125;\"&gt;&lt;/div&gt;&lt;div :class=\"[classA, classB]\"&gt;&lt;/div&gt;&lt;div :class=\"[classA, &#123; classB: isB, classC: isC &#125;]\"&gt;&lt;!-- style 绑定 --&gt;&lt;div :style=\"&#123; fontSize: size + 'px' &#125;\"&gt;&lt;/div&gt;&lt;div :style=\"[styleObjectA, styleObjectB]\"&gt;&lt;/div&gt;&lt;!-- 绑定一个有属性的对象 --&gt;&lt;div v-bind=\"&#123; id: someProp, 'other-attr': otherProp &#125;\"&gt;&lt;/div&gt;&lt;!-- 通过 prop 修饰符绑定 DOM 属性 --&gt;&lt;div v-bind:text-content.prop=\"text\"&gt;&lt;/div&gt;&lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;&lt;my-component :prop=\"someThing\"&gt;&lt;/my-component&gt;&lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&gt;&lt;child-component v-bind=\"$props\"&gt;&lt;/child-component&gt;&lt;!-- XLink --&gt;&lt;svg&gt;&lt;a :xlink:special=\"foo\"&gt;&lt;/a&gt;&lt;/svg&gt;&lt;/template&gt; v-slot 作用： 为插槽传入 prop 的时候使用 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!-- 定义一个插槽模板 --&gt;&lt;div class=\"container\"&gt; &lt;header&gt; &lt;!-- 具名插槽 --&gt; &lt;slot name=\"header\"&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;!-- 默认插槽 --&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=\"footer\"&gt;&lt;/slot&gt; &lt;/footer&gt; &lt;!-- 向具名插槽提供内容 --&gt; &lt;base-layout&gt; &lt;template v-slot:header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt; &lt;/template&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;template v-slot:footer&gt; &lt;p&gt;Here's some contact info&lt;/p&gt; &lt;/template&gt; &lt;/base-layout&gt; &lt;!-- 渲染结果 --&gt; &lt;div class=\"container\"&gt; &lt;header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;/main&gt; &lt;footer&gt; &lt;p&gt;Here's some contact info&lt;/p&gt; &lt;/footer&gt; &lt;/div&gt;&lt;/div&gt; 注意： v-slot 只能添加在一个 &lt;template&gt; 上 v-pre 作用： 跳过这个元素和它的子元素的编译过程 123&lt;template&gt; &lt;span v-pre&gt;&#123;&#123; this will not be compiled &#125;&#125;&lt;/span&gt;&lt;/template&gt; v-cloak 作用： 指令保持在元素上直到关联实例结束编译。 v-once 作用： 只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过 123&lt;template&gt; &lt;span v-once&gt;This will never change: &#123;&#123;msg&#125;&#125;&lt;/span&gt;&lt;/template&gt;","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}],"keywords":[]},{"title":"js基础算法","slug":"js数据结构和算法系列1","date":"2019-10-21T18:04:51.528Z","updated":"2019-10-21T18:04:51.528Z","comments":true,"path":"2019/10/21/js数据结构和算法系列1/","link":"","permalink":"http://yoursite.com/2019/10/21/js数据结构和算法系列1/","excerpt":"js基础算法","text":"js基础算法 实现一个js栈12345678910111213141516171819202122232425262728293031323334353637383940class Stack &#123; constructor() &#123; this.items = []; &#125; // 入栈或者压栈 push(ele) &#123; this.items.push(ele); &#125; // 移除栈顶元素 pop() &#123; this.items.pop(); &#125; // 返回栈顶的元素 peek() &#123; return this.items[this.items.length - 1]; &#125; // 判断是否为空 isEmpty() &#123; return this.items.length === 0; &#125; // 长度 size() &#123; return this.item.length; &#125;&#125;function sysConvertToBinary(decimal) &#123; let stack = new Stack(); let remainder; while (decimal &gt; 0) &#123; reminder = decimal % 2; decimal = Math.floor(decimal / 2); stack.push(remainder); &#125; let str = ''; while(!stack.isEmpth()) &#123; str += stack.pop(); &#125; return str;&#125;console.log(sysConvertToBinary(101)); // 110011","categories":[],"tags":[{"name":"js算法","slug":"js算法","permalink":"http://yoursite.com/tags/js算法/"}],"keywords":[]},{"title":"js数组flat方法","slug":"js数组扁平化（flat）方法总结","date":"2019-09-10T06:11:32.031Z","updated":"2019-09-10T06:11:32.031Z","comments":true,"path":"2019/09/09/js数组扁平化（flat）方法总结/","link":"","permalink":"http://yoursite.com/2019/09/09/js数组扁平化（flat）方法总结/","excerpt":"实现js数组flat方法","text":"实现js数组flat方法","categories":[],"tags":[{"name":"jsApi","slug":"jsApi","permalink":"http://yoursite.com/tags/jsApi/"}],"keywords":[]},{"title":"剖析并且自己手动编写javascript API","slug":"剖析并且自己手动编写API","date":"2019-09-10T02:53:59.338Z","updated":"2019-09-10T02:53:59.338Z","comments":true,"path":"2019/09/09/剖析并且自己手动编写API/","link":"","permalink":"http://yoursite.com/2019/09/09/剖析并且自己手动编写API/","excerpt":"自己手动编写jsApi","text":"自己手动编写jsApi 1.用es5实现数组的map方法12345678Array.prototype.myMap = (fn, context) =&gt; &#123; let mappedArr = []; let arr = Array.prototype.slice.call(this); for(let i = 0; i &lt; arr.length; i++) &#123; mappedArr.push(fn.call(context, arr[i], i, this)); &#125; return mappedArr;&#125; 2.用es5实现数组的reduce方法123456789Array.prototype.myReduce = (fn, initialValue) =&gt; &#123; let arr = Array.prototype.slice.call(this); let res = initialValue ? initialValue : arr[0]; let startIndex = initialValue ? 0 : 1; for(let i = startIndex; i &lt; arr.length; i++) &#123; res = fn.call(null, res, arr[startIndex]); &#125; return mappedArr;&#125; 3.实现call/apply123456789// 实现apply只要把下面的...args 换成 argsFunction.prototype.myCall = (context = window, ...args) =&gt; &#123; let func = this; let fn = Symbol('fn'); context[fn] = func; let res = context[fn](...args\"fn\"); // 相当于 context.caller(...args); delete context[fn]; return res; &#125; 4.实现对象的Object.create()方法123456Object.create = (proto) =&gt; &#123; function F() &#123;&#125;; F.prototype = proto; F.prototype.constructor = F; return new F();&#125; 5.实现bind方法12345678Function.prototype.myBind = (context, ...args) =&gt; &#123; let self = this;// 谨记this指向调用bind的函数 let fBound = function() &#123; return self.apply(this instanceof fBound ? this : context || window, args); &#125; fBound.prototype = object.create(this.prototype); // 保证函数原型上的属性不丢失 return fBound;&#125; 6.实现new关键字12345function myNew(fn, ...args) &#123; let instance = Object.create(fn.prototype); let res = fn.apply(instance, args); return typeof res === 'object' ? res : instance;&#125; 7.实现instanceof的作用12345678function myInstanceof(left, right) &#123; let proto = Oject.getPrototypeOf(left); while(true) &#123; if (proto === null) return false; if (proto === right.prototype) return true; proto = Oject.getProtypeOf(proto); &#125;&#125; 8.实现单例模式123456789101112function proxy() &#123; let instance; let handler = &#123; constructor(target, args) &#123; if(!instance) &#123; instance = Reflect.contructor(fun, args); &#125; return instance; &#125; &#125;; return new Proxy(func, handler);&#125; `","categories":[],"tags":[{"name":"jsApi","slug":"jsApi","permalink":"http://yoursite.com/tags/jsApi/"}],"keywords":[]},{"title":"网易云接口说明文档","slug":"网易云接口说明文档","date":"2019-09-10T00:34:11.026Z","updated":"2019-09-10T00:34:11.026Z","comments":true,"path":"2019/09/09/网易云接口说明文档/","link":"","permalink":"http://yoursite.com/2019/09/09/网易云接口说明文档/","excerpt":"网易云接口说明文档","text":"网易云接口说明文档 NeteaseCloudMusicApi网易云音乐 NodeJS 版 API 灵感来自disoul/electron-cloud-music darknessomi/musicbox sqaiyan/netmusic-node 工作原理跨站请求伪造 (CSRF), 伪造请求头 , 调用官方 API 功能特性 登录 刷新登录 发送验证码 校验验证码 注册(修改密码) 获取用户信息 , 歌单，收藏，mv, dj 数量 获取用户歌单 获取用户电台 获取用户关注列表 获取用户粉丝列表 获取用户动态 获取用户播放记录 获取精品歌单 获取歌单详情 搜索 搜索建议 获取歌词 歌曲评论 收藏单曲到歌单 专辑评论 歌单评论 mv 评论 电台节目评论 banner 获取歌曲详情 获取专辑内容 获取歌手单曲 获取歌手 mv 获取歌手专辑 获取歌手描述 获取相似歌手 获取相似歌单 相似 mv 获取相似音乐 获取最近 5 个听了这首歌的用户 获取每日推荐歌单 获取每日推荐歌曲 私人 FM 签到 喜欢音乐 垃圾桶 歌单 ( 网友精选碟 ) 新碟上架 热门歌手 最新 mv 推荐 mv 推荐歌单 推荐新音乐 推荐电台 推荐节目 独家放送 mv 排行 获取 mv 数据 播放 mv/视频 排行榜 歌手榜 云盘 电台 - 推荐 电台 - 分类 电台 - 分类推荐 电台 - 订阅 电台 - 详情 电台 - 节目 给评论点赞 获取动态 热搜列表(简略) 发送私信 发送私信歌单 新建歌单 收藏/取消收藏歌单 歌单分类 收藏的歌手列表 订阅的电台列表 相关歌单推荐 付费精选接口 音乐是否可用检查接口 登录状态 获取视频播放地址 发送/删除评论 热门评论 视频评论 退出登录 所有榜单 所有榜单内容摘要 收藏视频 收藏 MV 视频详情 相关视频 关注用户 新歌速递 喜欢音乐列表(无序) 收藏的 MV 列表 获取最新专辑 听歌打卡 获取视频标签下的视频 已收藏专辑列表 获取动态评论 歌单收藏者列表 云盘歌曲删除 热门话题 电台 - 推荐类型 电台 - 非热门类型 电台 - 今日优选 心动模式/智能播放 转发动态 删除动态 分享歌曲、歌单、mv、电台、电台节目到动态 通知-私信 通知-评论 通知-@我 通知-通知 设置 云盘数据详情 私信内容 我的数字专辑 batch批量请求接口 获取视频标签列表 全部mv 网易出品mv 收藏/取消收藏专辑 专辑动态信息 热搜列表(详细) 更换绑定手机 检测手机号码是否已注册 初始化昵称 更新歌单描述 更新歌单名 更新歌单标签 默认搜索关键词 安装123$ git clone git@github.com:Binaryify/NeteaseCloudMusicApi.git$ npm install 运行1$ node app.js 服务器启动默认端口为 3000, 若不想使用 3000 端口 , 可使用以下命令 : Mac/Linux 1$ PORT=4000 node app.js windows 下使用 git-bash 或者 cmder 等终端执行以下命令 : 1$ set PORT=4000 &amp;&amp; node app.js 可以使用代理在 query 参数中加上 proxy=your-proxy 即可让这一次的请求使用 proxy 12345678// 例子const url = `http://localhost:3000/song/url?id=33894312&amp;proxy=http://121.196.226.246:84`fetch(url).then(function() &#123; // do what you want&#125;)// 结果// &#123;\"data\":[&#123;\"id\":33894312,\"url\":\"http://m10.music.126.net/20180104125640/930a968b3fb04908b733506b3833e60b/ymusic/0fd6/4f65/43ed/a8772889f38dfcb91c04da915b301617.mp3\",\"br\":320000,\"size\":10691439,\"md5\":\"a8772889f38dfcb91c04da915b301617\",\"code\":200,\"expi\":1200,\"type\":\"mp3\",\"gain\":-2.0E-4,\"fee\":0,\"uf\":null,\"payed\":0,\"flag\":0,\"canExtend\":false&#125;],\"code\": 200&#125; v3.3.0 后支持使用 PAC代理,如 ?proxy=http://192.168.0.1/proxy.pac 更新到 v3.0 说明!&gt;2018.10.14 更新到 3.0.0,使用了模块化机制,因为部分接口参数和 url 做了调整,如还不想升级到 3.0.0,请查看 v2 的文档, 更新日志, 2.0+下载地址, 同时 2.0+ 将不再维护 Docker 容器运行 注意: 在 docker 中运行的时候, 由于使用了 request 来发请求, 所以会检查几个 proxy 相关的环境变量(如下所列), 这些环境变量 会影响到 request 的代理, 详情请参考request 的文档, 如果这些环境变量 指向的代理不可用, 那么就会造成错误, 所以在使用 docker 的时候一定要注意这些环境变量. 不过, 要是你在 query 中加上了 proxy 参数, 那么环境变量会被覆盖, 就会用你通过 proxy 参数提供的代理了. request 相关的环境变量 http_proxy https_proxy HTTP_PROXY HTTPS_PROXY no_proxy NO_PROXY 1234567891011121314docker pull binaryify/netease_cloud_music_apidocker run -d -p 3000:3000 --name netease_cloud_music_api binaryify/netease_cloud_music_api// 或者 docker run -d -p 3000:3000 binaryify/netease_cloud_music_api// 去掉或者设置相关的环境变量docker run -d -p 3000:3000 --name netease_cloud_music_api -e http_proxy= -e https_proxy= -e no_proxy= -e HTTP_PROXY= -e HTTPS_PROXY= -e NO_PROXY= binaryify/netease_cloud_music_api// 或者docker run -d -p 3000:3000 -e http_proxy= -e https_proxy= -e no_proxy= -e HTTP_PROXY= -e HTTPS_PROXY= -e NO_PROXY= binaryify/netease_cloud_music_api 以下是自行 build docker 镜像方式 12345$ git clone https://github.com/Binaryify/NeteaseCloudMusicApi &amp;&amp; cd NeteaseCloudMusicApi$ sudo docker build . -t netease-music-api$ sudo docker run -d -p 3000:3000 netease-music-api 接口文档调用前须知!&gt; 本项目不提供线上 demo，请不要轻易信任使用他人提供的公开服务，以免发生安全问题,泄露自己的账号和密码 !&gt; 为使用方便,降低门槛, 文档示例接口直接使用了 GET 请求,本项目同时支持 GET/POST 请按实际需求使用 !&gt; 由于接口做了缓存处理 ( 缓存 2 分钟,不缓存数据极容易引起网易服务器高频ip错误 , 可在 app.js 设置 , 可能会导致登陆后获取不到 cookie), 相同的 url 会在两分钟内只向网易服务器发一次请求 , 如果遇到不需要缓存结果的接口 , 可在请求 url 后面加一个时间戳参数使 url 不同 , 例子 :/simi/playlist?id=347230&amp;timestamp=1503019930000 (之所以加入缓存机制是因为项目早期没有缓存机制，很多 issues 都是报 IP高频，请按自己需求改造缓存中间件(app.js)，源码不复杂) !&gt; 如果是跨域请求 , 请在所有请求带上 xhrFields: { withCredentials: true } (axios 为 withCredentials: true)否则可能会因为没带上 cookie 导致 301, 具体例子可看 public/test.html, 例子使用 jQuery 和 axios !&gt; 301 错误基本都是没登录就调用了需要登录的接口,如果登陆了还是提示 301, 基本都是缓存把数据缓存起来了,解决方法是加时间戳或者等待 2 分钟或者重启服务重新登录后再调用接口,可自行改造缓存方法 !&gt; 部分接口如登录接口不能调用太频繁 , 否则可能会触发 503 错误或者 ip 高频错误 ,若需频繁调用 , 需要准备 IP 代理池 (更新:已加入缓存机制,但仍需注意). !&gt; 本项目仅供学习使用,请尊重版权，请勿利用此项目从事商业行为 !&gt; 文档可能会有缓存 , 如果文档版本和 github 上的版本不一致,请清除缓存再查看 !&gt; 由于网易限制,此项目在国外服务器上使用会受到限制,如需解决 , 可使用大陆服务器或者使用代理 , 感谢 @hiyangguo提出的解决方法:在 ‘/util/request.js’ 的 ‘headers’ 处增加 X-Real-IP&#39;:&#39;211.161.244.70&#39; // 任意国内 IP即可解决 !&gt; 图片加上 ?param=宽y高 可控制图片尺寸，如 http://p4.music.126.net/JzNK4a5PjjPIXAgVlqEc5Q==/109951164154280311.jpg?param=200y200, http://p4.music.126.net/JzNK4a5PjjPIXAgVlqEc5Q==/109951164154280311.jpg?param=50y50 登录说明 : 登录有两个接口 1. 手机登录必选参数 : phone: 手机号码 password: 密码 接口地址 : /login/cellphone 可选参数 : countrycode: 国家码，用于国外手机号登陆，例如美国传入：1 调用例子 : /login/cellphone?phone=xxx&amp;password=yyy 2. 邮箱登录~~ 注意 : 此接口被网易和谐了 , 待修复 , 暂时使用手机登录 (2017.05.20)~~ 更新 : 此接口已经可以正常使用(2018.07.03) 必选参数 : email: 163 网易邮箱password: 密码 接口地址 : /login 调用例子 : `/login?email=xxx@163.com&amp;password=yyy` 返回数据如下图 : 完成登录后 , 会在浏览器保存一个 Cookies 用作登录凭证 , 大部分 API 都需要用到这个Cookies 注意调用登录接口的速度比调用其他接口慢 , 因为登录过程调用了加密算法 刷新登录说明 : 调用此接口 , 可刷新登录状态 调用例子 : /login/refresh 发送验证码说明 : 调用此接口 ,传入手机号码, 可发送验证码 必选参数 : phone: 手机号码 可选参数 :ctcode: 国家区号,默认86即中国 接口地址 : /captcha/sent 调用例子 : /captcha/sent?phone=13xxx 验证验证码说明 : 调用此接口 ,传入手机号码和验证码, 可校验验证码是否正确 必选参数 : phone: 手机号码 captcha: 验证码 可选参数 : ctcode: 国家区号,默认86即中国 接口地址 : /captcha/verify 调用例子 : /captcha/verify?phone=13xxx&amp;captcha=1597 注册(修改密码)说明 : 调用此接口 ,传入手机号码和验证码,密码,昵称, 可注册网易云音乐账号(同时可修改密码) 必选参数 : captcha: 验证码 phone : 手机号码 password: 密码 nickname: 昵称 接口地址 : /register/cellphone 调用例子 : /register/cellphone?phone=13xxx&amp;password=xxxxx&amp;captcha=1234&amp;nickname=binary1345 检测手机号码是否已注册说明 : 调用此接口 ,可检测手机号码是否已注册必选参数 :phone : 手机号码 接口地址 : /cellphone/existence/check 调用例子 : /cellphone/existence/check?phone=13xxx 初始化昵称说明 : 刚注册的账号(需登录),调用此接口 ,可初始化昵称必选参数 :nickname : 昵称 接口地址 : /activate/initProfile 调用例子 : /activate/initProfile?nickname=testUser2019 更换绑定手机说明 : 调用此接口 ,可更换绑定手机(流程:先发送验证码到原手机号码,再发送验证码到新手机号码然后再调用此接口) 必选参数 :oldcaptcha: 原手机验证码 captcha: 新手机验证码 phone : 手机号码 ctcode : 国家区号,默认86即中国 接口地址 : /rebind 调用例子 : /rebind?phone=xxx&amp;oldcaptcha=1234&amp;captcha=5678 退出登录说明 : 调用此接口 , 可退出登录 调用例子 : /logout 登录状态说明 : 调用此接口,可获取登录状态 接口地址 : /login/status返回数据如下图: 获取用户详情说明 : 登陆后调用此接口 , 传入用户 id, 可以获取用户详情 必选参数 : uid : 用户 id 接口地址 : /user/detail 调用例子 : /user/detail?uid=32953014 获取用户信息 , 歌单，收藏，mv, dj 数量说明 : 登陆后调用此接口 , 可以获取用户信息 接口地址 : /user/subcount 调用例子 : /user/subcount 更新用户信息说明 : 登陆后调用此接口 , 传入相关信息,可以更新用户信息 必选参数 : 1234567891011gender: 性别 0:保密 1:男性 2:女性birthday: 出生日期,时间戳 unix timestampnickname: 用户昵称province: 省份idcity: 城市idsignature：用户签名 接口地址 : /user/update 调用例子 : /user/update?gender=0&amp;signature=测试签名&amp;city=440300&amp;nickname=binary&amp;birthday=1525918298004&amp;province=440000 获取用户歌单说明 : 登陆后调用此接口 , 传入用户 id, 可以获取用户歌单 必选参数 : uid : 用户 id 接口地址 : /user/playlist 调用例子 : /user/playlist?uid=32953014 返回数据如下图 : 更新歌单说明 : 登陆后调用此接口,可以更新用户歌单参数: 1234567id:歌单idname:歌单名字desc:歌单描述tags:歌单tag 接口地址 : /playlist/update 调用例子 : /playlist/update?id=24381616&amp;name=新歌单&amp;desc=描述&amp;tags=学习 更新歌单描述说明 : 登陆后调用此接口,可以单独更新用户歌单描述参数: 123id:歌单iddesc:歌单描述 接口地址 : /playlist/desc/update 调用例子 : /playlist/desc/update?id=24381616&amp;desc=描述 更新歌单名说明 : 登陆后调用此接口,可以单独更新用户歌单名参数: 123id: 歌单idname: 歌单名 接口地址 : /playlist/name/update 调用例子 : /playlist/name/update?id=24381616&amp;name=歌单名 更新歌单标签说明 : 登陆后调用此接口,可以单独更新用户歌单标签参数: 123id: 歌单idtags: 歌单标签 接口地址 : /playlist/tags/update 调用例子 : /playlist/tags/update?id=24381616&amp;tags=学习 获取用户电台说明 : 登陆后调用此接口 , 传入用户 id, 可以获取用户电台 必选参数 : uid : 用户 id 接口地址 : /user/dj 调用例子 : /user/dj?uid=32953014 获取用户关注列表说明 : 登陆后调用此接口 , 传入用户 id, 可以获取用户关注列表 必选参数 : uid : 用户 id 可选参数 : limit : 返回数量 , 默认为 30 offset : 偏移数量，用于分页 , 如: 如 :( 页数 -1)*30, 其中 30 为 limit 的值 , 默认为 0 接口地址 : /user/follows 调用例子 : /user/follows?uid=32953014 获取用户粉丝列表说明 : 登陆后调用此接口 , 传入用户 id, 可以获取用户粉丝列表 必选参数 : uid : 用户 id 可选参数 : limit : 返回数量 , 默认为 30 lasttime : 返回数据的 lasttime ,默认-1,传入上一次返回结果的 lasttime,将会返回下一页的数据 接口地址 : /user/followeds 调用例子 : /user/followeds?uid=32953014 /user/followeds?uid=416608258&amp;time=1560152549136 获取用户动态说明 : 登陆后调用此接口 , 传入用户 id, 可以获取用户动态 必选参数 : uid : 用户 id 可选参数 : limit : 返回数量 , 默认为 30 lasttime : 返回数据的 lasttime ,默认-1,传入上一次返回结果的 lasttime,将会返回下一页的数据 接口地址 : /user/event 调用例子 : /user/event?uid=32953014 /user/event?uid=32953014&amp;limit=1&amp;lasttime=1558011138743 转发用户动态说明 : 登陆后调用此接口 ,可以转发用户动态 必选参数 : uid : 用户 id evId : 动态 id forwards : 转发的评论 接口地址 : /event/forward 调用例子 : /event/forward?evId=6712917601&amp;uid=32953014&amp;forwards=测试内容 如下图 删除用户动态说明 : 登陆后调用此接口 ,可以删除用户动态 必选参数 : evId : 动态 id 接口地址 : /event/del 调用例子 : /event/del?evId=6712917601 分享歌曲、歌单、mv、电台、电台节目到动态说明 : 登陆后调用此接口 ,可以分享歌曲、歌单、mv、电台、电台节目到动态 必选参数 : id : 资源 id （歌曲，歌单，mv，电台，电台节目对应 id） 可选参数 : type: 资源类型，默认歌曲 song，可传 song,playlist,mv,djradio,djprogram msg: 内容，140 字限制，支持 emoji，@用户名（/user/follows接口获取的用户名，用户名后和内容应该有空格），图片暂不支持 接口地址 : /share/resource 调用例子 : /share/resource?id=1297494209&amp;msg=测试 /share/resource?type=djradio&amp;id=336355127 /share/resource?type=djprogram&amp;id=2061034798 /share/resource?type=djprogram&amp;id=2061034798&amp;msg=测试@binaryify 测试 获取动态评论说明 : 登陆后调用此接口 , 可以获取动态下评论 必选参数 : threadId : 动态 id，可通过 /event，/user/event 接口获取 接口地址 : /comment/event 调用例子 : /comment/event?threadId=A_EV_2_6559519868_32953014 关注/取消关注用户说明 : 登陆后调用此接口 , 传入用户 id, 和操作 t,可关注/取消关注用户 必选参数 : id : 用户 id t : 1为关注,其他为取消关注 接口地址 : /follow 调用例子 : /follow?id=32953014&amp;t=1 获取用户播放记录说明 : 登陆后调用此接口 , 传入用户 id, 可获取用户播放记录 必选参数 : uid : 用户 id 可选参数 : type : type=1 时只返回 weekData, type=0 时返回 allData 接口地址 : /user/record 调用例子 : /user/record?uid=32953014&amp;type=1 获取热门话题说明 : 调用此接口 , 可获取热门话题 可选参数 : limit: 取出评论数量 , 默认为 20 offset: 偏移数量 , 用于分页 , 如 :( 评论页数 -1)*20, 其中 20 为 limit 的值 接口地址 : /hot/topic 调用例子 : /hot/topic?limit=30&amp;offset=30 心动模式/智能播放说明 : 调用此接口 , 可获取心动模式/智能播放列表必选参数 : id : 歌曲 id pid : 歌单 id 可选参数 :sid : 要开始播放的歌曲的 id 接口地址 : /playmode/intelligence/list 调用例子 : /playmode/intelligence/list?id=33894312&amp;pid=24381616 , /playmode/intelligence/list?id=33894312&amp;pid=24381616&amp;sid=36871368 获取动态消息说明 : 调用此接口 , 可获取各种动态 , 对应网页版网易云，朋友界面里的各种动态消息，如分享的视频，音乐，照片等！ 必选参数 :pagesize : 每页数据,默认20 lasttime : 返回数据的 lasttime ,默认-1,传入上一次返回结果的 lasttime,将会返回下一页的数据 接口地址 : /event 调用例子 : /event?pagesize=30&amp;lasttime=1556740526369 歌手分类列表说明 : 调用此接口,可获取歌手分类列表必选参数 : cat : 即 category Code,歌手类型,默认 1001,返回华语男歌手数据可选参数 : limit : 返回数量 , 默认为 30 offset : 偏移数量，用于分页 , 如: 如 :( 页数 -1)*30, 其中 30 为 limit 的值 , 默认为 0initial: 按首字母索引查找参数,如 /artist/list?cat=1001&amp;initial=b 返回内容将以 name 字段开头为 b 或者拼音开头为 b 为顺序排列 category Code 取值: 12345678910111213141516171819202122232425262728293031入驻歌手 5001华语男歌手 1001华语女歌手 1002华语组合/乐队 1003欧美男歌手 2001欧美女歌手 2002欧美组合/乐队 2003日本男歌手 6001日本女歌手 6002日本组合/乐队 6003韩国男歌手 7001韩国女歌手 7002韩国组合/乐队 7003其他男歌手 4001其他女歌手 4002其他组合/乐队 4003 接口地址 : /artist/list 调用例子 : /artist/list?cat=1001 返回数据如下图: 收藏/取消收藏歌手说明 : 调用此接口,可收藏歌手 必选参数 : artistId : 歌手 id t:操作,1 为收藏,其他为取消收藏 接口地址 : /artist/sub 调用例子 : /artist/sub?id=6452&amp;t=1 收藏的歌手列表说明 : 调用此接口,可获取收藏的歌手列表 接口地址 : /artist/sublist 调用例子 : /artist/sublist 收藏视频说明 : 调用此接口,可收藏视频 必选参数 : id : 视频 id t : 1 为收藏,其他为取消收藏 接口地址 : /video/sub 调用例子 : /video/sub 收藏/取消收藏 MV说明 : 调用此接口,可收藏/取消收藏 MV 必选参数 : id : MV id t : 1 为收藏,其他为取消收藏 接口地址 : /mv/sub 调用例子 : /mv/sub 收藏的 MV 列表说明 : 调用此接口,可获取收藏的 MV 列表 接口地址 : /mv/sublist 调用例子 : /mv/sublist 歌单分类说明 : 调用此接口,可获取歌单分类,包含 category 信息 接口地址 : /playlist/catlist 调用例子 : /playlist/catlist 热门歌单分类说明 : 调用此接口,可获取歌单分类,包含 category 信息 接口地址 : /playlist/hot 调用例子 : /playlist/hot 歌单 ( 网友精选碟 )说明 : 调用此接口 , 可获取网友精选碟歌单 可选参数 : order: 可选值为 ‘new’ 和 ‘hot’, 分别对应最新和最热 , 默认为‘hot’ cat:cat: tag, 比如 “ 华语 “、” 古风 “ 、” 欧美 “、” 流行 “, 默认为“全部”,可从歌单分类接口获取(/playlist/catlist) 接口地址 : /top/playlist 调用例子 : /top/playlist?limit=10&amp;order=new 返回数据如下图 : 获取精品歌单说明 : 调用此接口 , 可获取精品歌单 可选参数 : cat: tag, 比如 “ 华语 “、” 古风 “ 、” 欧美 “、” 流行 “, 默认为“全部”,可从歌单分类接口获取(/playlist/catlist) limit: 取出歌单数量 , 默认为 20 before: 分页参数,取上一页最后一个歌单的 updateTime 获取下一页数据 接口地址 : /top/playlist/highquality 调用例子 : http://localhost:3000/top/playlist/highquality?before=1503639064232&amp;limit=3 相关歌单推荐说明 : 调用此接口,传入歌单 id 可获取相关歌单(对应页面 https://music.163.com/#/playlist?id=1) 必选参数 : id : 歌单 id 接口地址 : /related/playlist 调用例子 : /related/playlist?id=1 获取歌单详情说明 : 歌单能看到歌单名字 , 但看不到具体歌单内容 , 调用此接口 , 传入歌单 id, 可以获取对应歌单内的所有的音乐，但是返回的trackIds是完整的，tracks 则是不完整的，可拿全部 trackIds 请求一次 song/detail 接口获取所有歌曲的详情 (https://github.com/Binaryify/NeteaseCloudMusicApi/issues/452) 必选参数 : id : 歌单 id 可选参数 : s : 歌单最近的 s 个收藏者 接口地址 : /playlist/detail 调用例子 : /playlist/detail?id=24381616 返回数据如下图 : 获取音乐 url说明 : 使用歌单详情接口后 , 能得到的音乐的 id, 但不能得到的音乐 url, 调用此接口, 传入的音乐 id( 可多个 , 用逗号隔开 ), 可以获取对应的音乐的 url( 不需要登录 ) 注 : 部分用户反馈获取的 url 会 403,hwaphon找到的解决方案是当获取到音乐的 id 后，将https://music.163.com/song/media/outer/url?id=id.mp3 以 src 赋予 Audio 即可播放 必选参数 : id : 音乐 id 可选参数 : br: 码率,默认设置了 999000 即最大码率,如果要 320k 则可设置为 320000,其他类推 接口地址 : /song/url 调用例子 : /song/url?id=33894312 /song/url?id=405998841,33894312 返回数据如下图 : 音乐是否可用说明: 调用此接口,传入歌曲 id, 可获取音乐是否可用,返回 { success: true, message: &#39;ok&#39; } 或者 { success: false, message: &#39;亲爱的,暂无版权&#39; } 必选参数 : id : 歌曲 id 可选参数 : br: 码率,默认设置了 999000 即最大码率,如果要 320k 则可设置为 320000,其他类推 接口地址 : /check/music 调用例子 : /check/music?id=33894312 搜索说明 : 调用此接口 , 传入搜索关键词可以搜索该音乐 / 专辑 / 歌手 / 歌单 / 用户 ,关键词可以多个 , 以空格隔开 , 如 “ 周杰伦 搁浅 “( 不需要登录 ), 搜索获取的mp3url 不能直接用 , 可通过 /song/url 接口传入歌曲 id 获取具体的播放链接 必选参数 : keywords : 关键词 可选参数 : limit : 返回数量 , 默认为 30 offset : 偏移数量，用于分页 , 如: 如 :( 页数 -1)*30, 其中 30 为 limit 的值 , 默认为 0 type: 搜索类型；默认为 1 即单曲 , 取值意义 : 1: 单曲, 10: 专辑, 100: 歌手, 1000:歌单, 1002: 用户, 1004: MV, 1006: 歌词, 1009: 电台, 1014: 视频, 1018:综合 接口地址 : /search 调用例子 : /search?keywords= 海阔天空 返回数据如下图 : 默认搜索关键词说明 : 调用此接口 , 可获取默认搜索关键词 接口地址 : /search/default 热搜列表(简略)说明 : 调用此接口,可获取热门搜索列表 接口地址 : /search/hot 调用例子 : /search/hot 热搜列表(详细)说明 : 调用此接口,可获取热门搜索列表 接口地址 : /search/hot/detail 调用例子 : /search/hot/detail 搜索建议说明 : 调用此接口 , 传入搜索关键词可获得搜索建议 , 搜索结果同时包含单曲 , 歌手 ,歌单 ,mv 信息 必选参数 : keywords : 关键词 可选参数 : type : 如果传 ‘mobile’ 则返回移动端数据 接口地址 : /search/suggest 调用例子 : /search/suggest?keywords= 海阔天空 /search/suggest?keywords= 海阔天空&amp;type=mobile 搜索多重匹配说明 : 调用此接口 , 传入搜索关键词可获得搜索结果 必选参数 : keywords : 关键词 接口地址 : /search/multimatch 调用例子 : /search/multimatch?keywords= 海阔天空 新建歌单说明 : 调用此接口 , 传入歌单名字可新建歌单 必选参数 : name : 歌单名 可选参数 : privacy : 是否设置为隐私歌单，默认否，传’10’则设置成隐私歌单 接口地址 : /playlist/create 调用例子 : /playlist/create?name=测试歌单 返回数据如下图: 收藏/取消收藏歌单说明 : 调用此接口 , 传入类型和歌单 id 可收藏歌单或者取消收藏歌单 必选参数 : t : 类型,1:收藏,2:取消收藏id : 歌单 id 接口地址 : /playlist/subscribe 调用例子 : /playlist/subscribe?t=1&amp;id=106697785 /playlist/subscribe?t=2&amp;id=106697785 返回数据如下图: 歌单收藏者说明 : 调用此接口 , 传入歌单 id 可获取歌单的所有收藏者必选参数 : id : 歌单 id 可选参数 : limit: 取出评论数量 , 默认为 20 offset: 偏移数量 , 用于分页 , 如 :( 评论页数 -1)*20, 其中 20 为 limit 的值 接口地址 : /playlist/subscribers 调用例子 : /playlist/subscribers?id=544215255&amp;limit=30 对歌单添加或删除歌曲说明 : 调用此接口 , 可以添加歌曲到歌单或者从歌单删除某首歌曲 ( 需要登录 ) 必选参数 : op: 从歌单增加单曲为 add, 删除为 del pid: 歌单 idtracks: 歌曲 id,可多个,用逗号隔开 接口地址 : /playlist/tracks 调用例子 : /playlist/tracks?op=add&amp;pid=24381616&amp;tracks=347231 ( 对应把歌曲添加到 ‘ 我 ‘ 的歌单 , 测试的时候请把这里的 pid 换成你自己的, id 和 tracks 不对可能会报 502 错误) 获取歌词说明 : 调用此接口 , 传入音乐 id 可获得对应音乐的歌词 ( 不需要登录 ) 必选参数 : id: 音乐 id 接口地址 : /lyric 调用例子 : /lyric?id=33894312 返回数据如下图 : 新歌速递说明 : 调用此接口 , 可获取新歌速递 必选参数 : type: 地区类型 id,对应以下: 123456789全部:0华语:7欧美:96日本:8韩国:16 接口地址 : /top/song 调用例子 : /top/song?type=96 歌曲评论说明 : 调用此接口 , 传入音乐 id 和 limit 参数 , 可获得该音乐的所有评论 ( 不需要登录 ) 必选参数 : id: 音乐 id 可选参数 : limit: 取出评论数量 , 默认为 20 offset: 偏移数量 , 用于分页 , 如 :( 评论页数 -1)*20, 其中 20 为 limit 的值 before: 分页参数,取上一页最后一项的 time 获取下一页数据(获取超过5000条评论的时候需要用到) 接口地址 : /comment/music 调用例子 : /comment/music?id=186016&amp;limit=1 对应晴天评论 返回数据如下图 : 专辑评论说明 : 调用此接口 , 传入音乐 id 和 limit 参数 , 可获得该专辑的所有评论 ( 不需要登录 ) 必选参数 : id: 专辑 id 可选参数 : limit: 取出评论数量 , 默认为 20 offset: 偏移数量 , 用于分页 , 如 :( 评论页数 -1)*20, 其中 20 为 limit 的值 before: 分页参数,取上一页最后一项的 time 获取下一页数据(获取超过5000条评论的时候需要用到) 接口地址 : /comment/album 调用例子 : /comment/album?id=32311 歌单评论说明 : 调用此接口 , 传入音乐 id 和 limit 参数 , 可获得该歌单的所有评论 ( 不需要登录 ) 必选参数 : id: 歌单 id 可选参数 : limit: 取出评论数量 , 默认为 20 offset: 偏移数量 , 用于分页 , 如 :( 评论页数 -1)*20, 其中 20 为 limit 的值 before: 分页参数,取上一页最后一项的 time 获取下一页数据(获取超过5000条评论的时候需要用到) 接口地址 : /comment/playlist 调用例子 : /comment/playlist?id=705123491 mv 评论说明 : 调用此接口 , 传入音乐 id 和 limit 参数 , 可获得该 mv 的所有评论 ( 不需要登录 ) 必选参数 : id: mv id 可选参数 : limit: 取出评论数量 , 默认为 20 offset: 偏移数量 , 用于分页 , 如 :( 评论页数 -1)*20, 其中 20 为 limit 的值 before: 分页参数,取上一页最后一项的 time 获取下一页数据(获取超过5000条评论的时候需要用到) 接口地址 : /comment/mv 调用例子 : /comment/mv?id=5436712 电台节目评论说明 : 调用此接口 , 传入音乐 id 和 limit 参数 , 可获得该 电台节目 的所有评论 (不需要登录 ) 必选参数 : id: 电台节目的 id 可选参数 : limit: 取出评论数量 , 默认为 20 offset: 偏移数量 , 用于分页 , 如 :( 评论页数 -1)*20, 其中 20 为 limit 的值 before: 分页参数,取上一页最后一项的 time 获取下一页数据(获取超过5000条评论的时候需要用到) 接口地址 : /comment/dj 调用例子 : /comment/dj?id=794062371 视频评论说明 : 调用此接口 , 传入音乐 id 和 limit 参数 , 可获得该 视频 的所有评论 (不需要登录 ) 必选参数 : id: 视频的 id 可选参数 : limit: 取出评论数量 , 默认为 20 offset: 偏移数量 , 用于分页 , 如 :( 评论页数 -1)*20, 其中 20 为 limit 的值 before: 分页参数,取上一页最后一项的 time 获取下一页数据(获取超过5000条评论的时候需要用到) 接口地址 : /comment/video 调用例子 : /comment/video?id=89ADDE33C0AAE8EC14B99F6750DB954D 热门评论说明 : 调用此接口 , 传入 type, 资源 id 可获得对应资源热门评论 ( 不需要登录 ) 必选参数 : id : 资源 id tpye: 数字 , 资源类型 , 对应歌曲 , mv, 专辑 , 歌单 , 电台, 视频对应以下类型 12345678910110: 歌曲1: mv2: 歌单3: 专辑4: 电台5: 视频 可选参数 : limit: 取出评论数量 , 默认为 20 offset: 偏移数量 , 用于分页 , 如 :( 评论页数 -1)*20, 其中 20 为 limit 的值 before: 分页参数,取上一页最后一项的 time 获取下一页数据(获取超过5000条评论的时候需要用到) 接口地址 : /comment/hot 调用例子 : /comment/hot?id=186016&amp;type=0 给评论点赞说明 : 调用此接口 , 传入 type, 资源 id, 和评论 id cid 和 是否点赞参数 t 即可给对应评论点赞 ( 需要登录 ) 必选参数 : id : 资源 id, 如歌曲 id,mv id cid : 评论 id t : 是否点赞 ,1 为点赞 ,0 为取消点赞 tpye: 数字 , 资源类型 , 对应歌曲 , mv, 专辑 , 歌单 , 电台, 视频对应以下类型 123456789101112130: 歌曲1: mv2: 歌单3: 专辑4: 电台5: 视频6: 动态 接口地址 : comment/like 调用例子 : /comment/like?id=29178366&amp;cid=12840183&amp;t=1&amp;type=0 对应给 https://music.163.com/#/song?id=29178366 最热门的评论点赞 注意： 动态点赞不需要传入 id 参数，需要传入动态的 threadId 参数,如：/comment/like?type=6&amp;cid=1419532712&amp;threadId=A_EV_2_6559519868_32953014&amp;t=0， threadId 可通过 /event，/user/event 接口获取 发送/删除评论说明 : 调用此接口,可发送评论或者删除评论 接口地址 : /comment 发送评论 必选参数 t:1 发送 tpye: 数字,资源类型,对应歌曲,mv,专辑,歌单,电台,视频对应以下类型 123456789101112130: 歌曲1: mv2: 歌单3: 专辑4: 电台5: 视频6: 动态 id:对应资源 id content :要发送的内容 调用例子 : /comment?t=1&amp;type=1&amp;id=5436712&amp;content=test (往广岛之恋 mv 发送评论: test) 注意：如给动态发送评论，则不需要传 id，需要传动态的 threadId,如：/comment?t=1&amp;type=6&amp;threadId=A_EV_2_6559519868_32953014&amp;content=test 删除评论 必选参数 t:0 删除 tpye: 数字,资源类型,对应歌曲,mv,专辑,歌单,电台,视频对应以下类型 12345678910111213140: 歌曲1: mv2: 歌单3: 专辑4: 电台5: 视频6: 动态 id:对应资源 id content :内容 id,可通过 /comment/mv 等接口获取 调用例子 : /comment?t=0&amp;type=1&amp;id=5436712&amp;commentId=1535550516319 (在广岛之恋 mv 删除评论) 注意：如给动态删除评论，则不需要传 id，需要传动态的 `threadId`,如：`/comment?t=0&amp;type=6&amp;threadId=A_EV_2_6559519868_32953014&amp;commentId=1419516382` banner说明 : 调用此接口 , 可获取 banner( 轮播图 ) 数据 可选参数 : type:资源类型,对应以下类型,默认为 0 即PC 12345670: pc1: android2: iphone3: ipad 接口地址 : /banner 调用例子 : /banner, /banner?type=2 资源点赞( MV,电台,视频)说明 : 调用此接口 , 可对 MV,电台,视频点赞 必选参数 : type:资源类型,对应以下类型 12345671: mv4: 电台5: 视频6: 动态 t: 操作,1 为点赞,其他未取消点赞 id: 资源 id 接口地址 : /resource/like 调用例子 : /resource/like?t=1&amp;type=1&amp;id=5436712 注意：如给动态点赞，不需要传入 id，需要传入 threadId,可通过 event,/user/event 接口获取，如：/resource/like?t=1&amp;type=6&amp;threadId=A_EV_2_6559519868_32953014 获取歌曲详情说明 : 调用此接口 , 传入音乐 id(支持多个 id, 用 , 隔开), 可获得歌曲详情(注意:歌曲封面现在需要通过专辑内容接口获取) 必选参数 : ids: 音乐 id, 如 ids=347230 接口地址 : /song/detail 调用例子 : /song/detail?ids=347230,/song/detail?ids=347230,347231 返回数据如下图 : 获取专辑内容说明 : 调用此接口 , 传入专辑 id, 可获得专辑内容 必选参数 : id: 专辑 id 接口地址 : /album 调用例子 : /album?id=32311 返回数据如下图 : 专辑动态信息说明 : 调用此接口 , 传入专辑 id, 可获得专辑动态信息,如是否收藏,收藏数,评论数,分享数 必选参数 : id: 专辑 id 接口地址 : /album/detail/dynamic 调用例子 : /album/detail/dynamic?id=32311 收藏/取消收藏专辑说明 : 调用此接口,可收藏/取消收藏专辑 必选参数 : id : 专辑 id t : 1 为收藏,其他为取消收藏 接口地址 : /album/sub 调用例子 : /album/sub?t=1 /album/sub?t=0 获取已收藏专辑列表说明 : 调用此接口 , 可获得已收藏专辑列表 可选参数 :limit: 取出数量 , 默认为 25 offset: 偏移数量 , 用于分页 , 如 :( 页数 -1)*25, 其中 25 为 limit 的值 , 默认为 0 接口地址 : /album/sublist 调用例子 : /album/sublist ( 周杰伦 ) 获取歌手单曲说明 : 调用此接口 , 传入歌手 id, 可获得歌手部分信息和热门歌曲 必选参数 : id: 歌手 id, 可由搜索接口获得 接口地址 : /artists 调用例子 : /artists?id=6452 返回数据如下图 : 获取歌手 mv说明 : 调用此接口 , 传入歌手 id, 可获得歌手 mv 信息 , 具体 mv 播放地址可调用/mv传入此接口获得的 mvid 来拿到 , 如 :/artist/mv?id=6452,/mv?mvid=5461064 必选参数 : id: 歌手 id, 可由搜索接口获得 接口地址 : /artist/mv 调用例子 : /artist/mv?id=6452 获取歌手专辑说明 : 调用此接口 , 传入歌手 id, 可获得歌手专辑内容 必选参数 : id: 歌手 id 可选参数 : limit: 取出数量 , 默认为 50 offset: 偏移数量 , 用于分页 , 如 :( 页数 -1)*50, 其中 50 为 limit 的值 , 默认为 0 接口地址 : /artist/album 调用例子 : /artist/album?id=6452&amp;limit=30 ( 周杰伦 ) 返回数据如下图 : 获取歌手描述说明 : 调用此接口 , 传入歌手 id, 可获得歌手描述 必选参数 : id: 歌手 id 接口地址 : /artist/desc 调用例子 : /artist/desc?id=6452 ( 周杰伦 ) 获取相似歌手说明 : 调用此接口 , 传入歌手 id, 可获得相似歌手 必选参数 : id: 歌手 id 接口地址 : /simi/artist 调用例子 : /simi/artist?id=6452 ( 对应和周杰伦相似歌手 ) 获取相似歌单说明 : 调用此接口 , 传入歌曲 id, 可获得相似歌单 必选参数 : id: 歌曲 id 接口地址 : /simi/playlist 调用例子 : /simi/playlist?id=347230 ( 对应 ‘ 光辉岁月 ‘ 相似歌单 ) 相似 mv说明 : 调用此接口 , 传入 mvid 可获取相似 mv 必选参数 : mvid: mv id 接口地址 : /simi/mv 调用例子 : /simi/mv?mvid=5436712 获取相似音乐说明 : 调用此接口 , 传入歌曲 id, 可获得相似歌曲 必选参数 : id: 歌曲 id 接口地址 : /simi/song 调用例子 : /simi/song?id=347230 ( 对应 ‘ 光辉岁月 ‘ 相似歌曲 ) 获取最近 5 个听了这首歌的用户说明 : 调用此接口 , 传入歌曲 id, 最近 5 个听了这首歌的用户 必选参数 : id: 歌曲 id 接口地址 : /simi/user 调用例子 : /simi/user?id=347230 ( 对应 ‘ 光辉岁月 ‘ 相似歌曲 ) 获取每日推荐歌单说明 : 调用此接口 , 可获得每日推荐歌单 ( 需要登录 ) 接口地址 : /recommend/resource 调用例子 : /recommend/resource 返回数据如下图 : 获取每日推荐歌曲说明 : 调用此接口 , 可获得每日推荐歌曲 ( 需要登录 ) 接口地址 : /recommend/songs 调用例子 : /recommend/songs 返回数据如下图 : 私人 FM说明 : 私人 FM( 需要登录 ) 接口地址 : /personal_fm 调用例子 : /personal_fm 返回数据如下图 : 签到说明 : 调用此接口 , 传入签到类型 ( 可不传 , 默认安卓端签到 ), 可签到 ( 需要登录), 其中安卓端签到可获得 3 点经验 , web/PC 端签到可获得 2 点经验 可选参数 : type: 签到类型 , 默认 0, 其中 0 为安卓端签到 ,1 为 web/PC 签到 接口地址 : /daily_signin 调用例子 : /daily_signin 返回数据如下图 : 喜欢音乐说明 : 调用此接口 , 传入音乐 id, 可喜欢该音乐 必选参数 : id: 歌曲 id 可选参数 : like: 布尔值 , 默认为 true 即喜欢 , 若传 false, 则取消喜欢 接口地址 : /like 调用例子 : /like?id=347230 返回数据如下图 : 喜欢成功则返回数据的 code 为 200, 其余为失败 喜欢音乐列表说明 : 调用此接口 , 传入用户 id, 可获取已喜欢音乐id列表(id数组) 必选参数 : uid: 用户 id 接口地址 : /likelist 调用例子 : /likelist?uid=32953014 垃圾桶说明 : 调用此接口 , 传入音乐 id, 可把该音乐从私人 FM 中移除至垃圾桶 必选参数 : id: 歌曲 id 接口地址 : /fm_trash 调用例子 : /fm_trash?id=347230 返回数据如下图 : 新碟上架说明 : 调用此接口 , 可获取新碟上架列表 , 如需具体音乐信息需要调用获取专辑列表接口 /album , 然后传入 id, 如 /album?id=32311&amp;limit=30 可选参数 : limit: 取出数量 , 默认为 50 offset: 偏移数量 , 用于分页 , 如 :( 页数 -1)*50, 其中 50 为 limit 的值 , 默认为 0 接口地址 : /top/album 调用例子 : /top/album?offset=0&amp;limit=30 返回数据如下图 : 最新专辑说明 : 调用此接口 ，获取云音乐首页新碟上架数据 接口地址 : /album/newest 调用例子 : /album/newest 听歌打卡说明 : 调用此接口 , 传入音乐 id, 来源 id，歌曲时间 time，更新听歌排行数据 必选参数 : id: 歌曲 id, sourceid: 歌单或专辑 id 可选参数 : time: 歌曲播放时间,单位为秒 接口地址 : /scrobble 调用例子 : /scrobble?id=518066366&amp;sourceid=36780169&amp;time=291 热门歌手说明 : 调用此接口 , 可获取热门歌手数据 可选参数 : limit: 取出数量 , 默认为 50 offset: 偏移数量 , 用于分页 , 如 :( 页数 -1)*50, 其中 50 为 limit 的值 , 默认为 0 接口地址 : /top/artists 调用例子 : /top/artists?offset=0&amp;limit=30 返回数据如下图 : 全部 mv说明 : 调用此接口 , 可获取全部 mv 可选参数 :area: 地区,可选值为全部,内地,港台,欧美,日本,韩国,不填则为全部type: 类型,可选值为全部,官方版,原生,现场版,网易出品,不填则为全部 order: 排序,可选值为上升最快,最热,最新,不填则为上升最快 limit: 取出数量 , 默认为 30 offset: 偏移数量 , 用于分页 , 如 :( 页数 -1)*50, 其中 50 为 limit 的值 , 默认为 0 接口地址 : /mv/all 调用例子 : /mv/all?area=港台 最新 mv说明 : 调用此接口 , 可获取最新 mv 可选参数 : area: 地区,可选值为全部,内地,港台,欧美,日本,韩国,不填则为全部 可选参数 : limit: 取出数量 , 默认为 30 接口地址 : /mv/first 调用例子 : /mv/first?limit=10 网易出品mv说明 : 调用此接口 , 可获取网易出品 mv 可选参数 : limit: 取出数量 , 默认为 30 offset: 偏移数量 , 用于分页 , 如 :( 页数 -1)*30, 其中 30 为 limit 的值 , 默认为 0 接口地址 : /mv/exclusive/rcmd 调用例子 : /mv/exclusive/rcmd?limit=10 推荐 mv说明 : 调用此接口 , 可获取推荐 mv 接口地址 : /personalized/mv 调用例子 : /personalized/mv 推荐歌单说明 : 调用此接口 , 可获取推荐歌单 接口地址 : /personalized 调用例子 : /personalized 推荐新音乐说明 : 调用此接口 , 可获取推荐新音乐 接口地址 : /personalized/newsong 调用例子 : /personalized/newsong 推荐电台说明 : 调用此接口 , 可获取推荐电台 接口地址 : /personalized/djprogram 调用例子 : /personalized/djprogram 推荐节目说明 : 调用此接口 , 可获取推荐电台 接口地址 : /program/recommend 调用例子 : /program/recommend 独家放送说明 : 调用此接口 , 可获取独家放送 接口地址 : /personalized/privatecontent 调用例子 : /personalized/privatecontent mv 排行说明 : 调用此接口 , 可获取 mv 排行 可选参数 : limit: 取出数量 , 默认为 30 area: 地区,可选值为内地,港台,欧美,日本,韩国,不填则为全部 offset: 偏移数量 , 用于分页 , 如 :( 页数 -1)*30, 其中 30 为 limit 的值 , 默认为 0 接口地址 : /top/mv 调用例子 : /top/mv?limit=10 获取 mv 数据说明 : 调用此接口 , 传入 mvid ( 在搜索音乐的时候传 type=1004 获得 ) , 可获取对应MV 数据 , 数据包含 mv 名字 , 歌手 , 发布时间 , mv 视频地址等数据 , 其中 mv 视频网易做了防盗链处理 , 可能不能直接播放 , 需要播放的话需要调用 ‘ mv 地址’ 接口 必选参数 : mvid: mv 的 id 接口地址 : /mv/detail 调用例子 : /mv/detail?mvid=5436712 返回数据如下图 : mv 地址说明 : 调用此接口 , 传入 mv id,可获取 mv 播放地址 可选参数 : url: mv id 接口地址 : /mv/url 调用例子 : /mv/url?id=5436712 获取视频标签列表说明 : 调用此接口 , 可获取视频标签列表 接口地址 : /video/group/list 调用例子 : /video/group/list 获取视频标签下的视频说明 : 调用此接口 , 传入id,可获取到相关的视频。 (ps：无法分页，每次请求返回内容都不一样，官方桌面软件是打开先请求两次，然后每次滚动到底部的时候再请求一次) 必选参数 : id: videoGroup 的 id 接口地址 : /video/group 调用例子 : /video/group?id=9104 相关视频说明 : 调用此接口 , 可获取相关视频 必选参数 : id: 视频 的 id 接口地址 : /related/allvideo 调用例子 : /related/allvideo?id=89ADDE33C0AAE8EC14B99F6750DB954D 视频详情说明 : 调用此接口 , 可获取视频详情 必选参数 : id: 视频 的 id 接口地址 : /video/detail 调用例子 : /video/detail?id=89ADDE33C0AAE8EC14B99F6750DB954D 获取视频播放地址说明 : 调用此接口 , 传入视频 id,可获取视频播放地址 必选参数 : id: 视频 的 id 接口地址 : /video/url 调用例子 : /video/url?id=89ADDE33C0AAE8EC14B99F6750DB954D 返回数据如下图 : 排行榜说明 : 调用此接口 , 传入数字 idx, 可获取不同排行榜 必选参数 : idx: 对象 key, 对应以下排行榜 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&quot;0&quot;: 云音乐新歌榜,&quot;1&quot;: 云音乐热歌榜,&quot;2&quot;: 网易原创歌曲榜,&quot;3&quot;: 云音乐飙升榜,&quot;4&quot;: 云音乐电音榜,&quot;5&quot;: UK排行榜周榜,&quot;6&quot;: 美国Billboard周榜&quot;7&quot;: KTV嗨榜,&quot;8&quot;: iTunes榜,&quot;9&quot;: Hit FM Top榜,&quot;10&quot;: 日本Oricon周榜&quot;11&quot;: 韩国Melon排行榜周榜,&quot;12&quot;: 韩国Mnet排行榜周榜,&quot;13&quot;: 韩国Melon原声周榜,&quot;14&quot;: 中国TOP排行榜(港台榜),&quot;15&quot;: 中国TOP排行榜(内地榜)&quot;16&quot;: 香港电台中文歌曲龙虎榜,&quot;17&quot;: 华语金曲榜,&quot;18&quot;: 中国嘻哈榜,&quot;19&quot;: 法国 NRJ EuroHot 30周榜,&quot;20&quot;: 台湾Hito排行榜,&quot;21&quot;: Beatport全球电子舞曲榜,&quot;22&quot;: 云音乐ACG音乐榜,&quot;23&quot;: 云音乐嘻哈榜 接口地址 : /top/list 调用例子 : /top/list?idx=6 返回数据如下图 : 所有榜单说明 : 调用此接口,可获取所有榜单接口地址 : /toplist 调用例子 : /toplist 所有榜单内容摘要说明 : 调用此接口,可获取所有榜单内容摘要接口地址 : /toplist/detail 调用例子 : /toplist/detail 歌手榜说明 : 调用此接口 , 可获取排行榜中的歌手榜 接口地址 : /toplist/artist 调用例子 : /toplist/artist 云盘说明 : 登陆后调用此接口 , 可获取云盘数据 , 获取的数据没有对应 url, 需要再调用一次 /song/url 获取 url 可选参数 : limit : 返回数量 , 默认为 200 offset : 偏移数量，用于分页 , 如 :( 页数 -1)*200, 其中 200 为 limit 的值 , 默认为 0 接口地址 : /user/cloud 调用例子 : /user/cloud 云盘数据详情说明 : 登陆后调用此接口 , 传入云盘歌曲 id，可获取云盘数据详情 必选参数 : id: 歌曲id,可多个,用逗号隔开 接口地址 : /user/cloud/detail 调用例子 : /user/cloud/detail?id=5374627 云盘歌曲删除说明 : 登陆后调用此接口 , 可删除云盘歌曲 必选参数 : id: 歌曲id,可多个,用逗号隔开 接口地址 : /user/cloud/del 调用例子 : /user/cloud/del 电台 - 推荐说明 : 登陆后调用此接口 , 可获得推荐电台 接口地址 : /dj/recommend 调用例子 : /dj/recommend 电台 - 分类说明 : 登陆后调用此接口 , 可获得电台类型 接口地址 : /dj/catelist 调用例子 : /dj/catelist 电台 - 分类推荐说明 : 登陆后调用此接口 , 可获得推荐电台 必选参数 : type: 电台类型 , 数字 , 可通过/dj/catelist获取 , 对应关系为id 对应 此接口的 type, name 对应类型意义 接口地址 : /dj/recommend/type 调用例子 : /dj/recommend/type?type=1 电台 - 订阅说明 : 登陆后调用此接口 , 传入rid, 可订阅 dj,dj 的 rid 可通过搜索指定type=’1009’ 获取其 id, 如/search?keywords= 代码时间 &amp;type=1009 必选参数 : rid: 电台 的 id 接口地址 : /dj/sub 调用例子 : /dj/sub?rid=336355127&amp;t=1 ( 对应关注 ‘ 代码时间 ‘)/dj/sub?rid=336355127&amp;t=0 ( 对应取消关注 ‘ 代码时间 ‘) 电台的订阅列表说明 : 登陆后调用此接口 , 可获取订阅的电台列表 接口地址 : /dj/sublist 调用例子 : /dj/sublist 电台 - 付费精选说明 : 可以获取付费精选的电台列表 , 传入 limit 和 offset 可以进行分页 可选参数 : limit : 返回数量 , 默认为 30 offset : 偏移数量，用于分页 , 如 :( 页数 -1)*30, 其中 30 为 limit 的值 , 默认为 0 接口地址 : /dj/paygift 调用例子 : /dj/paygift?limit=10&amp;offset=20 电台 - 非热门类型说明 : 登陆后调用此接口, 可获得电台非热门类型 接口地址 : /dj/category/excludehot 调用例子 : /dj/category/excludehot 电台 - 推荐类型说明 : 登陆后调用此接口, 可获得电台推荐类型 接口地址 : /dj/category/recommend 调用例子 : /dj/category/recommend 电台 - 今日优选说明 : 登陆后调用此接口, 可获得电台今日优选 接口地址 : /dj/today/perfered 调用例子 : /dj/today/perfered 电台 - 详情说明 : 登陆后调用此接口 , 传入rid, 可获得对应电台的详情介绍 必选参数 : rid: 电台 的 id 接口地址 : /dj/detail?rid=336355127 调用例子 : /dj/detail?rid=336355127 ( 对应 ‘ 代码时间 ‘ 的详情介绍 ) 电台 - 节目说明 : 登陆后调用此接口 , 传入rid, 可查看对应电台的电台节目以及对应的 id, 需要注意的是这个接口返回的 mp3Url 已经无效 , 都为 null, 但是通过调用 /song/url 这个接口 , 传入节目 id 仍然能获取到节目音频 , 如 /song/url?id=478446370 获取代码时间的一个节目的音频 必选参数 : rid: 电台 的 id 可选参数 : limit : 返回数量 , 默认为 30 offset : 偏移数量，用于分页 , 如 :( 页数 -1)*30, 其中 30 为 limit 的值 , 默认为 0 asc : 排序方式,默认为 false (新 =&gt; 老 ) 设置 true 可改为 老 =&gt; 新 接口地址 : /dj/program 调用例子 : /dj/program?rid=336355127&amp;limit=40 ( 对应 ‘ 代码时间 ‘ 的节目列表 ) 通知 - 私信说明 : 登陆后调用此接口 ,可获取私信 可选参数 : limit : 返回数量 , 默认为 30 offset : 偏移数量，用于分页 , 如 :( 页数 -1)*30, 其中 30 为 limit 的值 , 默认为 0 接口地址 : /msg/private 调用例子 : /msg/private?limit=3 发送私信说明 : 登陆后调用此接口 , 传入用户 id 和要发送的信息, 可以发送私信,返回内容为历史私信,包含带歌单的私信信息(注:不能发送私信给自己) 必选参数 : user_ids : 用户 id,多个需用逗号隔开 msg : 要发送的信息 接口地址 : /send/text 调用例子 : /send/text?user_ids=32953014&amp;msg=test,/send/text?user_ids=32953014,475625142&amp;msg=test返回数据如下图: 私信内容说明 : 登陆后调用此接口 , 可获取私信内容 必选参数 :uid : 用户 id 可选参数 :limit : 返回数量 , 默认为 30 offset : 偏移数量，用于分页 , 如 :( 页数 -1)*30, 其中 30 为 limit 的值 , 默认为 0 接口地址 :/msg/private/history 调用例子 :/msg/private/history?uid=9003 (云音乐小秘书) 发送私信(带歌单)说明 : 登陆后调用此接口 , 传入用户 id 和要发送的信息和歌单 id, 可以发送带歌单的私信(注:不能发送重复的歌单) 必选参数 : user_ids : 用户 id,多个需用逗号隔开 msg : 要发送的信息 接口地址 : /send/playlist 调用例子 : /send/playlist?msg=test&amp;user_ids=475625142&amp;playlist=705123491,/send/playlist?msg=test2&amp;user_ids=475625142,32953014&amp;playlist=705123493返回数据如下图: 通知 - 评论说明 : 登陆后调用此接口 ,可获取评论 必选参数 : uid: 用户 的 id，只能和登录账号的 id 一致 可选参数 : limit : 返回数量 , 默认为 30 before : 分页参数,取上一页最后一个歌单的 updateTime 获取下一页数据 接口地址 : /msg/comments 调用例子 : /msg/comments?uid=32953014 通知 - @我说明 : 登陆后调用此接口 ,可获取@我数据 可选参数 : limit : 返回数量 , 默认为 30 offset : 偏移数量，用于分页 , 如 :( 页数 -1)*30, 其中 30 为 limit 的值 , 默认为 0 接口地址 : /msg/forwards 调用例子 : /msg/forwards?limit=3 通知 - 通知说明 : 登陆后调用此接口 ,可获取通知 可选参数 : limit : 返回数量 , 默认为 30 offset : 偏移数量，用于分页 , 如 :( 页数 -1)*30, 其中 30 为 limit 的值 , 默认为 0 接口地址 : /msg/notices 调用例子 : /msg/notices?limit=3 设置说明 : 登陆后调用此接口 ,可获取用户设置 接口地址 : /setting 调用例子 : /setting 我的数字专辑说明 : 登陆后调用此接口 ,可获取我的数字专辑 接口地址 : /digitalAlbum/purchased 调用例子 : /digitalAlbum/purchased?limit=10 batch批量请求接口说明 : 登陆后调用此接口 ,传入接口和对应原始参数(原始参数非文档里写的参数,需参考源码),可批量请求接口 接口地址 : /batch 调用例子 : 使用GET方式:/batch?/api/v2/banner/get={&quot;clientType&quot;:&quot;pc&quot;} 使用POST方式传入参数:{ &quot;/api/v2/banner/get&quot;: {&quot;clientType&quot;:&quot;pc&quot;} } 离线访问此文档此文档同时也是 Progressive Web Apps(PWA), 加入了 serviceWorker, 可离线访问 关于此文档此文档由 docsify 生成 docsify 是一个动态生成文档网站的工具。不同于 GitBook、Hexo 的地方是它不会生成将 .md 转成 .html文件，所有转换工作都是在运行时进行。 LicenseThe MIT License (MIT)","categories":[],"tags":[{"name":"api","slug":"api","permalink":"http://yoursite.com/tags/api/"}],"keywords":[]},{"title":"react hooks 使用实例","slug":"React Hooks使用实例2","date":"2019-09-10T00:28:35.119Z","updated":"2019-07-22T06:55:45.374Z","comments":true,"path":"2019/09/09/React Hooks使用实例2/","link":"","permalink":"http://yoursite.com/2019/09/09/React Hooks使用实例2/","excerpt":"react hooks 使用实例","text":"react hooks 使用实例 通过reducer来处理dispatch出来的各种actionreducer.ts1234567891011121314151617181920212223242526export const dataFetchReducer = (state: any, action: &#123;[type: string]: any&#125;) =&gt; &#123; switch(action.type) &#123; case 'FETCH_INIT': return &#123; ...state, isLoading: true, isError: false &#125; case 'FETCH_SUCCESS': return &#123; ...state, isLoading: false, isError: false data: action.payload &#125; case 'FETCH_ERROR': return &#123; ...state, isLoading: false, isError: true, msg: action.payload &#125; default: throw new Error(`Unsupport action type:$&#123;action.type&#125;`); &#125;&#125; 自定义一个获取数据的React Hooks1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859interface RequestConfig extends AxiosRequestConfig&#123; url: string&#125;exports const useDataApi = (initData: Array&lt;any&gt; | any, initRequestConfig: RequestConfig) &#123; if (!initRequstConfog.method) &#123; initRequstConfog.method = \"get\"; &#125; const [requestConfig, setRequestConfig] = useState(initRequestConfig); const [state, dispatch] = useReducer(dataFetchReducer, &#123; data: initData, isLoading: false, isError: false &#125;); useEffect(() =&gt; &#123; const fetchData = async () =&gt; &#123; try &#123; dispatch(&#123; type: 'FETCH_INIT' &#125;); if (!requestConfig.url) &#123; dispatch(&#123; type: 'FETCH_SUCCESS', payload: [] &#125;); &#125; else &#123; const response = await axios(requestConfig).catch(e =&gt; return e.response); if (response.data) &#123; const data = response.data; const &#123; success, result, message &#125; = data; if (!success) &#123; dispatch(&#123; type: 'FETCH_ERROR', payload: message &#125;); &#125; else &#123; dispatch(&#123; type: 'FETCH_SUCCESS', payload: result &#125;); &#125; &#125; else &#123; dispatch(&#123; type: 'FETCH_ERROR', payload: '加载数据失败' &#125;); &#125; &#125; &#125; catch(error) &#123; dispatch(&#123; type: 'FETCH_ERROR' msg: '加载数据失败' &#125;); &#125; &#125; &#125;, [requestConfig]); return [state, setRequestConfig]&#125; 使用自定义的Hooks来加载数据1234567891011121314151617181920const [&#123;isLoading, isError, msg, data&#125;, setRequestConfig] = useDataApi([], &#123;url: apiPath&#125;);if (isError) &#123; message.error(msg); return ( &lt;div&gt; &lt;div className=\"toolbar\"&gt; &lt;Link to=&#123;window.location.pathname+ '/detail'&#125; &gt; &lt;Button type=\"primary\" icon=\"plus\" &gt; 添加 &lt;/Button&gt; &lt;/Link&gt; &lt;/div&gt; &lt;CustomModal /&gt; &lt;Table columns=&#123;columns&#125; dataSource=&#123;data&#125; loading=&#123;isLoading&#125; rowKey=&#123;'id'&#125; /&gt; &lt;/div&gt; )&#125;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}],"keywords":[]},{"title":"react hooks 使用实例","slug":"React Hooks使用实例","date":"2019-09-10T00:28:35.107Z","updated":"2019-07-22T06:07:37.877Z","comments":true,"path":"2019/09/09/React Hooks使用实例/","link":"","permalink":"http://yoursite.com/2019/09/09/React Hooks使用实例/","excerpt":"react hooks 使用实例","text":"react hooks 使用实例 使用Suspense 和lazy实现模块懒加载功能123456789import React, &#123;Suspense, lazy&#125; from 'react';const HomePage = lazy(() =&gt; &#123; import('./modeles/home');&#125;);&lt;Suspense fallback=&#123;&lt;div&gt;加载中...&lt;/div&gt;&#125;&gt; &lt;Switch&gt; Route path=\"/home\" component=&#123;HomePage&#125; /&gt; &lt;/Switch&gt;&lt;/Suspense&gt; 使用React Hooks 实现一个自定义的组件12345678910111213141516171819202122232425262728293031export const useModal = (initTitle: string, initContent: string | React.Element) =&gt; &#123; const [visible, setVisible] = useState(false); const [title, setTitle] = useState(initTitle); const [content, setContent] = useState(initContent); const CustomModal = () =&gt; &#123; return ( &lt;Modal visible=&#123;visible&#125; title=&#123;title&#125; closable=&#123;false&#125; footer=&#123;null&#125;&gt; &#123;content&#125; &lt;/Modal&gt; ) &#125; const show = (content?: string | React.ReactElement) =&gt; &#123; content &amp;&amp; setContent(content); setVisible(true); &#125; const hide = (delay?: number) =&gt; &#123; if(delay) &#123; setTimeout(() =&gt; setVisible(false), delay); &#125; else &#123; setVisible(false) &#125; &#125; return &#123; show, hide, CustomModal, setTitle, setContent &#125;&#125; 使用：1234const &#123;hide, show, CustomModal&#125; = useModal('系统提示'， '正在初始化...');render() &#123; &lt;div&gt;&lt;CusomModal /&gt;&lt;/div&gt;&#125;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}],"keywords":[]},{"title":"react组件开发实践","slug":"React组件开发实践","date":"2019-09-10T00:28:35.095Z","updated":"2019-07-22T02:02:21.672Z","comments":true,"path":"2019/09/09/React组件开发实践/","link":"","permalink":"http://yoursite.com/2019/09/09/React组件开发实践/","excerpt":"6 种类型分别为结构型组件、样式型组件、组合型组件、配置型组件、受控型组件、非受控组件","text":"6 种类型分别为结构型组件、样式型组件、组合型组件、配置型组件、受控型组件、非受控组件 结构性组件和样式性组件 12345678910111213/** 样式性组件**/interface ModalProps &#123; tilte: string; content: string;&#125;&lt;Model title=\"title\" content=\"content\" /&gt;/** 结构性组件 **/interface ModalProps &#123; title: React.ReactNode; content: React.ReactNode;&#125;&lt;Modal title=&#123;&lt;h2&gt;Title&lt;/h2&gt;&#125; content=&#123;&lt;input type=\"text\" /&gt;&#125;&gt; 组合型组件和配置型组件 12345678/** 组合型组件 **/&lt;Select defaultValue=\"luck\"&gt; &lt;Seclect.Option value=\"jack\"&gt;jack&lt;/Seclect.Option&gt; &lt;Seclect.Option value=\"lucy\"&gt;lucy&lt;/Seclect.Option&gt;&lt;/Select&gt;/** 配置型组件 **/&lt;Select defaultValue=\"lucy\" options=&#123;['lucy', 'jack']&#125; /&gt; 受控型组件和非受控性组件 12345678910111213141516interface Controlled &#123; value: string; onChange: Function&#125;interface UnControlled &#123; defaultValue?:String;&#125;type inputProps = Controlled | UnControlled;/** 受控性组件 **/&lt;Input value=&#123;value&#125; onChange=&#123;onChange&#125;/&gt;/** 非受控性组件 **/&lt;Input defaultValue=&#123;value&#125; /&gt;;&lt;Input /&gt;;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}],"keywords":[]},{"title":"window下安装redis的教程和基本配置","slug":"windows下安装redis的教程和基本配置","date":"2019-09-10T00:28:35.083Z","updated":"2019-04-10T08:22:07.621Z","comments":true,"path":"2019/09/09/windows下安装redis的教程和基本配置/","link":"","permalink":"http://yoursite.com/2019/09/09/windows下安装redis的教程和基本配置/","excerpt":"Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。","text":"Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。 去官网下载安装包（详细教程可以去菜鸟教程） redis安装包下载地址 将解压缩文件的目录D:\\\\servers\\\\Redis-x64-3.2.100添加到环境变量（dos下可以直接操作） 开启服务 12cd D:\\\\servers\\\\Redis-x64-3.2.100（必须进入到该目录下）D:\\\\servers\\\\Redis-x64-3.2.100&gt; redis-server.exe 再打开一个dos,运行 12cd D:\\\\servers\\\\Redis-x64-3.2.100&gt;D:\\\\servers\\\\Redis-x64-3.2.100&gt;redis-cli.exe 配值权限（默认不具有权限）在上述客户端命令行下： 123CONFIG SET requirepass \"123456\" # 设置密码为 ‘123456’auth \"123456\" # 使用密码登录CONFIG GET requirepass # 查看密码 如何存储数据 12set myKey \"abc\"get myKey # \"abc\"","categories":[],"tags":[{"name":"redis, db","slug":"redis-db","permalink":"http://yoursite.com/tags/redis-db/"}],"keywords":[]},{"title":"Ubuntu 系统下配置远程jdk、mysql服务","slug":"Ubuntu 14.04.3 LTS 系统之指令集","date":"2019-09-10T00:28:35.075Z","updated":"2019-07-22T07:10:47.543Z","comments":true,"path":"2019/09/09/Ubuntu 14.04.3 LTS 系统之指令集/","link":"","permalink":"http://yoursite.com/2019/09/09/Ubuntu 14.04.3 LTS 系统之指令集/","excerpt":"Ubuntu 14.04.3 LTS 系统 &gt;&gt;&gt; 基本指令集合","text":"Ubuntu 14.04.3 LTS 系统 &gt;&gt;&gt; 基本指令集合 linux 指令集123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141======================操作系统信息=====================uname -a # 查看内核 操作系统 CPUcat /proc/version # 查看系统内核head -n 1 /etc/issue # 查看操作系统版本cat /proc/cpuinfo # cat /proc/cpuinfocat /proc/meminfo # 查看存储信息free -m # 查看内存使用量和交换区使用量 grep MemTotal /proc/meminfo # 查看内存总量 grep MemFree /proc/meminfo # 查看空闲内存量 uptime # 查看系统运行时间、用户数、负载df # 查看硬盘信息ps -ef # 查看所有进程 top # 实时显示进程状态lspci |grep VGA # 查看显卡ps -e # 查看进程jps # 查看用户启动的进程sudo kill 7082 # 杀死进程top # 看进程的PID，例如查看eclipse程序所在的目录cd /proc/3093 # 查看该进程的文件夹信息ls -l exe # 查看程序所在的目录nginx -v # 查看ubuntu系统自带的nginx服务器的版本号cwd符号链接的就是进程3093的运行目录；exe符号连接就是执行程序的绝对路径；cmdline就是程序运行时输入的命令行命令；本例为：。/cbscpu记录了进程可能运行在其上的cpu；显示虚拟的cpu信息environ记录了进程运行时的环境变量fd目录下是进程打开或使用的文件的符号连接。。。--------------------- 命令格式：命令 [-选项] [参数]例如：ls -la /etc======================文件处理命令=====================ls -a -l -d -h -i # 列出当前目录下的子目录及其文件pwd # 打印当前工作目录mkidr old # 创建名为old的目录mkdir -p /home/wind/mei # 递归创建目录rmdir old # 只能删除空目录rm -r old # 删除old目录rm -rf old # 强制删除非空目录cp test.java /home # 将test.java文件拷贝到/home目录下cp -r old /home # 将old目录复制到/home路径下mv old new # 将old目录命名为newmv jdk1.8.0_171 /usr/lib/xxx # 将文件从当前目录移动到 /usr/lib/xxx目录下cat # 由第一行开始显示文件内容tac # 文件内容从最后一行开始显示head -n 20 test.sh # 取出文件前面几行tail -n 20 test.sh # 取出文件后面几行more -f /enter # 一页一页翻动less # nl # 显示行号ln # 创建索引文件vi/vim xxx.txt # 若xxx.txt存在则开启编辑模式 反之，则新建该文件并开启编辑模式docker run -d hub.c.163.com/library/nginxwinpty docker run -it 68 bash======================权限管理命令=====================sudosudo su # 进入root权限chmod [&#123;ugoa&#125; &#123;+-=&#125; &#123;rwx&#125;] [文件或目录] # 修改文件或目录的权限chmod [mode = 421] [文件或目录] - R 递归修改注意： 文件： r 权限代表可以 cat/tac/more/less/head/tail w 权限代表可以 vim x 权限代表 可执行 文件类型一般为 script command 目录： r 权限代表可以 ls w 权限代表可以 touch mkdir rmdir rm x 权限代表 cd chown [用户] [文件或目录] # 改变文件或者目录的所有者chgrp [用户组] [文件或目录] # 改变文件或者目录的所有者unmask -S # 显示、设置文件的缺省权限 ======================文件搜索命令=====================find -name .bashrc # 查找文件在什么地方find /ect -name linux # 在etc目录下查找名称linux的文件======================帮助命令==============================================用户管理命令=====================# 用户的管理 ## 增加用户 ## 创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录/usr/sam useradd –d /usr/sam -m sam ## 删除用户 ## 删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录 userdel -r sam ## 修改账号 ## 将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer usermod -s /bin/ksh -d /home/z –g developer sam # 用户口令的管理passwd # 普通用此命令修改自己的口令passwd sam # 超级用户为sam用户修改口令# 用户组的管理 ## 增加一个新的用户组 ## 向系统中增加了一个新组group2，同时指定新组的组标识号是101 groupadd -g 101 group2 ## 删除一个已经存在用户组 ## 删除用户组group2 groupdel group2 ## 修改用户组的属性 ## groupmod –g 10000 -n group3 group2 groupmod –g 10000 -n group3 group2# 用户可以在他所属的多个用户组之间切换newgrp root # 切换到根用户组# 与用户账号有关的文件# 每行的含义：（用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell）cat /etc/passwd======================磁盘命令========================df # 检查文件系统的磁盘空间占用情况du # u命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看fdisk # fdisk 是 Linux 的磁盘分区表操作工具mkfs -t ext3 /dev/hdc6 # mkfs -t ext3 /dev/hdc6fsck -C -f -t ext3 /dev/hdc6 # 强制检测 /dev/hdc6 分区:mkdir /mnt/hdc6mount /dev/hdc6 /mnt/hdc6 # mount /dev/hdc6 /mnt/hdc6umount /dev/hdc6 # 卸载/dev/hdc6======================压缩解压命令=====================touch old # 创建old文件，其他的过程都和目录的操作方法是一样的tar -zxvf jdk-8u171-linux-x64.tar.gz # 解压缩文件======================网络命令========================curl http://www.yahoo.com # www.yahoo.com 的html就稀里哗啦地显示在屏幕上了 rz，sz # 先安装 install lrzsz 是Linux/Unix同Windows进行ZModem文件传输的命令行工具。curl -o page.html http://www.yahoo.com # 你就可以看到屏幕上出现一个下载页面进度指示。等进展到100%，自然就OK咯======================关机重启命令=====================sync # 将数据由内存同步到硬盘中。shutdown # 关机指令shutdown –h 10 # 计算机将在10分钟后关机，并且会显示在登陆用户的当前屏幕中。shutdown –h now # 立马关机shutdown –h 20:25 # 系统会在今天20:25关机shutdown –h +10 # 十分钟后关机shutdown –r now # 系统立马重启shutdown –r +10 # 系统十分钟后重启reboot # 就是重启，等同于 shutdown –r nowhalt # 关闭系统，等同于shutdown –h now 和 poweroffhalt -p # 关闭机器halp --reboot # 重启机器poweroff # 关闭机器poweroff --halt # 停止机器poweroff --reboot # 重启机器reboot # 重启机器reboot --halt # 停止机器reboot -p # 关闭机器","categories":[],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://yoursite.com/tags/ubuntu/"}],"keywords":[]},{"title":"docker 基本指令","slug":"docker基本指令","date":"2019-09-10T00:28:35.067Z","updated":"2019-07-22T07:07:47.951Z","comments":true,"path":"2019/09/09/docker基本指令/","link":"","permalink":"http://yoursite.com/2019/09/09/docker基本指令/","excerpt":"docker 基本指令","text":"docker 基本指令 安装docker 客户端好服务端 官网 查看镜像 1234567 docker images;``` 2. 拉取镜像。[网易蜂巢](https://www.163yun.com/)，注册-&gt;进入控制台-&gt;产品-&gt;镜像中心以拉取tomcat为例，在docker客户端执行：```bashdocker pull hub.c.163.com/library/tomcat:latest 创建tomcat容器 1docker run -ti --name docker-tomcat -p 8088:80 -d hub.c.163.com/library/tomcat:latest 以上参数可以使用 docker run –help 命令查看以上容器创建成功后，会返回进程唯一标识 容器创建成功后，相信你会使用到以下指令 123456789docker psdocker logs -f bf08b7f2cd89 # 查看应用程序日志docker exec -ti bf08b7f2cd89 bash # 进入容器终端docker stop docker-tomcat # 停止docker-tomcat容器docker kill docker-tomcat # 杀死docker-tomcat容器docker restart docker-tomcat # 重启docker-tomcat容器docker rm docker-tomcat # 移除docker-tomcat容器docker port docker-tomcat # 查看网络端口docker inspect docker-tomcat # 检查 WEB 应用程序 构建镜像(在 tomcat中 运行一个jpress.war 文件) 123456789cat Dockerfile # 编写指令===================内容如下======================FROM 72d2be374029MAINTAINER 978189365@qq.comCOPY /home/wind/apps/jpress.war /usr/local/tomcat/webapps================================================docker build -t tomcat-wind-jpress . # 编译docker tag 860c279d2fec runoob/centos:dev # 设置镜像标签 -t ：指定要创建的目标镜像名 . ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}],"keywords":[]},{"title":"window 操作系统下在本机安装mongodb数据库的简单教程","slug":"windows OS 安装mongodb教程","date":"2019-09-10T00:28:35.051Z","updated":"2019-04-10T07:59:57.310Z","comments":true,"path":"2019/09/09/windows OS 安装mongodb教程/","link":"","permalink":"http://yoursite.com/2019/09/09/windows OS 安装mongodb教程/","excerpt":"请先知：window 操作系统下在本机安装mongodb数据库的简单教程","text":"请先知：window 操作系统下在本机安装mongodb数据库的简单教程 跟往常一样，先上官网 mongodb官网 在官网下载安装包(.zip包或.msi),笔者是安装的压缩包）(v-4.0.7) 解压缩包在某个目录下（如：D:\\servers\\mongodb-win32-x86_64-2008plus-ssl-4.0.7） 新建必要目录 12345cd D:\\servers\\mongodb-win32-x86_64-2008plus-ssl-4.0.7\\mkdir datacd datamkdir dbmkdir log 创建配置文件 mongod.cfg，文件内容如下： 12345systemLog: destination: file path: D:\\\\servers\\\\mongodb-win32-x86_64-2008plus-ssl-4.0.7\\\\data\\\\log\\\\mongodb.logstorage: dbPath: D:\\\\servers\\\\mongodb-win32-x86_64-2008plus-ssl-4.0.7\\\\data\\db 安装MongoDB服务 123cd D:\\servers\\mongodb-win32-x86_64-2008plus-ssl-4.0.7\\bin\\D:\\servers\\mongodb-win32-x86_64-2008plus-ssl-4.0.7\\bin\\ mongod.exe --config \"D:\\servers\\mongodb-win32-x86_64-2008plus-ssl-4.0.7\\mongod.cfg\" --install --auth 其中，参数 `auth` 意味着开启权限认证，即连接数据库时需要用户名和密码（用命令行创建即可，后面会提到，怎么创建和修改等）; 启动、关闭和移除MongoDB服务 123net start MongoDB （启动成功后，可以在资源管理器中查看`MonDB`服务）net stop MongoDBD:\\servers\\mongodb-win32-x86_64-2008plus-ssl-4.0.7\\bin\\mongod.exe --remove 创建用户定位到D:\\servers\\mongodb-win32-x86_64-2008plus-ssl-4.0.7\\bin\\，使用mongo.exe进入mongodb的命令行管理。键入命令: 123&gt;use admin&gt;db.createUser(&#123;user: \"root\", pwd: \"123456\", roles:[\"userAdminAnyDatabase\"]&#125;) （新版的 3.0+）好了，现在我们已经为mongodb设置了一个全局用户root（因为使用了表admin），接下来先重启mongodb，使创建的用户生效。 用户登录用命令行进入管理端（同上） 12use admindb.auth('root', '123456'); # 使用root身份登录 如何创建数据库用户首先保证你已经以用户管理员的身份登录 admin 数据库。然后用 use 命令切换到目标数据库，同样用 db.createUser() 命令来创建用户，其中角色名为 “readWrite”。普通的数据库用户角色有两种，read 和 readWrite。顾名思义，前者只能读取数据不能修改，后者可以读取和修改。下面是一个例子： 12345678&gt; use test # 创建数据库test&gt; show dbs # 显示数据库switched to db test&gt; db.createUser(&#123;user:\"wind\",pwd:\"123456\",roles:[\"readWrite\"]&#125;)Successfully added user: &#123; \"user\" : \"testuser\", \"roles\" : [ \"readWrite\" ] &#125;&gt; db.auth(\"wind\",\"123456\")1# 这样 MongoDB 的数据安全性就得到保障了，没有登录的客户端将无法执行任何命令。 最后，推荐一个牛逼的客户端Studio 3T","categories":[],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://yoursite.com/tags/mongodb/"}],"keywords":[]},{"title":"初识Java_Spring 之要点记忆","slug":"初识java_Spring之要点记忆","date":"2019-09-10T00:28:35.043Z","updated":"2019-04-25T00:48:52.890Z","comments":true,"path":"2019/09/09/初识java_Spring之要点记忆/","link":"","permalink":"http://yoursite.com/2019/09/09/初识java_Spring之要点记忆/","excerpt":"Spring 是最受欢迎的企业级 Java 应用程序开发框架，数以百万的来自世界各地的开发人员使用 Spring 框架来创建性能好、易于测试、可重用的代码。","text":"Spring 是最受欢迎的企业级 Java 应用程序开发框架，数以百万的来自世界各地的开发人员使用 Spring 框架来创建性能好、易于测试、可重用的代码。 依赖注入 Spring 最认同的技术是控制反转的依赖注入（DI）模式。 控制反转（IoC）是一个通用的概念，它可以用许多不同的方式去表达，依赖注入仅仅是控制反转的一个具体的例子。 IOC 容器具有依赖注入功能的容器，它可以创建对象，IOC 容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。通常new一个实例，控制权由程序员控制，而”控制反转”是指new实例工作不由程序员来做而是交给Spring容器来做。 Spring 提供了以下两种不同类型的容器 Spring BeanFactory 容器（org.springframework.beans.factory.BeanFactory） Spring ApplicationContext 容器 （org.springframework.context.ApplicationContext） spring 框架: （注：JDBC=Java Data Base Connectivity，ORM=Object Relational Mapping，OXM=Object XML Mapping，JMS=Java Message Service） Spring Bean 如何创建一个 bean bean 的生命周期的详细信息 bean 的依赖关系 定义： bean 是一个被实例化，组装，并通过 Spring IoC 容器所管理的对象（定义一个类，在配置好元数据，然后交给容器去实例这就是bean的定义过程）Bean 与 Spring 容器的关系 作用域：singleton、prototype、request、session和global session 生命周期Bean的生命周期可以表达为： Bean的定义——Bean的初始化——Bean的使用——Bean的销毁 在基于 XML 的配置元数据的情况下，你可以使用 init-method 属性来指定带有 void 无参数方法的名称。例如：1&lt;bean id=\"exampleBean\" class=\"examples.ExampleBean\" init-method=\"init\" destroy-method=\"destroy\"/&gt; 下面是类的定义：123456789public class ExampleBean &#123; public void init() &#123; // do some initialization work &#125;&#125;public class ExampleBean &#123; public void destroy() &#123; // do some destruction work &#125;&#125; 后置处理器Bean 后置处理器允许在调用初始化方法前后对 Bean 进行额外的处理。 123456789101112131415package com.wind;import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanPostProcessor;public class InitHelloWorld implements BeanPostProcessor &#123; public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(\"BeforeInitialization : \" + beanName); return bean; // you can return any other object as well &#125; public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(\"AfterInitialization : \" + beanName); return bean; // you can return any other object as well &#125;&#125; 定义继承 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"helloWorld\" class=\"com.wind.HelloWorld\"&gt; &lt;property name=\"message1\" value=\"Hello World!\"/&gt; &lt;property name=\"message2\" value=\"Hello Second World!\"/&gt; &lt;/bean&gt; &lt;bean id=\"helloIndia\" class=\"com.wind.HelloIndia\" parent=\"helloWorld\"&gt; &lt;property name=\"message1\" value=\"Hello India!\"/&gt; &lt;property name=\"message3\" value=\"Namaste India!\"/&gt; &lt;/bean&gt; &lt;bean class=\"com.wind.InitHelloWorld\" /&gt;&lt;/beans&gt; Spring 依赖注入 通过构造函数注入假设你有一个包含文本编辑器组件的应用程序，并且你想要提供拼写检查。标准代码看起来是这样的：123456public class TextEditor &#123; private SpellChecker spellChecker; public TextEditor() &#123; spellChecker = new SpellChecker(); // 相当于写死啦 &#125;&#125; 在控制反转的场景中，我们反而会做这样的事情：123456public class TextEditor &#123; private SpellChecker spellChecker; public TextEditor(SpellChecker spellChecker) &#123; this.spellChecker = spellChecker; &#125;&#125; 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;!-- Definition for textEditor bean --&gt; &lt;bean id=\"textEditor\" class=\"com.tutorialspoint.TextEditor\"&gt; &lt;property name=\"spellChecker\" ref=\"spellChecker\"/&gt; &lt;/bean&gt; &lt;!-- Definition for spellChecker bean --&gt; &lt;bean id=\"spellChecker\" class=\"com.tutorialspoint.SpellChecker\"&gt; &lt;/bean&gt;&lt;/beans&gt; 通过设置函数注入1234567```javapublic class TextEditor &#123; private SpellChecker spellChecker; public void setSpellChecker(SpellChecker spellChecker) &#123; this.spellChecker = spellChecker; &#125;&#125; 1234567891011121314151617?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;!-- Definition for textEditor bean --&gt; &lt;bean id=\"textEditor\" class=\"com.tutorialspoint.TextEditor\"&gt; &lt;property name=\"spellChecker\" ref=\"spellChecker\"/&gt; &lt;/bean&gt; &lt;!-- Definition for spellChecker bean --&gt; &lt;bean id=\"spellChecker\" class=\"com.tutorialspoint.SpellChecker\"&gt; &lt;/bean&gt;&lt;/beans&gt; 两者唯一区别：就是在基于构造函数注入中，我们使用的是〈bean〉标签中的〈constructor-arg〉元素，而在基于设值函数的注入中，我们使用的是〈bean〉标签中的〈property〉元素。","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}],"keywords":[]},{"title":"java_SpringMVC框架的实现原理及案例分析","slug":"Java_SpringMVC实现原理及详解（下）","date":"2019-09-10T00:28:35.039Z","updated":"2019-05-05T08:17:51.195Z","comments":true,"path":"2019/09/09/Java_SpringMVC实现原理及详解（下）/","link":"","permalink":"http://yoursite.com/2019/09/09/Java_SpringMVC实现原理及详解（下）/","excerpt":"java_SpringMVC框架的实现原理及案例分析","text":"java_SpringMVC框架的实现原理及案例分析 应用程序的流程 源码web.xml1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" version=\"2.5\"&gt; &lt;display-name&gt;springmvc&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- spring入口 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 项目启动时，就加载并实例化 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 拦截所有不包括jsp的请求 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; springmvc-servlet.xml (${servlet-name}-servlet.xml) location=”/WEB-INF/“123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- springmvc注解驱动 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package=\"com\"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置试图解析器 prefix:指定试图所在目录 suffix:指定视图的后缀名 例如：prifex=\"/WEB-INF/jsp/\",suffix=\".jsp\",当viewname=\"test\"时，跳转到/WEB-INF/jsp/test.jsp页面 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; UserControll.java123456789101112131415161718192021@Controller@RequestMapping(\"user\")public class UserController &#123; @RequestMapping(\"findAllUsers\") public ModelAndView findAllUsers() &#123; ModelAndView mv = new ModelAndView(); ArrayList&lt;User&gt; users = new ArrayList&lt;User&gt;(); for (int i = 0; i &lt; 5; i++) &#123; User user = new User(); user.setUsername(\"zs\" + i); user.setAge(20 + i); user.setIncome(16000.0+i*100); user.setIsMarry(false); user.setHobby(new String[] &#123; \"篮球\"+i, \"足球\"+i &#125;); users.add(user); &#125; mv.addObject(\"users\", users); mv.setViewName(\"users\"); return mv; &#125;&#125; User.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class User implements Serializable &#123; /** * */ private static final long serialVersionUID = 1L; private String username; private Integer age; private Boolean isMarry; private Double income; private String[] hobby; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Boolean getIsMarry() &#123; return isMarry; &#125; public void setIsMarry(Boolean isMarry) &#123; this.isMarry = isMarry; &#125; public Double getIncome() &#123; return income; &#125; public void setIncome(Double income) &#123; this.income = income; &#125; public String[] getHobby() &#123; return hobby; &#125; public void setHobby(String[] hobby) &#123; this.hobby = hobby; &#125; @Override public String toString() &#123; return \"User [username=\" + username + \", age=\" + age + \", isMarry=\" + isMarry + \", income=\" + income + \", hobby=\" + Arrays.toString(hobby) + \"]\"; &#125;&#125; JSP页面123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/css/user.css\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;table id=\"customers\"&gt; &lt;tr&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;收入&lt;/th&gt; &lt;th&gt;婚姻状态&lt;/th&gt; &lt;th&gt;兴趣爱好&lt;/th&gt; &lt;/tr&gt; &lt;!-- 遍历后台传递的集合数据 --&gt; &lt;c:forEach items=\"$&#123;users&#125;\" var=\"user\"&gt; &lt;tr&gt; &lt;td&gt;$&#123;user.username&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.income&#125;&lt;/td&gt; &lt;!-- 判婚姻状态 --&gt; &lt;td&gt;&lt;c:choose&gt; &lt;c:when test=\"$&#123;user.isMarry&#125;\"&gt;已婚&lt;/c:when&gt; &lt;c:otherwise&gt;未婚&lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;/td&gt; &lt;td&gt; &lt;!-- 再次遍历用户爱好 --&gt; &lt;c:forEach items=\"$&#123;user.hobby&#125;\" var=\"hobby\" varStatus=\"status\"&gt; $&#123;hobby&#125; &lt;!-- 如果不是最后一个爱好，则加上逗号，否则就不加 --&gt; &lt;c:if test=\"$&#123;!status.last&#125;\"&gt;,&lt;/c:if&gt; &lt;/c:forEach&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"springMVC","slug":"springMVC","permalink":"http://yoursite.com/tags/springMVC/"}],"keywords":[]},{"title":"java_SpringMVC框架的实现原理及其详解","slug":"Java_SpringMVC实现原理及详解(上)","date":"2019-09-10T00:28:35.027Z","updated":"2019-04-23T04:56:03.610Z","comments":true,"path":"2019/09/09/Java_SpringMVC实现原理及详解(上)/","link":"","permalink":"http://yoursite.com/2019/09/09/Java_SpringMVC实现原理及详解(上)/","excerpt":"java_SpringMVC框架的实现原理及其详解","text":"java_SpringMVC框架的实现原理及其详解 1. Spring mvc介绍SpringMVC框架是以请求为驱动，围绕Servlet设计，将请求发给控制器，然后通过模型对象，分派器来展示请求结果视图。其中核心类是DispatcherServlet，它是一个Servlet，顶层是实现的Servlet接口。 2. SpringMVC使用需要在web.xml中配置DispatcherServlet。并且需要配置spring监听器ContextLoaderListener web.xml1234567891011121314151617&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;!-- 如果不设置init-param标签，则必须在/WEB-INF/下创建xxx-servlet.xml文件，其中xxx是servlet-name中配置的名称。 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 3. SpringMVC运行原理 流程图： 流程说明： 客户端（浏览器）发送请求，直接请求到DispatcherServlet。 DispatcherServlet根据请求信息调用HandlerMapping，解析请求对应的Handler。 解析到对应的Handler后，开始由HandlerAdapter适配器处理。 HandlerAdapter会根据Handler来调用真正的处理器开处理请求，并处理相应的业务逻辑。 处理器处理完业务后，会返回一个ModelAndView对象，Model是返回的数据对象，View是个逻辑上的View。 ViewResolver会根据逻辑View查找实际的View。 DispaterServlet把返回的Model传给View。 通过View返回给请求者（浏览器）4. DispatcherServlet详细解析首先看下源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package org.springframework.web.servlet; @SuppressWarnings(\"serial\")public class DispatcherServlet extends FrameworkServlet &#123; public static final String MULTIPART_RESOLVER_BEAN_NAME = \"multipartResolver\"; public static final String LOCALE_RESOLVER_BEAN_NAME = \"localeResolver\"; public static final String THEME_RESOLVER_BEAN_NAME = \"themeResolver\"; public static final String HANDLER_MAPPING_BEAN_NAME = \"handlerMapping\"; public static final String HANDLER_ADAPTER_BEAN_NAME = \"handlerAdapter\"; public static final String HANDLER_EXCEPTION_RESOLVER_BEAN_NAME = \"handlerExceptionResolver\"; public static final String REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME = \"viewNameTranslator\"; public static final String VIEW_RESOLVER_BEAN_NAME = \"viewResolver\"; public static final String FLASH_MAP_MANAGER_BEAN_NAME = \"flashMapManager\"; public static final String WEB_APPLICATION_CONTEXT_ATTRIBUTE = DispatcherServlet.class.getName() + \".CONTEXT\"; public static final String LOCALE_RESOLVER_ATTRIBUTE = DispatcherServlet.class.getName() + \".LOCALE_RESOLVER\"; public static final String THEME_RESOLVER_ATTRIBUTE = DispatcherServlet.class.getName() + \".THEME_RESOLVER\"; public static final String THEME_SOURCE_ATTRIBUTE = DispatcherServlet.class.getName() + \".THEME_SOURCE\"; public static final String INPUT_FLASH_MAP_ATTRIBUTE = DispatcherServlet.class.getName() + \".INPUT_FLASH_MAP\"; public static final String OUTPUT_FLASH_MAP_ATTRIBUTE = DispatcherServlet.class.getName() + \".OUTPUT_FLASH_MAP\"; public static final String FLASH_MAP_MANAGER_ATTRIBUTE = DispatcherServlet.class.getName() + \".FLASH_MAP_MANAGER\"; public static final String EXCEPTION_ATTRIBUTE = DispatcherServlet.class.getName() + \".EXCEPTION\"; public static final String PAGE_NOT_FOUND_LOG_CATEGORY = \"org.springframework.web.servlet.PageNotFound\"; private static final String DEFAULT_STRATEGIES_PATH = \"DispatcherServlet.properties\"; protected static final Log pageNotFoundLogger = LogFactory.getLog(PAGE_NOT_FOUND_LOG_CATEGORY); private static final Properties defaultStrategies; static &#123; try &#123; ClassPathResource resource = new ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class); defaultStrategies = PropertiesLoaderUtils.loadProperties(resource); &#125; catch (IOException ex) &#123; throw new IllegalStateException(\"Could not load 'DispatcherServlet.properties': \" + ex.getMessage()); &#125; &#125; /** Detect all HandlerMappings or just expect \"handlerMapping\" bean? */ private boolean detectAllHandlerMappings = true; /** Detect all HandlerAdapters or just expect \"handlerAdapter\" bean? */ private boolean detectAllHandlerAdapters = true; /** Detect all HandlerExceptionResolvers or just expect \"handlerExceptionResolver\" bean? */ private boolean detectAllHandlerExceptionResolvers = true; /** Detect all ViewResolvers or just expect \"viewResolver\" bean? */ private boolean detectAllViewResolvers = true; /** Throw a NoHandlerFoundException if no Handler was found to process this request? **/ private boolean throwExceptionIfNoHandlerFound = false; /** Perform cleanup of request attributes after include request? */ private boolean cleanupAfterInclude = true; /** MultipartResolver used by this servlet */ private MultipartResolver multipartResolver; /** LocaleResolver used by this servlet */ private LocaleResolver localeResolver; /** ThemeResolver used by this servlet */ private ThemeResolver themeResolver; /** List of HandlerMappings used by this servlet */ private List&lt;HandlerMapping&gt; handlerMappings; /** List of HandlerAdapters used by this servlet */ private List&lt;HandlerAdapter&gt; handlerAdapters; /** List of HandlerExceptionResolvers used by this servlet */ private List&lt;HandlerExceptionResolver&gt; handlerExceptionResolvers; /** RequestToViewNameTranslator used by this servlet */ private RequestToViewNameTranslator viewNameTranslator; private FlashMapManager flashMapManager; /** List of ViewResolvers used by this servlet */ private List&lt;ViewResolver&gt; viewResolvers; public DispatcherServlet() &#123; super(); &#125; public DispatcherServlet(WebApplicationContext webApplicationContext) &#123; super(webApplicationContext); &#125; @Override protected void onRefresh(ApplicationContext context) &#123; initStrategies(context); &#125; protected void initStrategies(ApplicationContext context) &#123; initMultipartResolver(context); initLocaleResolver(context); initThemeResolver(context); initHandlerMappings(context); initHandlerAdapters(context); initHandlerExceptionResolvers(context); initRequestToViewNameTranslator(context); initViewResolvers(context); initFlashMapManager(context); &#125; DispatcherServlet类中的属性beans： HandlerMapping：用于handlers映射请求和一系列的对于拦截器的前处理和后处理，大部分用@Controller注解。 HandlerMapping接口处理请求的映射 HandlerMapping接口的实现类： SimpleUrlHandlerMapping类通过配置文件把URL映射到Controller类。 DefaultAnnotationHandlerMapping类通过注解把URL映射到Controller类。 HandlerAdapter：帮助DispatcherServlet处理映射请求处理程序的适配器，而不用考虑实际调用的是 哪个处理程序。 HandlerExceptionResolver：处理映射异常。 ViewResolver：根据实际配置解析实际的View类型。 ViewResolver接口解析View视图。 UrlBasedViewResolver类 通过配置文件，把一个视图名交给到一个View来处理。 LocaleResolver：解决客户正在使用的区域设置以及可能的时区，以便能够提供国际化视野。 ThemeResolver：解决Web应用程序可以使用的主题，例如提供个性化布局。 MultipartResolver：解析多部分请求，以支持从HTML表单上传文件。 FlashMapManager：存储并检索可用于将一个请求属性传递到另一个请求的input和output的FlashMap，通常用于重定向。 在Web MVC框架中，每个DispatcherServlet都拥自己的WebApplicationContext，它继承了ApplicationContext。WebApplicationContext包含了其上下文和Servlet实例之间共享的所有的基础框架beans。","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}],"keywords":[]},{"title":"spring的工作原理","slug":"java_spring的工作原理","date":"2019-09-10T00:28:35.023Z","updated":"2019-04-23T00:18:06.072Z","comments":true,"path":"2019/09/09/java_spring的工作原理/","link":"","permalink":"http://yoursite.com/2019/09/09/java_spring的工作原理/","excerpt":"spring的工作原理","text":"spring的工作原理spring的工作原理 一、 IoC(Inversion of control): 控制反转1、IoC：概念：控制权由对象本身转向容器；由容器根据配置文件去创建实例并创建各个实例之间的依赖关系核心：bean工厂；在Spring中，bean工厂创建的各个实例称作bean 二、AOP(Aspect-Oriented Programming): 面向方面编程 (其实我的理解是，通过配置文件来实现模块和模块，对象和对象的分离。) 代理的两种方式：静态代理： 针对每个具体类分别编写代理类； 针对一个接口编写一个代理类；动态代理： 针对一个方面编写一个InvocationHandler，然后借用JDK反射包中的Proxy类为各种接口动态生成相应的代理类 AOP的主要原理：动态代理 三、Spring工作原理 Spring 已经用过一段时间了，感觉Spring是个很不错的框架。内部最核心的就是IOC了，动态注入，让一个对象的创建不用new了，可以自动的生产，这其实就是利用java里的反射反射其实就是在运行时动态的去创建、调用对象 Spring就是在运行时，跟xml Spring的配置文件来动态的创建对象，和调用对象里的方法的 。 Spring还有一个核心就是AOP这个就是面向切面编程，可以为某一类对象 进行监督和控制（也就是 在调用这类对象的具体方法的前后去调用你指定的 模块）从而达到对一个模块扩充的功能。这些都是通过 配置类达到的。 Spring目的：就是让对象与对象（模块与模块）之间的关系没有通过代码来关联，都是通过配置类说明管理的（Spring根据这些配置 内部通过反射去动态的组装对象） 要记住：Spring是一个容器，凡是在容器里的对象才会有Spring所提供的这些服务和功能。 Spring里用的最经典的一个设计模式就是：模板方法模式。（这里我都不介绍了，是一个很常用的设计模式） Spring里的配置是很多的，很难都记住，但是Spring里的精华也无非就是以上的两点，把以上两点跟理解了也就基本上掌握了Spring.","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}],"keywords":[]},{"title":"浅析java web开发架构之MVC","slug":"浅析java web开发架构之MVC","date":"2019-09-10T00:28:35.015Z","updated":"2019-04-23T00:18:21.761Z","comments":true,"path":"2019/09/09/浅析java web开发架构之MVC/","link":"","permalink":"http://yoursite.com/2019/09/09/浅析java web开发架构之MVC/","excerpt":"浅析java web开发架构之MVC","text":"浅析java web开发架构之MVC Java Web增强：过滤器、监听器、国际化、文件上传和下载、JavaMail邮件开发 项目开发设计之mvc模式： M （model）模型层 【entity（javabean,bean,pojo,domain）/dao/service】 V (view)视图层 【jsp/html】 C (control)控制器 【serlet】 优缺点：每一层各司其职，更容易更换具体的实现，而对其它层代码的影响较小！","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}],"keywords":[]},{"title":"JavaScript开发者应懂的33个概念","slug":"JavaScript开发者应懂的33个概念","date":"2019-09-10T00:28:35.007Z","updated":"2019-04-19T03:06:58.583Z","comments":true,"path":"2019/09/09/JavaScript开发者应懂的33个概念/","link":"","permalink":"http://yoursite.com/2019/09/09/JavaScript开发者应懂的33个概念/","excerpt":"JavaScript开发者应懂的33个概念","text":"JavaScript开发者应懂的33个概念 简介这个项目是为了帮助开发者掌握 JavaScript 概念而创立的。它不是必备，但在未来学习（JavaScript）中，可以作为一篇指南。 本篇文章是参照 @leonardomso 创立，英文版项目地址在这里。由于原版资源都要翻墙，所以本人创立一个中文版，附上关于这些概念在国内的一些文章和视频。若有觉得更好的文章或者视频，可以贡献出来，觉得有误的，请联系我删除。 更新若有觉得更好的文章或者视频，可以贡献出来，觉得有误的，请联系我删除。 文章的排序优化，前面的文章是介绍概念，后面的文章是深入解读。 将原文的 “高阶函数” 和 “map, reduce, filter” 合并为 “map, reduce, filter 等高阶函数” 增加 “promise” 概念(替换删除的 “高阶函数”) 2018-10-24 更新：@BuptStEve 贡献的三篇关于“函数式编程”方面的文章 目录 调用堆栈 原始类型 值类型和引用类型 隐式, 显式, 名义和鸭子类型 == 与 ===, typeof 与 instanceof this, call, apply 和 bind 函数作用域, 块级作用域和词法作用域 闭包 map, reduce, filter 等高阶函数 表达式和语句 变量提升 Promise 立即执行函数, 模块化, 命名空间 递归 算法 数据结构 消息队列和事件循环 setTimeout, setInterval 和 requestAnimationFrame 继承, 多态和代码复用 按位操作符, 类数组对象和类型化数组 DOM 树和渲染过程 new 与构造函数, instanceof 与实例 原型继承与原型链 Object.create 和 Object.assign 工厂函数和类 设计模式 Memoization 纯函数, 函数副作用和状态变化 耗性能操作和时间复杂度 JavaScript 引擎 二进制, 十进制, 十六进制, 科学记数法 偏函数, 柯里化, Compose 和 Pipe 代码整洁之道 1. 调用堆栈文章 :book: Call Stack — MDN :book: [译] JavaScript 如何工作：对引擎、运行时、调用堆栈的概述 —— 掘金 :book: [译] 理解 JavaScript 中的执行上下文和执行栈 —— 掘金 :book: 这一次，彻底弄懂 JavaScript 执行机制 —— 掘金 :book: 解读 JavaScript 之引擎、运行时和堆栈调用 —— 开源中国 :book: Tasks, microtasks, queues and schedules —— Jake Archibald 视频 :tv: What is the event loop anyway? —— 腾讯视频(英文字幕) :tv: Understanding The JavaScript Call Stack, Event Queue, Event Table, &amp; Event Loop —— Bilibili :tv: JS 中的变量提升、堆栈内存及闭包详解 —— Acfun :tv: 事件循环模型 —— PHP 中文网 :arrow_up: 返回目录 2. 原始类型文章 :book: 原始数据 —— MDN :book: ECMAScript 原始类型 —— W3school :book: How numbers are encoded in JavaScript —— Dr. Axe :book: 每一个 JavaScript 开发者应该了解的浮点知识 —— 颜海镜 :book: JavaScript 标准参考教程(基本语法之数值) —— 阮一峰 :book: The Secret Life of JavaScript Primitives —— Angus Croll 视频 :tv: javascript 六种数据类型 —— 慕课网 :tv: javascript 视频教程(数据类型) —— PHP 中文网 :arrow_up: 返回目录 3. 值类型和引用类型文章 :book: ECMAScript 引用类型 —— W3school :book: js 中的值类型和引用类型的区别 —— 博客园 :book: JavaScript 的值传递和引用传递 —— FunDebug :book: Primitive Types &amp; Reference Types in JavaScript —— Bran van der Meer :book: JavaScript: Passing by Value or by Reference —— CSDN :book: js 值引用和值复制 —— SegmentFault :book: js- 引用和复制(传值和传址) —— CSDN :arrow_up: 返回目录 4. 隐式, 显式, 名义和鸭子类型文章 :book: ECMAScript 类型转换 —— W3school :book: JavaScript 的怪癖 1：隐式类型转换 —— justjavac :book: JavaScript 运算符规则与隐式类型转换详解 —— 掘金 :book: 聊一聊 JS 中的隐式类型转换 —— SegmentFault :book: 有趣的 JavaScript 隐式类型转换 —— 博客园 :book: JavaScript 显式类型转换与隐式类型转换 —— CSDN :book: 你不知道的 JavaScript（中卷）强制类型转换 —— 简书 :book: 你懂 JavaScript 嗎？#8 強制轉型 —— cythilya :book: 动态类型语言和鸭子类型 —— 曾探 :book: Nominal &amp; Structural Typing —— flow :book: What exactly is Type Coercion in Javascript? —— stackoverflow :book: You Don’t Know JS: Types &amp; Grammar —— github 视频 :tv: javascript 隐式转换 —— 慕课网 :tv: Javascript 基础加强-类型转换 —— 黑马程序员 :arrow_up: 返回目录 5. == vs ===, typeof vs instanceof文章 :book: JavaScript 中的相等性判断 —— MDN :book: js 中 == 和 === 的区别 —— 掘金 :book: == vs === in Javascript —— CSDN :book: 深入理解 javascript 之 typeof 和 instanceof —— CSDN :book: JavaScript 的 typeof 的用途 —— justjavac :book: 一张图看懂 Function 和 Object 的关系及简述 instanceof 运算符 —— 掘金 :book: 浅谈 instanceof 和 typeof 的实现原理 —— 掘金 :book: js 中 typeof 与 instanceof 用法 —— 博客园 :arrow_up: 返回目录 6. this, call, apply 和 bind文章 :book: Javascript 的 this 用法 —— 阮一峰 :book: 学会 JS 的 this 这一篇就够了，根本不用记 —— 简书 :book: [译] this（他喵的）到底是什么 — 理解 JavaScript 中的 this、call、apply 和 bind —— 掘金 :book: this、apply、call、bind —— 掘金 :book: 使用 call、apply 和 bind 解决 js 中烦人的 this，事件绑定时的 this 和传参问题 —— 博客园 :book: call、apply 和 bind 的原生实现 —— github :book: 详解 JS 中的 this、apply、call、bind(经典面试题) —— 脚本之家 视频 :tv: JavaScript 关于 this 关键字解释 —— 爱奇艺 :tv: JS 关于作用域闭包和 this 的综合面试题 —— 百度视频 :tv: js 面向对象闭包数组 12.函数中的 this —— 乐视视频 :tv: 1.3.10-this 指向及 this 应用 —— 乐视视频 :tv: 珠峰培训 JavaScript 开发课程：关于 this 关键字、闭包作用域 —— 网易云课堂 :arrow_up: 返回目录 7. 函数作用域, 块级作用域和词法作用域文章 :book: 变量作用域与解构赋值 —— 廖雪峰 :book: 学习 Javascript 闭包（Closure） —— 阮一峰 :book: JavaScript 中词法作用域、闭包与跳出闭包 —— SegmentFault :book: JavaScript 深入之词法作用域和动态作用域 —— 掘金 :book: 深入理解闭包之前置知识 → 作用域与词法作用域 —— 掘金 :book: What is lexical scope? —— stackoverflow :book: You Don’t Know JS: Scope &amp; Closures —— Kyle Simpson :arrow_up: 返回目录 8. 闭包文章 :book: 闭包 —— MDN :book: ECMAScript 闭包（closure）—— w3school :book: 学习 Javascript 闭包（Closure） —— 阮一峰 :book: 闭包 —— 廖雪峰 :book: 一次性搞懂 JavaScript 闭包 —— 简书 :book: JavaScript 闭包 —— SegmentFault :book: js 匿名自执行函数中闭包的高级使用 —— 掘金 :book: 高效使用 JavaScript 闭包 —— 掘金 视频 :tv: JavaScript 闭包和闭包面试题 —— 爱奇艺 :tv: js 面向对象闭包数组 11.闭包 —— 乐视 :tv: 白贺翔_函数(闭包) —— 乐视 :arrow_up: 返回目录 9. map, reduce, filter 等高阶函数文章 :book: 高阶函数 —— 廖雪峰 :book: ES5 中新增的 Array 方法详细说明 —— 张鑫旭 :book: 一张图看懂 JavaScript 中数组的迭代方法：forEach、map、filter、reduce、every、some —— 掘金 :book: Transducing（上）－《JavaScript 轻量级函数式编程》 —— SegmentFault :book: JavaScript 函数式编程（三） —— @BuptStEve :arrow_up: 返回目录 10. 表达式和语句文章 :book: js 表达式与语句 —— 博客园 :book: JS 表达式和语句的区别 —— SegmentFault :book: JavaScript 中的表达式（expression）和语句/声明（statement） —— CSDN :book: 重讀 Axel 的 Javascript 中的 Expression vs Statement 一文 —— SegmentFault :book: Expressions versus statements in JavaScript —— Dr. Axel :arrow_up: 返回目录 11. 变量提升文章 :book: JavaScript 变量提升 —— 菜鸟教程 :book: ES6 变量作用域与提升：变量的生命周期详解 —— 掘金 :book: [翻译] JavaScript Scoping and Hoisting —— SegmentFault :book: JavaScript Scoping and Hoisting —— Ben Cherry :arrow_up: 返回目录 12. Promise文章 :book: 使用 promises —— MDN :book: Promise —— MDN :book: Promie — 廖雪峰 :book: JavaScript Promise：去而复返 —— 司徒正美 :book: (上面的原文)JavaScript Promise：简介 —— Web Fundamentals :book: 1 分钟读完《10 分钟学会 JavaScript 的 Async/Await》 —— justjavac :book: JavaScript Promise 迷你书（中文版） :book: JavaScript 进阶之路——认识和使用 Promise，重构你的 Js 代码 —— 博客园 视频 :tv: Promise 入门 —— 慕课网 :arrow_up: 返回目录 13. 立即执行函数, 模块化, 命名空间文章 :book: Javascript 模块化编程（一）：模块的写法 —— 阮一峰 :book: javascript 模块化编程-详解立即执行函数表达式 —— 简书 :book: Javascript 的匿名函数与自执行 —— 掘金 :book: 前端模块化——技术选型 —— SegmentFault :book: 谈谈 Js 前端模块化规范 —— SegmentFault :arrow_up: 返回目录 14. 递归文章 :book: 求解释 js 递归 —— SegmentFault :book: JavaScript 中的递归 —— 掘金 :book: 递归（上）－《JavaScript 轻量级函数式编程》 —— 掘金 :book: 递归（下）－《JavaScript 轻量级函数式编程》 —— 掘金 :book: 尾调用和尾递归 —— 掘金 :book: 几个经典递归问题用 js 实现 —— CSDN :book: 递归函数的几个例子 —— CSDN :arrow_up: 返回目录 15. 算法文章 :book: 十大经典排序算法总结（JavaScript 描述） —— 掘金 :book: 在 JavaScript 中学习数据结构与算法 —— 掘金 :book: JS 中可能用得到的全部的排序算法 —— 掘金 :book: JS 家的排序算法 —— 简书 :book: 前端常见算法的 JS 实现 —— SegmentFault :book: 前端面试中的常见的算法问题 ——蒲小花的博客 视频 :tv: Javascript 实现二叉树算法 —— 慕课网 :arrow_up: 返回目录 16. 数据结构文章 :book: 来我们浅谈一下 js 的数据结构 —— 简书 :book: JavaScript 中的算法与数据结构 —— 简书 :book: 学 JS 必看-JavaScript 数据结构深度剖析 —— 大道至简的博客 :book: js 中基础数据结构数组去重问题 —— 掘金 视频 :tv: :tv: JavaScript 数据结构-运算符 —— 乐视 :arrow_up: 返回目录 17. 消息队列和事件循环文章 :book: 并发模型与事件循环 —— MDN :book: JavaScript 运行机制详解：再谈 Event Loop —— 阮一峰 :book: 深入理解 JavaScript 事件循环 —— 博客园 :book: 深入浅出 Javascript 事件循环机制 —— 知乎 :book: JS 事件循环机制（event loop）之宏任务、微任务 —— SegmentFault :book: JavaScript：彻底理解同步、异步和事件循环 —— SegmentFault :arrow_up: 返回目录 18. setTimeout, setInterval 和 requestAnimationFrame文章 :book: Window setTimeout() 方法 —— 菜鸟教程 :book: Window setInterval() 方法 —— 菜鸟教程 :book: 关于 setTimeout —— 掘金 :book: 你不知道的 Javascript：有趣的 setTimeout —— 掘金 :book: 原来你是这样的 setTimeout —— 掘金 :book: setTimeout() 和 setInterval() 本质区别在哪里？ —— SegmentFault book: window.requestAnimationFrame —— MDN :book: requestAnimationFrame 知多少？ —— 博客园 :book: CSS3 动画那么强，requestAnimationFrame 还有毛线用？ —— 张鑫旭 :book: 「JavaScript 定时器」setInterval、setTimeout 和 requestAnimationFrame 浅析 —— SegmentFault :book: 翻译：setInterval 与 requestAnimationFrame 的时间间隔测试 —— SegmentFault :book: 阿里前端面试题：requestAnimationFrame 实现类似 setInterval 的计时器 —— SegmentFault 视频 :tv: setTimeout 和 setInterval —— 优酷 :arrow_up: 返回目录 19. 继承, 多态和代码复用文章 :book: JS 面向对象编程之：封装、继承、多态 —— 博客园 :book: Javascript 的继承与多态 —— 简书 :book: js:面向对象编程，带你认识封装、继承和多态 —— 掘金 :book: JavaScript 中的“多继承” —— 掘金 :book: 代码复用模式 —— github :book: 深入理解 JavaScript：代码复用模式(推荐篇) —— 汤姆大叔 :book: 深入理解 JavaScript：代码复用模式(避免篇) —— 汤姆大叔 :arrow_up: 返回目录 20. 按位操作符, 类数组对象和类型化数组文章 :book: 按位操作符 —— MDN :book: 类数组对象 —— MDN :book: 类型化数组 —— MDN :book: JavaScript ArrayBuffer 浅析 —— 博客园 :arrow_up: 返回目录 21. DOM 树和渲染过程文章 :book: 如何创建一个 DOM 树 —— MDN :book: HTML DOM 节点 —— W3school :book: DOM 概述 —— 阮一峰 :book: 《JavaScript 闯关记》之 DOM（上）—— 掘金 :book: 《JavaScript 闯关记》之 DOM（下）—— 掘金 :book: 掌握 DOM 操作 —— 掘金 :book: 操作 DOM —— 廖雪峰 :book: 原来 CSS 与 JS 是这样阻塞 DOM 解析和渲染的 —— 掘金 视频 :tv: DOM 探索之基础详解篇 —— 慕课网 :tv: DOM 事件探秘 —— 慕课网 :tv: jQuery 基础(二)DOM 篇 —— 慕课网 :tv: JS 操作 DOM 对象属性和方法 —— 爱奇艺 :arrow_up: 返回目录 22. new 与构造函数, instanceof 与实例文章 :book: 构造函数与 new 命令 —— 阮一峰 :book: Javascript 面向对象编程（二）：构造函数的继承 —— 阮一峰 :book: 完整原型链详细图解(构造函数、原型、实例化对象) —— CSDN :book: JavaScript 中构造函数与 new 操作符的实例详解 —— PHP 中文网 :book: 构造函数、实例、原型、原型链之间的关系 —— CSDN :book: 深入理解 JS—instanceof 和原型链 —— CSDN :book: 前端基础进阶（九）：详解面向对象、构造函数、原型与原型链 —— 简书 :book: js 用 new 实例化对象与直接调用的 this 的区别 —— 简书 :book: JavaScript 并非所有的东西都是对象 —— justjavac :book: JavaScript instanceof 运算符深入剖析 —— IBM 视频 :tv: 改良版的构造函数 —— 乐视 :arrow_up: 返回目录 23. 原型继承与原型链文章 :book: 继承与原型链 —— MDN :book: 构造函数、原型与原型链 —— github :book: 原型及原型链 —— github(1269 Star) :book: 理清 javascript 中的面向对象(一) 原型继承 —— SegmentFault :book: JavaScript：继承和原型链(译) —— justjavac :book: 三张图搞懂 JavaScript 的原型对象与原型链 —— 博客园 :book: 一张图让你搞懂 JavaScript 的继承与原型链 —— CSDN :book: JS 高级–原型链(一看就懂，但 18 岁以下请绕道) —— CSDN :book: 原型继承 —— 廖雪峰 :book: JS 原型链与继承别再被问倒了 —— 掘金 :book: 征服 JavaScript 面试系列：类继承和原型继承的区别 —— 掘金 视频 :tv: JS 高级-07-原型链继承 —— 乐视 :tv: JS 原型对象和原型链简介 —— 腾讯视频 :arrow_up: 返回目录 24. Object.create 和 Object.assign文章 :book: Object.create —— MDN :book: Object.assign —— MDN :book: Object.create vs Object.assign —— 慕课网手记 :book: JS 中的 Object.assign()、Object.create()、Object.defineProperty() —— CSDN :book: es6 中 object.create()和 object.assign() —— 风信子博客 :book: Object-Assign-Deep —— github :arrow_up: 返回目录 25. 工厂函数和类文章 :book: 类 —— MDN :book: 类和实例 —— 廖雪峰 :book: Javascript 定义类（class）的三种方法 —— 阮一峰 :book: 【译】ES6 的工厂函数 —— 掘金 :book: JavaScript 创建对象之单例、工厂、构造函数模式 —— 掘金 :arrow_up: 返回目录 26. 设计模式文章 :book: 设计模式 —— 阮一峰 :book: JavaScript 设计模式 —— 掘金 :book: 学用 JavaScript 设计模式 —— 极客学院 :book: [面试专题]JS 设计模式 —— SegmentFault :book: JavaScript Patterns 中译本 —— github 视频 :tv: HTML5 课程大纲 2-11JS 设计模式 :arrow_up: 返回目录 27. Memoization文章 :book: JavaScript Memoization —— 司徒正美 :book: memoization 提升递归效率 —— 博客园 :book: 如何提升 JavaScript 的递归效率 —— 51CTO :book: JavaScript 高级技巧 Memoization —— SegmentFaut :arrow_up: 返回目录 28. 纯函数, 函数副作用和状态变化文章 :book: 纯函数(Pure Function) —— React.js 小书 :book: JavaScript Functional Programming：纯函数 —— 宁皓网 :book: js 函数的副作用分析 —— 脚本之家 :book: 如何使用纯函数式 JavaScript 处理脏副作用 —— 掘金 :book: 原生 JavaScript 实现 state 状态管理系统 —— 博客园 :book: JavaScript 函数式编程 —— @BuptStEve :arrow_up: 返回目录 29. 耗性能操作和时间复杂度文章 :book: 时间复杂度 O(log n) 意味着什么？ —— 掘金 :book: 算法的时间复杂度和空间复杂度 —— 掘金 :book: 算法（一）时间复杂度 —— 掘金 :book: Big O Search Algorithms in JavaScript —— Bradley Braithwaite :book: Time Complexity Analysis in JavaScript — Jennifer Bland- :arrow_up: 返回目录 30. JavaScript 引擎文章 :book: javascript 引擎 —— 百度百科 :book: V8(JavaScript 引擎) —— 百度百科 :book: 图解搞懂 JavaScript 引擎 Event Loop —— 掘金3 :book: V8 JavaScript 引擎：高性能的 ES2015+ —— justjavac :book: 10 分钟理解 JS 引擎的执行机制 —— SegmentFaut :book: V8 javascript 引擎 —— 博客园 :arrow_up: 返回目录 31. 二进制, 十六进制, 十进制, 科学记数法文章 :book: 二、八、十、十六进制转换(图解篇) —— 博客园 :book: JavaScript 读写二进制数据 —— 掘金 视频 :tv: 二进制、十进制、十六进制互相转化很难吗？ —— 百度视频 :arrow_up: 返回目录 32. 偏函数, 柯里化, Compose 和 Pipe文章. :book: Javascript 函数式编程之偏函数 —— CSDN :book: JavaScript 专题之偏函数 —— SegmentFault :book: 柯里化和偏函数有什么区别？ —— SegmentFault :book: Javascript 偏函数与柯里化 —— CSDN :book: 柯里化(curry) —— JS 函数式编程指南 :book: 代码组合(compose) —— JS 函数式编程指南 :book: 关于 javascript 函数式编程中 compose 的实现 —— SegmentFault :book: 实现 compose 的五种思路 —— SegmentFault :book: JavaScript 函数式编程之函数组合函数 compose 和 pipe 的实现 —— SegmentFault :book: JavaScript 轻量级函数式编程-第 4 章:组合函数 ——掘金 :book: JavaScript 函数式编程（二） —— @BuptStEve :arrow_up: 返回目录 33. 代码整洁之道文章 :book: [译] JavaScript 代码整洁之道 —— 边城 :book: Javascript 编程风格 —— 阮一峰 :book: 重构 - 代码整洁之道 —— 掘金 :book: 让你的代码更简短，更整洁，更易读的 ES6 小技巧 —— 掘金 :book: Web 前端：11 个让你代码整洁的原则 —— 伯乐在线 :arrow_up: 返回目录","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}],"keywords":[]},{"title":"求职季节之你必须要懂的原生js(上)","slug":"求职季之你必须要懂的原生JS(上)","date":"2019-09-10T00:28:34.995Z","updated":"2019-04-19T02:48:19.094Z","comments":true,"path":"2019/09/09/求职季之你必须要懂的原生JS(上)/","link":"","permalink":"http://yoursite.com/2019/09/09/求职季之你必须要懂的原生JS(上)/","excerpt":"(来自掘金) 寒冬求职之季你必须要懂的原生JS(上)","text":"(来自掘金) 寒冬求职之季你必须要懂的原生JS(上) 1. 基本类型有哪几种？null是对象吗？基本数据类型和复杂数据类型存储有啥区别？ 基本数据类型有6种：undefined、boolean、null、number、string、symbol（es6新增类型）。 虽然 typeof null 返回的是对象，但是null不是对象，而是基本类型种的一种。 基本数据类型存储在栈内存，存储的是值。 复杂数据类型存储的在堆内存，存储的是地址。当我们把对象赋值给另一个变量的时候，复制的是地址，指向同一块内存空间，当其中一个对象改变时，另一个对象也会改变。 2. typeof是否正确判断类型？instanceof呢？instanceof的实现原理是什么？ typeof 能正确判断基本数据类型，但除了null之外， typeof null返回的是对象 但是对于对象，typeof不能正确的判断其类型，type 一个函数 输出的是 function，其余的对象都返回object instanceof 能正确判断复杂类型但不能判断基本类型 instanceof是通过原型链判断的，A instanceof B , 在A的原型链中层层查找，是否有原型等于B.prototype,如果一直站到A的原型链的顶端（null即 Object.prototype.proto），仍然不等于B.prototype,那么返回false,否则返回true instanceof 的实现代码：123456789101112// L instanceof Rfunction instance_of(L, R) &#123; // L 为左边表达式 R 为右表达式 var O = R.prototype; // 取R的显示原型 L = L._proto_; // 取L的隐式原型 while (true) &#123; // 遇到return 语句则跳出循环 if (L === null) // 已经找到顶层 return false; if (L === O) // 当 O 严格等于 L 时，返回true return true; L = L._proto_; // 继续向上一层原型链查找 &#125;&#125; 3. for of，for in 和forEach,map的区别 for…of循环：具有iterator接口，就可以使用for…of循环遍历他的成员（属性值）。for…of 循环可以使用的范围包括数组、Set和Map结构、某些类似数组的对象、generator对象，以及字符串。for…of 循环调用遍历器接口，数组的遍历器只返回具有数字索引的属性。对于普通的对象，for…of 结构不能直接使用，会报错，必须部署了Iterator接口后才能使用。可以中断循环。 for…in 循环：遍历对象自身和继承的可枚举的属性，不能直接获取属性值。可以中断循环。 forEach只能遍历数组，不能中断，没有返回值（或认为是undefined）。 map:只能遍历数组，不能中断，返回值修改后的数组。PS:Object.keys():返回给定对象的所有可枚举属性的字符串数组。 关于forEach是否会改变原数组的问题：1234567891011121314151617let arry = [1, 2, 3, 4];arry.forEach((item) =&gt; &#123; item*=10;&#125;);console.log(arry);// [1, 2, 3, 4]arry.forEach((item) =&gt; &#123; arry[1] = 10;&#125;);console.log(arry); // [1, 10, 3, 4]let arry2 = [ &#123;name: 'Vue'&#125;, &#123;age: 10&#125;];arry2.forEach((item) =&gt; &#123; item.name = 20;&#125;);console.log(arrr2); // [&#123;name: 20&#125;, &#123;age: 10, name: 20&#125; 4.如何判断一个变量是不是数组? 使用Arrar.isArray()判断，如果返回true，说明是数组 使用instanceof Array 判断，如果返回true，说明是数组 使用Object.prototype.toString.call判断，如果值是[objec Array]，说明是数组 通过constructor来判断，如果是数组，那么arr.constructor ==== Array，（不准确，因为我们可指定 obj.constructor = Array）123456789function fn() &#123; console.log(Array.isArray(arguments)); // false, 因为arguments是类数组 console.log(Array.isArray([1, 2, 3])); // true console.log(arguments instanceof Array); // false console.log([1, 2, 3] instanceof Array); // true console.log(Object.prototype.toString.call(arguments)); // [object arguments] console.log(arguments.constructor === Array); // false fn(1, 2, 3, 4);&#125; 5.类数组和数组的区别?类数组：是一个普通的对象，而真实的数组是Array类型。 拥有length属性，其他属性（索引）为非负整数（对象中的索引会被当做字符串来处理)； 不具有数组的方法；常见的类数组有：函数的参数arguments,DOM对象列表（比如通过document.querySelectorAll得到的列表），jQuery对象￥(“div”)类数组可以转换为数组：123456// 第一种转换方法Object.prototype.slice.call(arrayLike, start);// 第二种方法[...arrayLike]// 第三种方法Array.from(arrayLike); PS:任何定义了遍历器（Irerator）接口的对象，都可以用扩展运算符转为真正的数组Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like-object）和可遍历（iterator）对象。 6.== 和 === 有什么区别？=== 不需要类型转换，只有类型相等并且值相等时才返回true == 如果两者类型不同，首先进行类型转换，具体流程如下： 首先判断两者类型是否相同，如果相等，判断值是否相等。 如果类型不同进行类型转换 判断比较的是否是null 或undefined，如果是，返回true 判断两者类型事是否为string和number,如果是，将字符串转换成number 判断其中一方是否是boolean,如果是，将boolean转为number再进行判断 判断其中一方是否是object且另一方为string、number或者symbol，如果是，将object转换为原始类型再判断123456let person1 = &#123; age：25&#125;let person2 = person1;person2.age = 10;console.log(person1 === person2); 思考：[] == ![];我们来分析一下：[] == ![] 是true还是false? 首先我们需要知道!运算符优先级高于 == ![] 引用类型转换成布尔值都是true,因此，![] 是false 根据上面的第5条，false转换为number是0，因此右边表达式的计算结果是0 再根据上面的第6条，有一方是number，那么将object也转换为Number(空数组转换为number是0，如果数组中只有一个数字，转换为number就是这个数字，其他情况均为NaN) 0 == 0;为true 7. ES6中的class和ES5的类有什么区别？ ES6 class 内部所有定义的方法都是不可枚举的 ES6 class 必须使用new调用 ES6 class 不存在变量提升 ES6 class 即默认为严格模式 ES6 class 子类必须在父类的构造器函数中调用super(),这样才有this对象;ES5中类的继承关系是相反的，现有子类的this，然后用父类的方法应用在this上。 8.数组中的哪下API会改变原数组？修改原数组的API有：splice/reverse/fill/copyWithin/sort/push/pop/unshift/shift 不修改原数组的API有：slice/map/forEach/every/filter/reduce/entries/find/some 9.let,const以及var的区别是什么？ let 和 const 定义的变量不会出现变量提升，而var 定义的变量会提升 let 和 const 是JS中的块级作用域 let 和 const 不允许重复声明（会抛出错误） let 和 const 定义的变量，如果在定义语句之前使用会抛出错误（形成了暂时性死区），而var 不会 const 声明一个只读的常量。一旦声明，常量的值就不能改变（如果声明是一个对象，那么不能改变的是对象的引用地址） 10.在JS中什么是变量提升，什么是暂时性四区？变量提升就是在变量声明之前就可以使用，值为undefined在代码块中，使用let/const 命令声明变量之前，该变量都是不可用的。这在语法上称为“暂时性死区”。暂时性死区也意味着typeof不再是一个百分之百安全的操作123typeof x; // referenceError(暂时性死区)let x;typeof y; // 值是undefined，不会抛错 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 11.如何正确的判断this?箭头函数的this是什么？this的绑定有四种规则：默认绑定、隐式绑定、显式绑定，new绑定 函数是否在new中调用（new绑定），如果是，那么this绑定的是新创建的对象。 函数使用通过call,apply调用，或者使用了bind（即硬绑定），如果是，那么this绑定的就是指定的对象 函数是否在某个上下文对象中调用（隐式绑定），如果是的话，this绑定的就是那个上线文对象。一般是obj.foo() 如果以上都不是，那么使用默认绑定。如果在严格模式下，则绑定到undefined，否则绑定到全局对象。 如果把null或者undefined作为this的绑定对象传入call、appley或者bind,这些值在调用时会被忽略，实际应用的是默认绑定规则。 箭头函数没有this,她的this继承于上一层代码块的this 测试下你已经get的知识点（浏览器执行环境）123456789101112131415161718192021var number = 5;var obj = &#123; number: 3, fn1: (function()&#123; var number; this.number *= 2 number = number * 2; number = 3; return function () &#123; var num = this.number; this.number *= 2; console.log(num); number *= 3; console.log(number); &#125; &#125;)()&#125;var fn1 = obj.fn1;fn1.call(null);obj.fn1();console.log(window.number); 12.词法作用域和this的区别 词法作用域是由你写代码时将变量和块作用域写在哪里来决定的 this是在被调用的时候被绑定的，this指向什么？完全取决于函数的调用位置 13.谈谈你对JS执行上下文栈和作用域链的理解执行上下文就是当前JS代码被解析和执行时所在的环境，JS执行上下文栈可以认为是一个存储函数调用的栈结构，遵循先进后出的原则。 Javascript 执行在单线程上，所有的代码都是排队执行 一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。 每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。 浏览器的JS执行引擎总是访问栈顶的执行上下文 全局上下文只有唯一的一个，它在浏览器关闭时出栈。作用域链：无论是LHS还是RHS查询，都会在当前的作用域开始查找，如果没有找到，就会继续向上级作用域链查找目标标识符，每次上升一个作用域，一直到全局作用域为止。 14.什么是闭包？闭包的作用是什么?闭包有哪些使用场景？闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包最常用的方式就是在一个函数内部创建另一个函数。闭包的作用有： 封装私有变量 模仿块级作用域（es5中没有块就作用域） 实现JS的模块 15.call、apply有什么区别？call，apply和bind的内部是如何实现的？call和apply的功能相同，区别在于传参的方式不一样： fn.call(obj,arg1,arg2,…)调用一个函数，具有一个指定的this值和分别提供的指定的参数（参数的列表） fn.apply(obj, [argsArray])调用一个函数，具有一个指定的this值，一个作为一个数组（或类数组对象）提供的参数。 call核心： 将函数设为传入参数的属性 指定this到函数并传入给定参数执行函数 如果不传入参数或者参数为null，默认指向为window/global 删除参数上的函数call方法的实现：1234567891011121314151617181920212223Object.prootype.call = function (context) &#123; if (!context) &#123; context = typeof window === 'undefined' : global ? window; &#125; contex.fn = this; // this的指向是当前函数function的实例 let rest = [...argument].slice(1); let result = context.fn(...rest); delete context.fn; return result;&#125;// 测试代码var foo = &#123; name: 'Selina';&#125;var name = 'Chirs';function bar(job, age) &#123; console.log(this.name); console.log(job, age);&#125;bar.call(foo, 'programmer', 20);// Selina programmer 20bar.call(null, 'teacher', 25);// 浏览器环境：Chirs teacher 25 // node 环境：undefined teacher 25 apply apply的实现和call很类似，但是需要注意他们的参数是不一样的，apply的第二个参数是数组或类数组123456789101112131415161718192021222324252627Object.prototype.apply = function (context, rest) &#123; if (!context) &#123; context = typeof window === 'undefined' ? global : window; &#125; constext.fn = this; let result; if (rest === undefined || rest === null) &#123; result = context.fn(rest); &#125; else if (type rest === 'object') &#123; result = context.fn(...rest) &#125; delete context.fn; return result;&#125;// 测试代码var foo = &#123; name: 'Selina';&#125;var name = 'Chirs';function bar(job, age) &#123; console.log(this.name); console.log(job, age);&#125;bar.apply(foo, ['programmer', 20]);// Selina programmer 20bar.call(null, 'teacher', 25);// 浏览器环境：Chirs teacher 25 // node 环境：undefined teacher 25 bind bind和call/apply 有一个很重要的的区别，一个函数被call/apply的时候，会直接调用，但是bind会创建一个新函数。当这个新函数被调用时，bind()的第一个参数作为它运行时的this，之后的一序列参数将会在传递的实参前传入作为它的参数。123456789101112131415161718192021222324Function.prototype.bind = function (context) &#123; if(typeof this !== 'function') &#123; throw new TypeError('not a function'); &#125; let self = this; let args = [...arguments].slice(1); function Fn() &#123;&#125; Fn.prototype = this.prototype; let bound = function () &#123; let res = [...args, ...arguments]; context = this instanceof Fn ? this : context || this; return self.apply(context, res) &#125; // 原型链 bound.prototype = new Fn(); return bound; &#125;var name = 'jack';function person(age, job, gender) &#123; console.log(this.name, age, job, gender);&#125;var Yve = &#123;name: 'Yvette'&#125;;let result = person.bind(Yve, 22, 'enginner')('female') 16.new的原理是什么？通过new的方式创建对象和通过字面量创建有啥区别？new: 创建一个新对象 这个新对象会被执行[[原型]]连接 将构造函数的作用域值赋值给新对象，即this指向这个新对象 如果函数没有返回其他对象，那么new 表达式中的函数调用会自动返回这个新对象123456789function new(func) &#123; let target = &#123;&#125;; target._proto_ = func.prototype; let res = func.call(target); if (typeof (res) == 'object' || typeof (res) == \"function\") &#123; return res; &#125; return target;&#125; 字面量创建对象，不会调用Object构造函数，简洁且性能更好；new Object() 方式创建对象本质上是方法的调用，涉及到在proto链中遍历该方法，当找到该方法后，又会生产方法调用必须的堆栈信息，方法调用结束后，还有释放该堆栈，性能不如字面量的方式。 17.谈谈你对原型的理解在JavaScript中，每当定义一个对象（函数也是对象）时候，对象中都会包含一些预定义的属性。其中每个函数对象都有一个prototype属性，这个属性指向函数的原型对象。使用原型对象的好处就是所有对象实例共享共享它所包含的属性和方法。 18.什么是原型链？【原型链解决是什么问题？】原型链解决的主要是集成问题每个对象拥有一个原型对象，通过proto指针指向其原型对象，并从中集成方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向null。这种关系称为原型链，同过原型链可以拥有定义在其他对象的中的属性和方法1p._proo_ === Parent.prototype 19.prototype 和 proto 区别是什么？prototype 是构造函数的属性proto是每个实例都有的属性，可以访问[[prototype]]属性实例的proto与其构造函数的prototype指向的是同一个对象12345678function Student(name) &#123; this.name = name;&#125;Student.prototype.setAge = function() &#123; this.age = 20;&#125;let Jack = new Student('jack');console.log(Jack._proto_ === Student.prototype); 20.使用ES5实现一个继承？ 组合继承（最常用的方式） 12345678910111213function SuperType() &#123; this.name = ''; this.colors = ['red', 'yellow', 'blue'];&#125;SuperType.prototype.sayName = function () &#123; console.log(this.name)&#125;function SubType (name, age) &#123; SuperType.call(this, age); this.age = age;&#125;SubType.prototype = new SuperType();SubType.prototype.construction = SubType; 21.什么是深拷贝?深拷贝和浅拷贝的区别是什么？浅拷贝是值值复制第一层对象，但是当对象的属性是引用类型时，实质是复制的其引用，当引用指向的值改变时也会跟着变化。 深拷贝复制变量值了，对于非基本类型的变量，则递归至基本类型变量后，在复制。深拷贝的对象和原来的对象是隔离的，互不影响，对一个对象的修改并不会影响另一个对象。实现一个深拷贝：12345678910111213function deepClone(obj) &#123; if (obj === undefined) return null; if (obj instanceof RegExp) return new RegExp(obj); if (obj instanceof Date) return new Date(obj); if (typeof obj !== 'object') &#123; return obj; // 不是复杂数据类型的话直接返回 &#125; let t = new obj.constuctor(); for (let key in obj) &#123; t[key] = deepClone(obj(key)); &#125; return t;&#125; 22.防抖和节流的区别是什么？防抖和节流的实现？防抖和节流的作用都是防止函数的多次调用。区别在于，假设一个用户一直触发这个函数且每次触发函数的时间小于设置的时间，防抖的情况下只会调用一次，而节流的情况是每个一定时间调用一次函数。 防抖（debounce）: n秒内函数只执行一次，如果n秒内高频事件再次被触发，则重新计算时间 123456789101112131415161718192021222324252627282930313233function debounce(func, wait, immediate=true) &#123; let timeout, context, args; const later = () =&gt; settimeout(() =&gt; &#123; timeout = null; // 延时函数执行完毕，清空计时器 // 延迟执行的情况下，函数会在延迟函数中执行 // 使用到之前的的缓存参数和执行上下文 if (!immediate) &#123; func.appy(context, args); context = args = null; &#125; &#125; , wait); let debounced = function (...params) &#123; if (!timeout) &#123; timeout = later(); if(immediate) &#123; // 立即执行 func.apply(this, params); &#125; else &#123; // 闭包 constext = this; args = params; &#125; &#125; else &#123; clearTimeout(timeout); timeout = later(); &#125; &#125; debounced.cancel = function (params) &#123; clearTimeout(timeout); timeout = null &#125;; return debounced;&#125; 防抖的应用场景: 每次resize/scroll触发统计事件 文本输入的验证（连续输入文字后发送AJAX请求进行验证，验证一次就好） 节流（throttle）: 高频事件在规定的时间内只会执行一次，执行一次后，只有大于设定的执行周期后才会执行第二次。 123456789101112131415161718192021222324252627282930313233343536function throttle(func, wait, options) &#123; var timeout, context, args, result; var previous = 0; if (!options) options = &#123;&#125;; var later = function () &#123; previous = options.leading === false ? 0: Date.now() || new Date().getTime(); timeout = null; result = func.apply(context, args); if (!timeout) context = args = null; &#125; var throttled = function() &#123; var now = Date.now() || new Date().getTime(); if (!previous &amp;&amp; options.leading === false) previous = now; var remaining = wait - (now - previous); context = this; args = arguments; if (remaining &lt;= 0 || remaining &gt; wait) &#123; if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; result = func.apply(context, args); &#125; else if(!timeout &amp;&amp; options.trailing !== false) &#123; // 判断是否设置了定时器和trailing timeout = setTimeout(later, remaining); &#125; return result; &#125; throttled.cancel = function () &#123; clearTimeout(timeout); previous = 0; timeout = context = args = null; &#125; return throttled;&#125; 函数节流的应用场景有： DOM 元素的拖拽功能的实现（mousemove） 设计游戏的mousedown/keydown时间（单位时间内只能发送一颗子弹） 计算鼠标移动的距离（mousemove） canvas模拟画板功能（mousemove） 搜索联想 监听滚动事件是否到页面底部自动加载更多：给scroll加了debounce后，只能用户停止滚动后，才能判断是否到了页面底部；如果是throttle的话，只要页面滚动就会间隔一段时间判断一次 23.取数组中的最大值（ES5、5S6）12345678// es5Math.max.apply(null, [14, 3, 77, 301]);// es6Math.max(...[14, 3, 77, 301])// reduce[14, 3, 77, 301].reduce((accumulator, currentValue) =&gt; &#123; return accumulator = accumulator &gt; currentVale ? accumulator : currentValue;&#125;); 24.ES6新的特性有哪些？ 新增了块级作用域（let 和 const） 提供了定义类的语法糖 新增了一种基本数据类型（Symbol） 新增了变量的结构赋值 函数参数允许设置默认值，引入了rest参数，新增了箭头函数 数组新增了一些API, 如isArray/from/of方法；数组实例新增了entries(), keys()和values()等方法 对象好数组新增了扩展运算符 ES6新增了模块化（import/export） ES6新增了Set和Map数据结构 ES6 原生提供了Proxy构造函数，用来生成Proxy实例 ES6 新增了生成器（Generator）和遍历器（iterator） 25.setTimeout倒计时为什么会出现误差？setTimeout()只是将事件加入了“任务队列”，必须等待当前执行栈执行完，主线程才会去执行它指定的回调函数。要是当前代码消耗时间很长，也有可能要等很久，所以并不能保证回调函数一定会在setTimeout()指定的时间执行。所以，setTimeout()的第二个参数表示的是最少时间，并非确切时。 HTML5标准规定了setTimeout()的第二参数的最小值不得小于4毫秒，如果低于这个值，则默认是4毫秒。在此之前，老版本的浏览器都将最短时间设为10毫秒。另外，对于那些DOM的变动（尤其是涉及页面重新渲染的部分），通常是间隔16毫秒执行，这时使用requestAnimationFrame()的效果要好于setTimeout() 26.为什么0.1 + 0.2 != 0.3因为在进制转换和进阶运算的过程中出现精度损失。 27.promise有几种状态，Promise有什么优缺点？promise有三种状态：fulfilled,rejected,pendingPromise的优点： 一旦状态改变就不会变，任何时候都可以得到这个结果。 可以将异步操作以同步操作表达出来，避免了层层嵌套的回调函数Promise的缺点： 无法取消Promise 当处于pending状态时，无法得知目前进展到哪一个阶段 28.Promise构造函数是同步执行还是异步执行，then中方法呢？promise如何实现then处理？promise的构造函数是同步执行的。then中的方法是异步执行的。promise的then实现 29. Promise和setTimeout的区别？Promise是微服务，setTimeout是宏服务，同一个事件循环中，promise.then总是先于setTimeout执行。 30. 如何实现Promise.all?123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051Promise.all = function (promises) &#123; return new Promise((resolve, reject) =&gt; &#123; let index = 0; let result = []; if (promises.length === 0) &#123; resolve(result); &#125; else &#123; function processValue(i, data) &#123; result[i] = data; if (++index === promises.length) &#123; resolve(result); &#125; &#125; for (let i = 0; i &lt; promises.length; i++) &#123; Promise.resolve(promises[i].then((data) =&gt; &#123; processValue(i, data); &#125;,(err) =&gt; &#123; reject(err); return; &#125;)); &#125; &#125; &#125;);&#125;``` ---### 31.如何实现Promise.finally?不管成功还是失败，都会走到finally中，并且finally之后，还可以继续then。并且将值原封不动的传递给后面的then```javascriptPromise.prototype.finally = function (callback) &#123; return this.then((value) =&gt; &#123; return Promise.resolve(callback()).then(() =&gt; &#123; return value; &#125;); &#125;, (err) =&gt; &#123; return Promise.resolve(callback()).then(() =&gt; &#123; throw err; &#125;) &#125;);&#125;``` ### 32.什么是函数的柯里化？实现sum(1)(2)(3) 返回的结果是1,2,3的和```javascriptfunction sum (a) &#123; return function (b)&#123; return function (c) &#123; return a + b + c; &#125; &#125;&#125;sum(1)(2)(3); 引申：实现一个curry函数，将普通函数进行柯里化：1234567891011121314151617function cuury(fn, args = []) &#123; return function() &#123; let rest = [...args, ...arguments]; if (rest.length &lt; fn.length) &#123; return curry.call(this, fn, rest); &#125; else &#123; return fn.apply(this, rest) &#125; &#125;&#125;// testfunction sum(a, b, c) &#123; return a + b + c;&#125;let sumFn = curry(sum);console.log(sumFn(1)(2)(3)); // 6console.log(sumFn(1)(2)(3)); // 6","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}],"keywords":[]},{"title":"java开发中，使用自动化管理工具来管理项目之maven 和 gradle","slug":"使用maven自动化管理工程","date":"2019-09-10T00:28:34.987Z","updated":"2019-03-27T01:10:18.804Z","comments":true,"path":"2019/09/09/使用maven自动化管理工程/","link":"","permalink":"http://yoursite.com/2019/09/09/使用maven自动化管理工程/","excerpt":"java开发中，使用自动化管理工具来管理工程之maven 和 gradle的基本使用","text":"java开发中，使用自动化管理工具来管理工程之maven 和 gradle的基本使用 maven和gradle都是工程自动化管理工具。 maven篇章 maven官网 一、安装maven 官网网下载安装包（如：.zip文件） 解压缩在某个目录下。笔者是：E:\\Downloads\\apache-maven-3.6.0-bin\\apache-maven-3.6.0 自定义依赖包的下载目录 找E:\\Downloads\\apache-maven-3.6.0-bin\\apache-maven-3.6.0\\conf目录（可能不同，得看解压缩包到底安装在哪）下的settings.xml文件 修改 此文件中的 localRepository（默认是被注释掉的） 标签中的值（一个特定的目录，用来存放依赖包）如笔者：E:\\Downloads\\apache-maven-3.6.0-bin\\repository 配置环境变量 新建变量：MAVEN_HOME:E:\\Downloads\\apache-maven-3.6.0-bin\\apache-maven-3.6.0 添加到环境变量：%MAVEN_HOME%\\bin 检查是否安装成功 cmd 中 输入 mvn -version 输出版本信息，则说明已经安装成功 使用maven 打开idea或eclipse等这样的集成开发工具 idea集成maven maven配置：File &gt; Setting &gt; Build,Execution,Deployment&gt;maven12Maven home directory: `E:\\Downloads\\apache-maven-3.6.0-bin\\apache-maven-3.6.0`Local repository: `E:\\Downloads\\apache-maven-3.6.0-bin\\repository` 打开已经存在的maven项目（或者可自己创建），如： 在idea中：File &gt; Open 在idea的右侧边栏，有maven选项，点击后，弹出面板，然后单击刷新即可自动安装项目依赖包 等安装完成后，可以在 E:\\Downloads\\apache-maven-3.6.0-bin\\repository 查看安装的依赖包 maven 主要指令123456`终端进入到`pox.xml`文件所在的目录下`mvn -version # 查看当前maven的版本信息mvn clean # 清除打包之后的target目录mvn package # 运行打包，生成jar包# 运行包 如：java -jar target/platform-plus.jar 注意：jar包的运行必须要有java环境（即得安装JDK） gradle篇章","categories":[],"tags":[{"name":"maven gradle","slug":"maven-gradle","permalink":"http://yoursite.com/tags/maven-gradle/"}],"keywords":[]},{"title":"weex 扩展Android 和 iso 的能力","slug":"weex 扩展Android的能力","date":"2019-09-10T00:28:34.975Z","updated":"2019-03-23T07:24:50.851Z","comments":true,"path":"2019/09/09/weex 扩展Android的能力/","link":"","permalink":"http://yoursite.com/2019/09/09/weex 扩展Android的能力/","excerpt":"weex 扩展Android 和 iso 的能力, 来自weex官网","text":"weex 扩展Android 和 iso 的能力, 来自weex官网 Module 扩展 Module 扩展必须继承WXModule类。 扩展方法必须加上@JSMethod(uiThread = false or true)注解。Weex会根据注解来判断当前方法是否要运行在UI线程。 Weex是根据反射来调用Module扩展方法，所以Module中的扩展方法必须是pulic类型。 同样是因为反射调用，Module不能被混淆。请在混淆文件中添加代码:-keep public class * extends com.taobao.weex.common.WXModule{*;}。 Module扩展方法可以使用int,double,float,String,Map,List类型的参数。 完成Module后一定要在初始化注册WXSDKEngine.registerModule(&quot;myModule&quot;, MyModule.class),否则会报类似错误：ReportException :undefined:9: TypeError: Object #&lt;Object&gt; has no method &#39;printLog&#39;; 示例如下：12345678910111213pulic class MyModule extends WXModule &#123; // run ui thread @JSMethod(uithead = true) public void printLog(String str) &#123; Toast.makeText(mWXSDKInstance.getContext(),msg,Toast.LENGTH_SHORT).show(); &#125; // run JS thread @JSMethod(uiThread = false) public void fireEventSyncCall() &#123; // implement your module logic here &#125;&#125; Register the module1WXSDKEngine.registerModule('MyModule', MyModule.class); JS调用如下：123456789101112131415&lt;template&gt; &lt;div&gt; &lt;text onclick='click'&gt;testMyModule&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: ''. methods: &#123; click() &#123; weex.requireModule('MyModule').printLog(\"i am a weex Module\"); &#125; &#125; &#125;&lt;/script&gt; Module 注册registerModule(moduleName,moduleClass) return {bool}: 是否注册成功 moduleName {String}: 模块名称 moduleClass {Class}: 模块对应的class,创建module 实例时调用 使用方式：1WXSDKEngine.registerModule('picker', WXPickersModule.class); Component 扩展（version&lt; 0.19.0） Component 扩展类必须继承 WXComponent. Component 对应的设置属性的方法必须添加注解 @WXComponentProp(name=value(value is attr or style of dsl)) Weex sdk 通过反射调用对应的方法，所以 Component 对应的属性方法必须是 public，并且不能被混淆。请在混淆文件中添加代码-keep public class * extends com.taobao.weex.ui.component.WXComponent{*;} Component 扩展的方法可以使用 int, double, float, String, Map, List 类型的参数 完成 Component 后一定要在初始化时注册 WXSDKEngine.registerComponent(&quot;richText&quot;, RichText.class);示例如下：1234567891011121314151617public class RichText extends WXComponent&lt;TextView&gt; &#123; public RichText(WXSDKInstance instance, WXDomObject dom, WXContainer parent) &#123; super(instance, dom, parent); &#125; @Override protected TextView initComponentHostView(@NonNull Context context) &#123; TextView textView = new TextView(context); textView.setTextSize(20); textView.setTextColor(Color.banck); return textView; &#125; @WXComponentProp(name = \"tel\") public void setTel(String telNumber) &#123; getHostView().setText(\"tel:\" + telNumber); &#125;&#125; 注册你的组件：1WXSDKEngine.registerComponent('RichText', RichText.class); JS调用如下：12345&lt;template&gt; &lt;div&gt; &lt;richText tel=\"12305\" style=\"width:200;height:100\"&gt;12305&lt;/richText&gt; &lt;/div&gt;&lt;/template&gt; Component 注册registerComponent(type,class,appendTree) return(bool): 是否注册成功 type(String): 前端使用的对应标签 class(Class): 组件的class，在创建组件实例时调用 appendTree(bool): 渲染时判定逻辑，默认false 如果为true，则这个组件的子组件，整颗树建立、layout完后，整体一起刷新。 如果为false，则这个组件的子组件，每add一个，刷新一个。使用方式：1WXSDKEngine.registerComponent('video', WXVideo, false); registerComponent(holder,appendTree，…names) return(bool): 是否注册成功 holder(IFComponentHolder): 用于创建component的抽象工厂，默认使用SimpleComponentHolder。 appendTree: 同上 names(String …): 前端使用的对应标签使用方式:12345678WXSDKEngine.registerComponent( new SimpleComponentHolder( WXText.class, new WXText.Creator() ), false, \"text\" ); Adapter 扩展图片库Adapter需要时集成接口 IWXImgLoaderAdapter，实现 setImage 方法。示例代码：12345678910111213141516171819202122232425262728293031323334public class ImageAdapter implements IWXImgLoaderAdapter &#123; public ImageAdapter() &#123; &#125; @Override public void setImage(final String url, final ImageView view, WXImageQuality quality, WXImageStrategy strategy) &#123; WXSDKManager.getInstance().postOnUiThread(new Runnable() &#123; @Override public void run() &#123; if(view==null||view.getLayoutParams()==null)&#123; return; &#125; if (TextUtils.isEmpty(url)) &#123; view.setImageBitmap(null); return; &#125; String temp = url; if (url.startsWith(\"//\")) &#123; temp = \"http:\" + url; &#125; if (view.getLayoutParams().width &lt;= 0 || view.getLayoutParams().height &lt;= 0) &#123; return; &#125; Picasso.with(WXEnvironment.getApplication()) .load(temp) .into(view); &#125; &#125;,0); &#125;&#125; Adapter 注册WEEX和图片库完全解耦，WEEX的图片加载，都是通过调用公共接口，由实现类决定调用哪个图片库 一个相对完整的源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168package com.alibaba.weex;import android.app.Activity;import android.app.Application;import android.os.Bundle;import com.alibaba.android.bindingx.plugin.weex.BindingX;import com.alibaba.weex.commons.adapter.DefaultWebSocketAdapterFactory;import com.alibaba.weex.commons.adapter.ImageAdapter;import com.alibaba.weex.commons.adapter.JSExceptionAdapter;import com.alibaba.weex.commons.adapter.PicassoBasedDrawableLoader;import com.alibaba.weex.extend.adapter.ApmGenerator;import com.alibaba.weex.extend.adapter.DefaultAccessibilityRoleAdapter;import com.alibaba.weex.extend.adapter.InterceptWXHttpAdapter;import com.alibaba.weex.extend.adapter.WXAnalyzerDemoListener;import com.alibaba.weex.extend.component.WXComponentSyncTest;import com.alibaba.weex.extend.component.WXMask;import com.alibaba.weex.extend.component.WXParallax;import com.alibaba.weex.extend.module.GeolocationModule;import com.alibaba.weex.extend.module.MyModule;import com.alibaba.weex.extend.module.RenderModule;import com.alibaba.weex.extend.module.SyncTestModule;import com.alibaba.weex.extend.module.WXEventModule;import com.alibaba.weex.extend.module.WXTitleBar;import com.alibaba.weex.extend.module.WXWsonTestModule;import com.facebook.drawee.backends.pipeline.Fresco;import com.taobao.weex.InitConfig;import com.taobao.weex.WXEnvironment;import com.taobao.weex.WXSDKEngine;import com.taobao.weex.WXSDKManager;import com.taobao.weex.bridge.WXBridgeManager;import com.taobao.weex.common.WXException;import com.taobao.weex.performance.WXAnalyzerDataTransfer;public class WXApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); /** * Set up for fresco usage. * Set&lt;RequestListener&gt; requestListeners = new HashSet&lt;&gt;(); * requestListeners.add(new RequestLoggingListener()); * ImagePipelineConfig config = ImagePipelineConfig.newBuilder(this) * .setRequestListeners(requestListeners) * .build(); * Fresco.initialize(this,config); **/// initDebugEnvironment(true, false, \"DEBUG_SERVER_HOST\"); WXBridgeManager.updateGlobalConfig(\"wson_on\"); WXEnvironment.setOpenDebugLog(true); WXEnvironment.setApkDebugable(true); WXSDKEngine.addCustomOptions(\"appName\", \"WXSample\"); WXSDKEngine.addCustomOptions(\"appGroup\", \"WXApp\"); WXSDKEngine.initialize(this, new InitConfig.Builder() //.setImgAdapter(new FrescoImageAdapter())// use fresco adapter .setImgAdapter(new ImageAdapter()) .setDrawableLoader(new PicassoBasedDrawableLoader(getApplicationContext())) .setWebSocketAdapterFactory(new DefaultWebSocketAdapterFactory()) .setJSExceptionAdapter(new JSExceptionAdapter()) .setHttpAdapter(new InterceptWXHttpAdapter()) .setApmGenerater(new ApmGenerator()) .build() ); WXSDKManager.getInstance().addWXAnalyzer(new WXAnalyzerDemoListener()); WXAnalyzerDataTransfer.isOpenPerformance = false; WXSDKManager.getInstance().setAccessibilityRoleAdapter(new DefaultAccessibilityRoleAdapter()); try &#123; Fresco.initialize(this); WXSDKEngine.registerComponent(\"synccomponent\", WXComponentSyncTest.class); WXSDKEngine.registerComponent(WXParallax.PARALLAX, WXParallax.class); WXSDKEngine.registerModule(\"render\", RenderModule.class); WXSDKEngine.registerModule(\"event\", WXEventModule.class); WXSDKEngine.registerModule(\"syncTest\", SyncTestModule.class); WXSDKEngine.registerComponent(\"mask\", WXMask.class); WXSDKEngine.registerModule(\"myModule\", MyModule.class); WXSDKEngine.registerModule(\"geolocation\", GeolocationModule.class); WXSDKEngine.registerModule(\"titleBar\", WXTitleBar.class); WXSDKEngine.registerModule(\"wsonTest\", WXWsonTestModule.class); BindingX.register(); /** * override default image tag * WXSDKEngine.registerComponent(\"image\", FrescoImageComponent.class); */ //Typeface nativeFont = Typeface.createFromAsset(getAssets(), \"font/native_font.ttf\"); //WXEnvironment.setGlobalFontFamily(\"bolezhusun\", nativeFont); &#125; catch (WXException e) &#123; e.printStackTrace(); &#125; registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() &#123; @Override public void onActivityCreated(Activity activity, Bundle bundle) &#123; &#125; @Override public void onActivityStarted(Activity activity) &#123; &#125; @Override public void onActivityResumed(Activity activity) &#123; &#125; @Override public void onActivityPaused(Activity activity) &#123; &#125; @Override public void onActivityStopped(Activity activity) &#123; &#125; @Override public void onActivitySaveInstanceState(Activity activity, Bundle bundle) &#123; &#125; @Override public void onActivityDestroyed(Activity activity) &#123; // The demo code of calling 'notifyTrimMemory()' if (false) &#123; // We assume that the application is on an idle time. WXSDKManager.getInstance().notifyTrimMemory(); &#125; // The demo code of calling 'notifySerializeCodeCache()' if (false) &#123; WXSDKManager.getInstance().notifySerializeCodeCache(); &#125; &#125; &#125;); &#125; /** *@param connectable debug server is connectable or not. * if true, sdk will try to connect remote debug server when init WXBridge. * * @param debuggable enable remote debugger. valid only if host not to be \"DEBUG_SERVER_HOST\". * true, you can launch a remote debugger and inspector both. * false, you can just launch a inspector. * @param host the debug server host, must not be \"DEBUG_SERVER_HOST\", a ip address or domain will be OK. * for example \"127.0.0.1\". */ private void initDebugEnvironment(boolean connectable, boolean debuggable, String host) &#123; if (!\"DEBUG_SERVER_HOST\".equals(host)) &#123; WXEnvironment.sDebugServerConnectable = connectable; WXEnvironment.sRemoteDebugMode = debuggable; WXEnvironment.sRemoteDebugProxyUrl = \"ws://\" + host + \":8088/debugProxy/native\"; &#125; &#125;&#125;","categories":[],"tags":[{"name":"weex","slug":"weex","permalink":"http://yoursite.com/tags/weex/"}],"keywords":[]},{"title":"weex 集成到 Android 应用","slug":"weex集成到android应用","date":"2019-09-10T00:28:34.963Z","updated":"2019-03-21T10:27:17.257Z","comments":true,"path":"2019/09/09/weex集成到android应用/","link":"","permalink":"http://yoursite.com/2019/09/09/weex集成到android应用/","excerpt":"weex 集成到 Android 应用weex官网","text":"weex 集成到 Android 应用weex官网 设置gradle依赖 在build.gradle中的dependencies添加支持Android开发的依赖1234567891011dependencies &#123; ... // weex sdk and fastjson compile 'com.taobao.android:weex_sdk:0.20.0.2@aar' compile 'com.alibaba:fastjson:1.1.46.android' //support library dependencies compile 'com.android.support:recyclerview-v7:23.1.1' compile 'com.android.support:support-v4:23.1.1' compile 'com.android.support:appcompat-v7:23.1.1'&#125; 配置混淆规则 12345-keep class com.taobao.weex.bridge.** &#123; *; &#125;-keep class com.taobao.weex.layout.** &#123; *; &#125;-keep class com.taobao.weex.WXSDKEngine &#123; *; &#125;-keep class com.taobao.weex.base.SystemMessageHandler &#123; *; &#125;-dontwarn com.taobao.weex.bridge.** 声明权限 在AndroidManifest.xml中声明权限1234567//网络&lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/&gt;//sd卡读写&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/&gt;&lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/&gt; 初始化sdk 12345678910InitConfig config = new InitConfig.Builder() //.setImgAdapter(new FrescoImageAdapter())// use fresco adapter .setImgAdapter(new ImageAdapter()) .setDrawableLoader(new PicassoBasedDrawableLoader(getApplicationContext())) .setWebSocketAdapterFactory(new DefaultWebSocketAdapterFactory()) .setJSExceptionAdapter(new JSExceptionAdapter()) .setHttpAdapter(new InterceptWXHttpAdapter()) .setApmGenerater(new ApmGenerator()) .build();WXSDKEngine.initialize(applicationContext, config); 创建WXSDKInstance WXSDKInstance是weex 渲染页面的基本单元 通过instance.render(url)拉取bundle 在回调IWXrenderListener的onViewCreated返回创建的view 将返回的view添加到Activity的view上（rootView）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class MainActivity extends AppCompatActivity implements IWXRenderListener &#123; WXSDKInstance mWXSDKInstance; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mWXSDKInstance = new WXSDKInstance(this); mWXSDKInstance.registerRenderListener(this); /** * bundleUrl source http://dotwe.org/vue/38e202c16bdfefbdb88a8754f975454c */ String pageName = \"WXSample\"; String bundleUrl = \"http://dotwe.org/raw/dist/38e202c16bdfefbdb88a8754f975454c.bundle.wx\"; mWXSDKInstance.renderByUrl(pageName, bundleUrl, null, null,WXRenderStrategy.APPEND_ASYNC); &#125; @Override public void onViewCreated(WXSDKInstance instance, View view) &#123; setContentView(view); &#125; @Override public void onRenderSuccess(WXSDKInstance instance, int width, int height) &#123; &#125; @Override public void onRefreshSuccess(WXSDKInstance instance, int width, int height) &#123; &#125; @Override public void onException(WXSDKInstance instance, String errCode, String msg) &#123; &#125; @Override protected void onResume() &#123; super.onResume(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityResume(); &#125; &#125; @Override protected void onPause() &#123; super.onPause(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityPause(); &#125; &#125; @Override protected void onStop() &#123; super.onStop(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityStop(); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityDestroy(); &#125; &#125;&#125; 运行app 运行app 扩展Android能力 Weex提供了能力扩展机制，可以根据自己的业务定制自己的功能。主要分为： Module 扩展，非UI的特定功能。例如sendHttp、openURL等。 Component 扩展，实现特别功能的Native控件。例如：RichTextiew, RefreshListview 等。 Adapter扩展，Weex对一些基础功能实现了统一接口，可实现这些接口来定制自己的业务。例如，图片下载等。","categories":[],"tags":[{"name":"weex","slug":"weex","permalink":"http://yoursite.com/tags/weex/"}],"keywords":[]},{"title":"git 分支剖析","slug":"git 分支操作","date":"2019-09-10T00:28:34.951Z","updated":"2019-03-13T06:45:07.495Z","comments":true,"path":"2019/09/09/git 分支操作/","link":"","permalink":"http://yoursite.com/2019/09/09/git 分支操作/","excerpt":"git 的分支是它最明显的特性， 大部分人听别人推荐使用git都会听到“git分支操作方便…”，对比其他版本控制系统git 分支操作有难以置信的轻量，创建新分支几乎瞬间完成，不同分支之间切换也非常快捷方便； 本文主要介绍了git分支的创建和删除，以及 push、pull、merge等基本操作","text":"git 的分支是它最明显的特性， 大部分人听别人推荐使用git都会听到“git分支操作方便…”，对比其他版本控制系统git 分支操作有难以置信的轻量，创建新分支几乎瞬间完成，不同分支之间切换也非常快捷方便； 本文主要介绍了git分支的创建和删除，以及 push、pull、merge等基本操作 创建分支首先我们得知道， GIT分支包括本地分支 与 远程分支。 有时远程有的分支我们本地没有（其他同事维护的分支）， 或者本地有的分支远程没有（修复线上小问题开的本地小分支）； 创建本地分支（有2种方法） 新分支都是基于原有分支创建， 而在实践开发中基本从线上分支（与线上代码同步的分支）master 分支创建。而 从master创建本地分支也有两种方式： 基于【本地master分支】创建本地分支 12345678git branch # 查看本地分支git branch xxx # 基于当前分支创建某分支git checkout xxx # 切换某分支git checkout -b newBranchName # 创建并切换到新分支（可以基于xxx分支创建新分支）如：git checkout master # 切换到本地master分支git pull # 更新本地master分支的代码至最新git pull origin master # 如 本地master分支未关联远程master分支 基于【远程master分支】创建本地分支 123git branch -a # 查看线上分支和本地分支信息 白色表示为本地分支 绿色为当前分支 红色表示线上分支git checkout remotes/origin/master # 切换到远程分支git checkout -b newBranchName # 基于远程master分支创建新分支 创建远程分支 创建远程分支可以直接由本地新分支推送完成也可以在远程分支管理系统（例如：github 、gitLab）上可视化操作完成。 本地新分支推送创建远程分支 如果本地创建的分支上上更新了代码，然后执行git add、git commit指令后， 再执行以下指令可在远程创建新分支；1git push origin newBranch:newBranch # git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; GitHub上创建远程分支 选中项目， 然后在项目首页左上侧点选分支按钮， 弹出的弹层输入新分支名称即可； PS: 上述创建的同名本地分支跟远程分支并没建立关联， 这样操作指令会比较不方便（如“git pull”指令得输入对应的远程分支名）， 怎么让其建立关联？12345678git checkout newBranchName # 切换到newBranchName分支(如当前处在其他分支)git pull # 执行更新代码指令# 执行git pull 就能看到git 的关联提示：# 按照其提示提示执行指令即可：# git branch --set-upstream-to=origin/&lt;远程分支名&gt; &lt;本地分支名&gt;如设置当前分支，第二个参数可省略,；git branch --set-upstream-to=origin/newBranchName # 校验是否关联成功：git pull # 提示 “Already up-to-date.” 表示已关联成功； 合并分支分支代码合并也有两方式： 合并本地分支代码、合并远程分支代码； 合并本地分支代码: 例如在新分支 newBranch开发的功能已完成并已提交；接下来走测试流程需要将代码合并到develop分支（我所在团队develop为测试分支，不同团队的测试分支会不一样）12345git checkout newBranch # 首先切换到本地分支git pull # 然后更新代码git checkout develop # 再次切换到develop分支git merge newBranch # 最后才能执行合并操作git push # 提交commit到远程（newBranch分支有多少个commit就会生成几个） 其实可直接将远程的 newBranch分支代码合并到本地 develop分支：1git pull origin newBranch 合并代码冲突解决 无论哪种方式合并分支代码代码冲突是无可避免的情况， 开发流程使用了typescript/sass等需要执行编译的语言更容易产生冲突；分支合并代码冲突跟一般代码冲突一样： git能处理的冲突会自动解决， 否则就得手动解决冲突；冲突是由于多人维护代码导致，一定要找到相关人一起讨论冲突代码的取舍； 删除分支上线流程完成：应删除本地分支及远程分支(git lab分支)： git branch -D xxxx， 上线完成意味着当前xxx分支代码已经合并到线上分支（master）以及开发分支(develop)， 该分支后续功能的改动（bug修复或代码扩展）完全可以在master新开分支完成；（否则可能遗忘删除，导致远程分支原来越多） 删除本地分支 12git branch -d xxxx # 如果该分支代码未合并到其他分支，将无法删除git branch -D xxxx # 强制删除分支，不会出现任何提示 删除远程分支删除远程分支两种方式： 1.在git管理系统的Web页面操作（gitLab）；gitHub上无法删除远程分支， 如果你团队使用的是gitLab那可以在gitLab管理页面操作； 2.本地指令完成；1git push origin --delete newBranch","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}],"keywords":[]},{"title":"weex + vue 开发native app 中遇到的问题","slug":"weex 开发 android app 过程中的采坑经历","date":"2019-09-10T00:28:34.951Z","updated":"2019-03-14T09:29:18.683Z","comments":true,"path":"2019/09/09/weex 开发 android app 过程中的采坑经历/","link":"","permalink":"http://yoursite.com/2019/09/09/weex 开发 android app 过程中的采坑经历/","excerpt":"weex + vue 开发native app 中遇到的问题","text":"weex + vue 开发native app 中遇到的问题 image 组件不显示内容的问题： 必须设置宽和高 必须输入正确的src资源路径","categories":[],"tags":[{"name":"weex","slug":"weex","permalink":"http://yoursite.com/tags/weex/"}],"keywords":[]},{"title":"使用git 操作工作空间的基本文件","slug":"git增加删除提交和发布等基本指令的用法","date":"2019-09-10T00:28:34.939Z","updated":"2019-03-12T05:10:05.771Z","comments":true,"path":"2019/09/09/git增加删除提交和发布等基本指令的用法/","link":"","permalink":"http://yoursite.com/2019/09/09/git增加删除提交和发布等基本指令的用法/","excerpt":"使用git 操作工作空间的基本文件","text":"使用git 操作工作空间的基本文件 本地新建目录和文件并提交远程仓库本地新建的目录和文件需要提交远程仓库，供开发人员共享操作步骤： 查看目前代码的修改状态 1234git statusnew file # 表示新建文件modified # 表示修改文件deleted # 表示删除文件 查看代码修改的内容 git diff \\ 比较某文件与最近提交节点的差异。 注意:如果该文件已暂存，那么应该使用 git diff –cached git diff 比较某文件在提交节点a，节点b的差异。 技巧：如果省略后面一个hashcode，则默认表示与上一提交节点比较。（也可以利用^运算符） 暂存需要提交的文件 如果是新建的文件,则用以下指令: git add \\ -a 如果是删除的文件，则用以下指令: git rm 如果忽略某些文件,怎需要在git版本库同级目录下，新建.gitignore文件，但在创建并编辑这个文件之前，一定要保证要忽略的文件没有添加到git索引中。使用命令将要忽略的文件从索引中删除。 git rm –cached filename 提交已暂存的文件 git commit -m ‘message’ git commit 主要是将暂存区里的改动给提交到本地版本库。每次使用git commit 命令我们都会在本地版本库生成一个40位的哈希值，这个哈希值也叫commit-id，commit-id在版本回退的时候是非常有用的，它相当于一个快照,可以在未来的任何时候通过与git reset的组合命令回到这里。 同步到服务器同步到服务器前先需要将服务器代码同步到本地 git pull 如果执行失败，就按照提示还原有冲突的文件，然后再次尝试同步。 git checkout – &lt;有冲突的文件路径&gt; push到远程服务器 git push origin &lt;本地分支名&gt; 如果执行失败，一般是没有将服务器代码同步到本地导致的，先执行上面的git pull命令。","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}],"keywords":[]},{"title":"使用 import 和 export 实现模块化","slug":"使用export和import事项模块化","date":"2019-09-10T00:28:34.927Z","updated":"2019-03-14T04:45:25.190Z","comments":true,"path":"2019/09/09/使用export和import事项模块化/","link":"","permalink":"http://yoursite.com/2019/09/09/使用export和import事项模块化/","excerpt":"在es6 之前，前端是使用RequireJS或者seaJS实现模块化，RequireJS是基于AMD规范的模块化库，而像seaJS是基于CMD规范的模块化库，两者都是推进前端模块化的工具。","text":"在es6 之前，前端是使用RequireJS或者seaJS实现模块化，RequireJS是基于AMD规范的模块化库，而像seaJS是基于CMD规范的模块化库，两者都是推进前端模块化的工具。 现在es6自带了模块化，也是js第一次支持module。 现代浏览器对模块支持程度不同，目前都是使用babelJS、或者Traceur转化为兼容es5版本的js代码。 es6 模块化的基本规则或特点 每个模块只加载一次，每一个JS只执行一次，如果下次再去加载同目录下同文件，直接从内存中读取。一个模块就是一个单例，或者说就是一个对象； 每一给模块内部声明的变量都是局部变量，不会污染全局作用域； 模块内部的变量或者函数可以通过export导出； 一个模块可以导入别的模块； 下面列出几种常用的import和import的基本语法 第一种导出方式： 12345678910111213141516// lib.js filelet bar = 'StringBar';let foo = 'StringFoo';let fn0 = function () &#123; console.log('fn0');&#125;let fn1 = function () &#123; console.log('fn1');&#125;export &#123;bar, foo, fn0, fn1&#125;// main.jsimport &#123;bar, foo, fn0, fn1&#125; from './lib' // 经过结构赋值了console.log(bar+ '_' + foo) // StringBar_StringFoofn0(); // fn0fn1(); // fn1 第二种导出方式 1234567891011// lib.js filelet obj0 = &#123;&#125;;let fn0 = function () &#123; console.log('fn0');&#125;export &#123; fn0 as foo, obj0 as bar&#125;;// main.js fileimport &#123;foo, bar&#125; from './lib.js'foo(); // fn0console.log(bar); // &#123;&#125; 第三种导出的方式 12345678// lib.js fileexport let foo = () =&gt; &#123;console.log('fnFoo');return 'foo';&#125;, bar = 'stringbar';// main.jsimport &#123;foo, bar&#125; from 'lib.js'console.log(foo()) // fnFooconsole.log(bar) // stringbar 第四种导出的方式 12345678910// lib.js fileexport function fn0() &#123; console.log('fn0')&#125;export defult &#123;&#125;// main.jsimport o, &#123;fn0&#125; from 'lib.js'console.log(o) // &#123;&#125;console.log(fn0()) // fn0","categories":[],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}],"keywords":[]},{"title":"学习前端可以从这里出发","slug":"前端资源链路","date":"2019-09-10T00:28:34.919Z","updated":"2019-05-03T09:01:59.877Z","comments":true,"path":"2019/09/09/前端资源链路/","link":"","permalink":"http://yoursite.com/2019/09/09/前端资源链路/","excerpt":"互联网时代，资源共享，各社区生态繁荣，媛（猿）们更是殚精竭虑、乐此不疲的分享着自己的智慧与创新。那么，问题来了：如山如海的网络资源，想入前端坑，路在何方？","text":"互联网时代，资源共享，各社区生态繁荣，媛（猿）们更是殚精竭虑、乐此不疲的分享着自己的智慧与创新。那么，问题来了：如山如海的网络资源，想入前端坑，路在何方？ 声明：完全是自己的学习经验哈如果有需要,欢迎email砸（978189365@qq.com） 如果你是前端小白，前端三剑客（html、css、JavaScript）是必须要懂滴。菜鸟教程是完全免费的资源网站，里面各种编程语言基本都能找到，从前端到后端再到数据库，若君真心并且下定决心想加入程序员的大阵营，我相信总能找到符合你胃口的萝卜青菜~~ 菜鸟教程 w3school领先的 Web 技术教程 - 全部免费，从基础的 HTML 到 CSS，乃至进阶的 XML、SQL、JS、PHP 和 ASP.NET。 w3school 在线教程 w3cschool w3cschool 打开以上链接，按照官网教程，一个demo,一个demo 去体验吧 手册网 最近发现的一个很牛逼的网站 时间：20190313160430 手册网 视频资源网站 慕课网，此网站基础部分一般都是免费的，而且大多数老师都是在一线互联网公司任职的具有一定项目开发经验的大神在讲课，可以跟着老师一步一步去实现教程中的效果，如果遇到自己迈不过的坑可以在视频下方区域提问，有的老师是公开源码的，可以下载，然后一步步去分析，总之，万事开头难是实话，遇到问题不要惊慌（先去百度或者google），不能解决可以去联系源码贡献者。 慕课网-程序员的梦工厂 极客学院是IT在线教育平台-中国专业的IT职业在线教育平台（IT线上培训网站，所以多数视频是收费的） 极客学院 nodejs，如果你学会了javascript, nodejs 一定不要错过，如果学会了nodejs，那么恭喜你，你离全栈工程师不远啦 nodejs，这是官网，学习教程，在菜鸟和慕课上都有，请自行去找 JavaScript框架，是必须要会用的，目前比较火的是react、vue和angular学习教程当属官网是首选、菜鸟、慕课、极客等 reactvueangular 开源中国-找到您想要的开源项目，分享和交流(可以拿到一个完整项目的源码，适用于综合练习，这个跟生产中的实际项目源码很接近，建议多分析，增加项目经验，通过阅读别人的代码来自我提升) 开源中国 github是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。所以先得学会git(分发式版本控制工具)。git的学习教程可以看廖雪峰的个人官网 github 国外网站，由于天朝原因，访问这样的网站，一般得有翻墙，不然网速真的比蜗牛还慢（虽然不知蜗牛到底有多慢），这里能搜到来自全世界的和你一样的编程爱好者的开源代码，如果你英语还可以，经常逛国外的技术网站是个不错的选择。 接下来列举几个比较好的个人网站（博客）和 研发团队 阮一峰的个人网站 张鑫旭的个人主页 十年踪迹的博客 腾讯全端AlloyTeam团队 aotu 实验室 阿里巴巴","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}],"keywords":[]},{"title":"数字证书安装","slug":"数字证书安装","date":"2019-09-10T00:28:34.907Z","updated":"2019-07-22T07:09:24.144Z","comments":true,"path":"2019/09/09/数字证书安装/","link":"","permalink":"http://yoursite.com/2019/09/09/数字证书安装/","excerpt":"4种主流服务器使用https时，在服务器端安装数字证书（ssl）","text":"4种主流服务器使用https时，在服务器端安装数字证书（ssl） Apache服务器安装SSL证书在证书控制台下载Apache版本证书，下载到本地的是一个压缩文件，解压后里面包含_public.crt文件是证书文件，_chain.crt是证书链(中间证书)文件，.key文件是证书的私钥文件（申请证书时如果没有选择系统创建CSR，则没有该文件）。 友情提示： .crt扩展名的证书文件采用Base64-encoded的PEM格式文本文件，可根据需要，修改成.pem等扩展名。 以Apache标准配置为例，假如证书文件名是a_public.crt，证书链文件是a_chain.crt,私钥文件是a.key。 操作步骤: 在Apache的安装目录下创建cert目录，并且将下载的全部文件拷贝到cert目录中。如果申请证书时是自己创建的CSR文件，请将对应的私钥文件放到cert目录下并且命名为a.key； 打开 apache 安装目录下 conf 目录中的 httpd.conf 文件，找到以下内容并去掉“#”。 12#LoadModule ssl_module modules/mod_ssl.so (如果找不到请确认是否编译过 openssl 插件)#Include conf/extra/httpd-ssl.conf（删除行首的配置语句注释符号“#”，保存后退出） 打开 apache 安装目录下 conf/extra/httpd-ssl.conf 文件 (也可能是conf.d/ssl.conf，与操作系统及安装方式有关)， 在配置文件中查找以下配置语句: 1234567891011# 添加 SSL 协议支持协议，去掉不安全的协议SSLProtocol all -SSLv2 -SSLv3# 修改加密套件如下SSLCipherSuite HIGH:!RC4:!MD5:!aNULL:!eNULL:!NULL:!DH:!EDH:!EXP:+MEDIUMSSLHonorCipherOrder on# 证书公钥配置SSLCertificateFile cert/a_public.crt# 证书私钥配置SSLCertificateKeyFile cert/a.key# 证书链配置，如果该属性开头有 '#'字符，请删除掉SSLCertificateChainFile cert/a_chain.crt 重启 Apache。 12apachectl -k stopapachectl -k start Nginx/Tengine服务器安装SSL证书2018年11月30日 00:17:13 在证书控制台(可以在阿里云控制台购买或者获取免费的)下载Nginx版本证书。下载到本地的压缩文件包解压后包含： .crt文件：是证书文件，crt是pem文件的扩展名。.key文件：证书的私钥文件（申请证书时如果没有选择自动创建CSR，则没有该文件）。友情提示： .pem扩展名的证书文件采用Base64-encoded的PEM格式文本文件，可根据需要修改扩展名。 以Nginx标准配置为例，假如证书文件名是a.pem，私钥文件是a.key。 在Nginx的安装目录下创建cert目录，并且将下载的全部文件拷贝到cert目录中。如果申请证书时是自己创建的CSR文件，请将对应的私钥文件放到cert目录下并且命名为a.key； 打开 Nginx 安装目录下 conf 目录中的 nginx.conf 文件，找到： 12345678910111213141516# HTTPS server# #server &#123;# listen 443;# server_name localhost;# ssl on;# ssl_certificate cert.pem;# ssl_certificate_key cert.key;# ssl_session_timeout 5m;# ssl_protocols SSLv2 SSLv3 TLSv1;# ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;# ssl_prefer_server_ciphers on;# location / &#123;###&#125;#&#125; 将其修改为 (以下属性中ssl开头的属性与证书配置有直接关系，其它属性请结合自己的实际情况复制或调整) : 1234567891011121314151617server &#123; listen 443; server_name localhost; ssl on; root html; index index.html index.htm; ssl_certificate cert/a.pem; ssl_certificate_key cert/a.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; root html; index index.html index.htm; &#125;&#125; 保存退出。 重启 Nginx。 Tomcat服务器安装SSL证书在证书控制台下载Tomcat版本证书，下载到本地的是一个压缩文件，解压后里面包含.pfx文件是证书文件，pfx_password.txt是证书文件的密码。友情提示： 每次下载都会产生新密码，该密码仅匹配本次下载的证书。如果需要更新证书文件，同时也要更新密码。申请证书时如果没有选择系统创建CSR，则没有该文件，请选择其它服务器下载.crt文件，利用openssl命令自己生成pfx证书。 PFX证书安装以Tomcat7标准配置为例，假如证书文件名是a.pfx。找到安装Tomcat目录下该文件server.xml,一般默认路径都是在 conf 文件夹中。找到 &lt;Connection port=”8443”标签，增加如下属性：1234567891011121314151617keystoreFile=\"cert/200613478180598.pfx\"keystoreType=\"PKCS12\"#此处的证书密码，请参考附件中的密码文件或在第1步中设置的密码keystorePass=\"证书密码\"完整的配置如下，其中port属性根据实际情况修改：&lt;Connector port=\"8443\" protocol=\"HTTP/1.1\" SSLEnabled=\"true\" scheme=\"https\" secure=\"true\" keystoreFile=\"cert/a.pfx\" keystoreType=\"PKCS12\" keystorePass=\"证书密码\" clientAuth=\"false\" SSLProtocol=\"TLSv1+TLSv1.1+TLSv1.2\" ciphers=\"TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA256\"/&gt; 注意：不同的版本Tomcat，需要替换的属性字段不一定相同，所以只需要给预定的属性赋值即可 JKS证书安装( 1 ) 使用java jdk将PFX格式证书转换为JKS格式证书(windows环境注意在%JAVA_HOME%/jdk/bin目录下执行)1keytool -importkeystore -srckeystore amanda.pfx -destkeystore amanda.jks -srcstoretype PKCS12 -deststoretype JKS 回车后输入JKS证书密码和PFX证书密码，强烈推荐将JKS密码与PFX证书密码相同，否则可能会导致Tomcat启动失败。 ( 2 ) 找到安装 Tomcat 目录下该文件Server.xml，一般默认路径都是在 conf 文件夹中。找到 &lt;Connection port=”8443”标签，增加如下属性：1234567891011121314keystoreFile=\"cert/a.jks\"keystorePass=\"证书密码\"完整的配置如下，其中port属性根据实际情况修改：&lt;Connector port=\"8443\" protocol=\"HTTP/1.1\" SSLEnabled=\"true\" scheme=\"https\" secure=\"true\" keystoreFile=\"cert/a.jks\" keystorePass=\"证书密码\" clientAuth=\"false\" SSLProtocol=\"TLSv1+TLSv1.1+TLSv1.2\" ciphers=\"TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA256\"/&gt;( 注意:不要直接拷贝所有配置，只需添加 keystoreFile,keystorePass等参数即可，其它参数请根据自己的实际情况修改 ) 重启 Tomcat。","categories":[],"tags":[{"name":"ssl","slug":"ssl","permalink":"http://yoursite.com/tags/ssl/"}],"keywords":[]},{"title":"markdown 基本语法","slug":"markdown基本语法","date":"2019-09-10T00:28:34.887Z","updated":"2019-03-10T04:33:03.906Z","comments":true,"path":"2019/09/09/markdown基本语法/","link":"","permalink":"http://yoursite.com/2019/09/09/markdown基本语法/","excerpt":"前端基本上都用上了前端构建工具，那就难免要写一些readme等等的说明性文件，但是这样的文件一般都是.md的文件，编写的语法自然跟其他格式的文件有所区别，置于为什么要用这种格式的文件，不要问我，我也不知道","text":"前端基本上都用上了前端构建工具，那就难免要写一些readme等等的说明性文件，但是这样的文件一般都是.md的文件，编写的语法自然跟其他格式的文件有所区别，置于为什么要用这种格式的文件，不要问我，我也不知道 标题一级标题二级标题三级标题四级标题五级标题六级标题。。。 列表无序列表： 星号 + 空格 加号 + 空格 减号 + 空格 有序列表： 数字 + 英文的点 + 空格 注意，数字后面的点只能是英文的点 序列表的序号是根据第一行列表的数字顺序来的 区块引用 不以结婚为目的的谈恋爱都叫耍流氓 这是毛主席说的 华丽的分各线 链接 行内式：链接的文字放在[]中，链接地址放在随后的（）中语法：1[妙语连珠](http://www.baidu.com) 妙语连珠 妙语连珠 参数式 图片语法：1![我是图片](https://github.com/zwwill/yanxuan-weex-demo/raw/master/banner.png) 代码框如果代码量比较少，只有单行的话，可以用单反引号包起来多行用三个反引号，如果要写注释，可以在反引号后面写 表格语法：1234学号|姓名|分数 -|-|- 小明|男|25 小红|女|20 学号 姓名 分数 小明 男 25 小红 女 20 强调重要指示 转义 \\ \\’ 删除线请删掉我吧","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}],"keywords":[]},{"title":"jquery插件系列之轮播图","slug":"基于jquery二次开发轮播图插件","date":"2019-09-10T00:28:34.875Z","updated":"2019-03-10T04:02:43.938Z","comments":true,"path":"2019/09/09/基于jquery二次开发轮播图插件/","link":"","permalink":"http://yoursite.com/2019/09/09/基于jquery二次开发轮播图插件/","excerpt":"基于js函数库（jquery）开发轮播图插件","text":"基于js函数库（jquery）开发轮播图插件 如果你熟悉以下基本知识，阅读起来可能会更好 有一定的前端开发基础（熟悉html、css、js） 有基于jquery再次开发插件的经验项目目录结构12345678910/ # 项目根目录 （本实例是 slider-by-jquery)---lib------jquery.js # jquery-v3.3.1 库---js------slider.js # 轮播图构造器---css------slider.css # 主要样式----images------... # 轮播图片资源---index.html # 项目入口文件 实例代码（index.html）12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;jQuery轮播图插件&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"./css/slider.css\"&gt;&lt;/head&gt; &lt;body&gt; &lt;div id=\"slider\" style=\"margin:50px auto\"&gt;&lt;/div&gt; &lt;script src=\"./lib/jquery.js\"&gt;&lt;/script&gt; &lt;script src=\"./js/slider.js\"&gt;&lt;/script&gt; &lt;script&gt; var images = new Array(15); // 轮播图片容器 var path = './images/'; var imgType = '.jpg'; for (var i = 0; i &lt; images.length; i++) &#123; images[i] = path + (i + 1) + imgType; &#125; $('#slider').sliderImg(images); &lt;/script&gt;&lt;/body&gt; &lt;/html&gt;","categories":[],"tags":[{"name":"javascript, jquery","slug":"javascript-jquery","permalink":"http://yoursite.com/tags/javascript-jquery/"}],"keywords":[]},{"title":"vue 在weex 中的不同","slug":"vue 在 weex 中的不同","date":"2019-09-10T00:28:34.871Z","updated":"2019-03-10T03:07:03.324Z","comments":true,"path":"2019/09/09/vue 在 weex 中的不同/","link":"","permalink":"http://yoursite.com/2019/09/09/vue 在 weex 中的不同/","excerpt":"vue在weex中的不同","text":"vue在weex中的不同 语法差异 1、“html标签”目前Weex支持了基本容器（div）、文本（text）、图片（image）、视频（video）等组件，注意是组件，不是标签，虽然使用起来和html标签很像，至于其他标签基本可以使用以上组件组合而成。 2、 Weex环境中没有DOM因为Wexx解析vue 得到的并不是dom,而是原生布局树。 3、支持有限的事件并不支持 Web 中所有的事件类型，详情请参考《通用事件》 4、没有BOM 但可以调用原生API在 Weex 中能够调用移动设备原生 API，使用方法是通过注册、调用模块来实现。其中有一些模块是 Weex 内置的，如 clipboard 、 navigator 、storage 等。《clipboard 剪切板》《navigator 导航控制》《storage 本地存储 》 为了保持框架的通用性，Weex 内置的原生模块有限，不过 Weex 提供了横向扩展的能力，可以扩展原生模块，具体的扩展方法请参考《iOS 扩展》 和《Android 扩展》。 样式差异 Weex 中的样式是由原生渲染器解析的，出于性能和复杂度的考虑，Weex对css的特性做了一些取舍 1、Weex 中只支持单个类名选择器，不支持关系选择器，也不支持属性选择器。 2、组件级别的作用域，为了保持web和native的一致性，需要&lt;style scoped&gt; 写法。 3、支持了基本的盒模型和flexbox布局，详情可参考Weex通用样式文档，但是需要注意的是： 不支持display：none；可用opacity：0；（opacity &lt;= 0.01时，元素可点透） 样式属性暂不支持简写（提高解析效率） flex布局需要web的兼容性 css 不支持3D变换 Vue 语法 举个例子，以下是严选App Demo 首页的简化代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;text class=\"iconfont\"&gt;&lt;/text&gt; &lt;home-header&gt;&lt;/home-header&gt; &lt;scroller class=\"main-list\" offset-accuracy=\"300px\"&gt; &lt;refresher&gt;&lt;/refresher&gt; &lt;div class=\"cell-button\" @click=\"jumpWeb('https://m.you.163.com')\"&gt; &lt;yx-slider :imageList=\"YXBanners\" &gt;&lt;/yx-slider&gt; &lt;/div&gt; &lt;div class=\"cell-button\"&gt; &lt;block-1 :title=\"block1.title\" :items=\"block1.items\"&gt;&lt;/block-1&gt; &lt;/div&gt; &lt;/scroller&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .iconfont &#123; font-family:iconfont; &#125; .main-list&#123; position: fixed; top: 168px; bottom: 90px; left: 0; right: 0; &#125;&lt;/style&gt;&lt;script&gt; var navigator = weex.requireModule('navigator'); import util from '../../src/assets/util'; import Header from '../components/Header.vue'; import refresher from '../components/refresh.vue'; import YXSlider from '../components/YXSlider.vue'; import Block1 from '../components/Block1.vue'; export default &#123; components: &#123; 'home-header': Header, 'refresher': refresher, 'yx-slider': YXSlider, 'block-1': Block1 &#125;, data () &#123; return &#123; YXBanners: [ &#123; title: '', src: 'http://doc.zwwill.com/yanxuan/imgs/banner-1.jpg'&#125;, &#123; title: '', src: 'http://doc.zwwill.com/yanxuan/imgs/banner-2.jpg'&#125;, &#123; title: '', src: 'http://doc.zwwill.com/yanxuan/imgs/banner-3.jpg'&#125; ] &#125; &#125;, methods: &#123; jumpWeb (_url) &#123; const url = this.$getConfig().bundleUrl; navigator.push(&#123; url: util.setBundleUrl(url, 'page/web.js?weburl='+_url) , animated: \"true\" &#125;); &#125; &#125; &#125;&lt;/script&gt; Weex 工程中常用的标签有&lt;div /&gt;，&lt;text /&gt;，&lt;image /&gt;，&lt;video /&gt;（组件另算），由此四种标签基本可以满足绝大多数场景的需求，虽说此标签同 web 工程下的标签用法一致，但此处的标签已不再是我们前端口中常提的 html 标签，而且名存实亡的 Weex 标签，确切讲是 Weex 组件。 通过weex-loader、vue-loader、weex-vue-render的解析最终转换输出的便是实际的组件，有此设计只是为了完成「web开发体验」的目标。但是我们身为上层的开发人员要清楚自己每天「把玩」的到底是个什么「鬼」。 阉割版css 其实用阉割版来形容 Weex 的 css 支持度并不合适，但如果从「web开发体验」的角度来衡量，那么这个形容词也是可以理解的。（此处对 Weex 寄有厚望^_^） 单位 Weex 中的所有 css 属性值的单位均为 px，也可省略不写，系统会默认为 px 单位。 选择器 Weex 中只支持单个类名选择器，不支持关系选择器，也不支持属性选择器。123456789101112/* 支持单个类名选择器 */.one-class &#123; font-size: 36px;&#125;/* 不支持关系选择器 */.parent &gt; .child &#123; padding-top: 10px;&#125;/* 不支持属性选择器，不支持 `v-cloak` 指令 */[v-cloak] &#123; color: #FF6600;&#125; 这个只是对样式定义的限制，不影响样式类名的使用，在标签中可以添加多个样式类名，如：123&lt;template&gt; &lt;div class=\"one two three\"&gt;&lt;div&gt;&lt;/template&gt; 盒模型 weex支持css基本的盒模型结构，但需要注意的是 box-sizing 属性的默认值为 border-box margin、padding、border 等属性暂时不支持合并简写 FlexBox Weex 中对 flexbox 布局支持度很高，但依然有部分属性并不支持，如 align-items:baseline;、align-content:space-around;、align-self:wrap_reverse;等。 具体 Weex 对 flexbox 的支持和布局算法，可通过此文进行了解由 FlexBox 算法强力驱动的 Weex 布局引擎，此处便不再赘述。 显隐性 在 Weex 的 ios 和 android 端，并不支持 display 属性。因此，不能使用 display:none; 来控制元素的显隐性，所以 vue 语法中的 v-show 条件渲染是不生效的。我们可以使用 v-if 代替，或者用 opacity:0; 来模拟。需要注意的是，ios和android端并不能使用 opacity:0; 来完全模拟 visibility: hidden;，因为，当opacity 的只小于等于 0.01 时，native 控件便会消失，占位空间还在，但用户无法进行交互操作，点击时会发生点透效果。 css3 Weex 支持 css3 属性，虽然支持并不够，但相较 React Native 的「不能用」已经是强大很多了。以下几种属性我们在开发前需要知道她的支持度 transform: 目前只支持2D转换 transition: v0.16.0+的sdk版本支持css过度动画，可根据情况配合内组件animation 实现动画交互 linear-gradient:目前只支持双色变色 font-family: Weex 目前只支持tff和woff字体格式的自定义字体 第三方工具库 由于使用了增强版的 webpak 打包工具 weexpack，支持第三方框架也是件自然而然的事情。常用的有 vuex、vue-router 等，可根据项目实际情况引入需要的第三方工具库 npm 包管理 npm 包管理是前端开发朋友们再熟悉不过的包管理方式了。这也是为什么 React Native 和 Weex 都选择这种管理方式的原因。以下是本工程的 package.json 文件，这里就不做讲解了，不熟悉的朋友点这里-&gt;NPM 使用介绍1234567891011121314151617181920212223242526272829303132333435363738394041&#123; \"name\": \"yanxuan-weex\", \"version\": \"1.0.0\", \"description\": \"a weex project\", \"main\": \"index.js\", \"scripts\": &#123; \"build\": \"webpack\", \"build_plugin\": \"webpack --config ./tools/webpack.config.plugin.js --color\", \"dev\": \"weex-builder src dist -w\", \"serve\": \"webpack-dev-server --config webpack.dev.js -p --open\" &#125;, \"keywords\": [\"weex\"], \"author\": \"zwwill\", \"license\": \"MIT\", \"dependencies\": &#123; \"vue\": \"^2.4.2\", \"vue-router\": \"^2.7.0\", \"vuex\": \"^2.1.1\", \"vuex-router-sync\": \"^4.3.0\", \"weex-html5\": \"^0.4.1\", \"weex-vue-render\": \"^0.11.2\" &#125;, \"devDependencies\": &#123; \"babel-core\": \"^6.21.0\", \"babel-loader\": \"^6.2.4\", \"babel-plugin-add-module-exports\": \"^0.2.1\", \"babel-plugin-transform-runtime\": \"^6.9.0\", \"babel-preset-es2015\": \"^6.9.0\", \"babel-runtime\": \"^6.9.2\", \"css-loader\": \"^0.26.1\", \"history\": \"^4.7.2\", \"quick-local-ip\": \"^1.0.7\", \"vue-loader\": \"^13.0.4\", \"vue-template-compiler\": \"^2.4.2\", \"webpack\": \"^2.7.0\", \"webpack-dev-server\": \"^2.4.2\", \"weex-builder\": \"^0.2.7\", \"weex-loader\": \"^0.4.5\", \"weex-router\": \"0.0.1\" &#125;&#125; UI尺寸适配 Weex 容器默认的显示宽度 (viewport) 是 750px，页面中的所有组件都会以 750px 作为满屏宽度。这很像移动设备的逻辑像，比如 iPhone 6 的物理像素宽为 750，逻辑像素","categories":[],"tags":[{"name":"weex","slug":"weex","permalink":"http://yoursite.com/tags/weex/"}],"keywords":[]},{"title":"App常用开发模式【简介】","slug":"几种常见APP的开发模式","date":"2019-09-10T00:28:34.863Z","updated":"2019-03-08T01:25:58.675Z","comments":true,"path":"2019/09/09/几种常见APP的开发模式/","link":"","permalink":"http://yoursite.com/2019/09/09/几种常见APP的开发模式/","excerpt":"App常用开发模式【简介】","text":"App常用开发模式【简介】 1.ReactNativeFacebook发现Hybrid App存在很多缺陷和不足，于是发起开源的一套新的App开发方案RN。使用JSX语言写原生界面，js通过JSBridge调用原生API渲染UI交互通信。 优点：效率体验接近Native App，发布和开发成本低于Native App 缺点：学习有一定成本，且文档较少，免不了踩坑 举个栗子：Facebook、Youtube、Discord、QQ、百度等等 与传统跨平台开发不同，它的目标不是一次编写到处执行，而是一次学习多处开发（一次学习跨平台开发）不同平台上编写基于React的代码 其中，Android版本代码和iOS版本代码是有差别的，但是由于都是js驱动的开发，相同语法的，所以会编写iOS的同时也会编写Android。 相比传统跨平台大大提高了性能-既拥有Native的用户体验，又保留React的开打效率。 原理仍然是依赖原生暴露的借口-通过JSBridge技术，所以仍然会存在原生代码。 ReactJs和React Native 的原理是相同的，都是由js实现的虚拟dom 来驱动界面view层渲染。只不过ReactJs驱动html dom 渲染；React Native 是驱动Android/ios原生组件渲染。其实在React Native 推出之前，就已经存在这种使用js 驱动app原生组件的技术了，比如Native Script。 2. Weex 阿里巴巴开发团队在RN的成功案例上，重新设计出的一套开发模式，站在了巨人肩膀上并有淘宝团队项目做养料，广受关注，2016年4月正式开源，并在v2.0版本官方支持Vue.js，与RN分庭抗礼。 优点：单页开发模式效率极高，热更新发包体积小，并且跨平台性更强 缺点：刚刚起步，文档欠缺；社区没有RN活跃，功能尚不健全，暂不适合完全使用Weex开发App 举个栗子：淘宝、天猫、阿里云、优酷、闲鱼、饿了么等 weex 最底层的原理是和React-Native相同的，就是将JS代码渲染成原生组件 只不过在业务代码层面，Weex和React-Naive 有差别： 最新版Weex是基于Vue的语法，然后写出来的就是一些特定的H5语法，然后底层引擎再分贝根据web和原生，分别将代码解析成html dom 或者原生组件，所以感觉起来跟写web插件一样。 而React-Native 则是直接通过JS写原代码，所以对外表现层上，weex只要遵循一定规则就可以一套代码完全跨平台，React-Native 则针对不同平台写不同的代码，虽然大部分代码可以复用 维护层面上，Weex主要由阿里人员维护，社区方面目前还有点不足，而Reac-Native 目前社区已经比较成熟，期待未来两者各自的发展。` 3.Native APPNative App是一种基于智能手机本地操作系统如iOS、Android、WP并使用原生程式编写运行的第三方应用程序,也叫本地app。一般使用的开发语言为Java、C++、Objective-C。 优点：性能和体验都是最好的 缺点：开发和发布成本高 举个栗子：网易管家App （Tab1，Tab2） 应用技术：Swift，OC，Java 4.Web App移动端的网站，常被称为H5应用，说白了就是特定运行在移动端浏览器上的网站应用。一般泛指 SPA(Single Page Application)模式开发出的网站，与MPA（Multi-page Application）对应。 优点：开发和发布成本最低 缺点：性能和体验不能讲是最差的，但也受到浏览器处理能力的限制，多次下载同 样会占用用户一定的流量 举个栗子：网易管家APP（Tab3） 应用技术：ReactJS，RegularJS，VueJS等等 Hybrid App混合模式移动应用，介于Web App、Native App这两者之间的App开发技术，兼具“Native App良好交互体验的优势”和“Web App跨平台开发的优势”（百度百科解释）主要的原理是，由Native通过JSBridge等方法提供统一的API，然后用Html+Css实现界面，JS来写逻辑，调用API，最终的页面在Webview中显示，这种模式下，Android、iOS的API一般有一致性，Hybrid App所以有跨平台效果。 优点：开发和发布都比较方便，效率介于Native App、Web App之间 缺点：学习范围较广，需要原生配合 举个栗子：FanReact，我爱我家App，东方航空App，富国基金-富国钱包App 应用技术：PhoneGap，AppCan，Wex5，APICloud等","categories":[],"tags":[{"name":"weex","slug":"weex","permalink":"http://yoursite.com/tags/weex/"}],"keywords":[]},{"title":"java基础语法","slug":"java基础语法","date":"2019-09-10T00:28:34.847Z","updated":"2019-04-15T11:35:40.036Z","comments":true,"path":"2019/09/09/java基础语法/","link":"","permalink":"http://yoursite.com/2019/09/09/java基础语法/","excerpt":"java基础语法","text":"java基础语法 Java中的数据类型（Java 语言是一种强类型语言。通俗点说就是，在 Java 中存储的数据都是有类型的，而且必须在编译时就确定其类型） 基本类型：byte、int、long、short、float、double、char、boolean 引用类型：class、interface、array123456789101112131415public class DataTyepe &#123; public static void main(String[] args) &#123; String name=\"爱慕课\"; char sex='男'; int num=18; double price=120.5; Boolean isOK=true; System.out.println(name); System.out.println(sex); System.out.println(num); System.out.println(price); System.out.println(isOK); &#125;&#125;// 注：String 和 char有区别，float和double有区别","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}],"keywords":[]},{"title":"当面试官问你如何进行性能优化时，你该怎么回答？","slug":"网站性能优化","date":"2019-09-10T00:28:34.831Z","updated":"2019-03-08T01:28:10.947Z","comments":true,"path":"2019/09/09/网站性能优化/","link":"","permalink":"http://yoursite.com/2019/09/09/网站性能优化/","excerpt":"当面试官问你如何进行性能优化时，你该怎么回答？","text":"当面试官问你如何进行性能优化时，你该怎么回答？ 背景 当你这样说的时候：压缩代码、打包代码、雪碧图、cdn、事件代理、 说明你对网站性能优化缺少一个整体的认识 性能优化是什么 从前端的角度，分页面加载时间 和 页面运行效率 从浏览器打开到页面渲染完成，花费了多少时间主要的过程是：12345浏览器解析 -&gt; 查询缓存 -&gt; dns查询 -&gt; 建立链接 -&gt; 服务器请求处理 -&gt; 服务器发送响应 -&gt; 客户端收到页面 -&gt;解析html -&gt; 构建渲染树 -&gt; 开始显示内容（白屏时间）-&gt; 首屏加载完成（首屏时间）-&gt; 用户可交互（DOMContentLoaded）-&gt;加载完成（load） 页面加载时间监控推荐 PerformanceTiming 可以获取页面加载的数据： 12345dns解析时间: domainLookEnd - domainLookStartTCP建立链接时间： connectEnd - connectStart白屏时间： responsStart - navigationStartdom渲染完成时间: domContentLoadEnentEnd - navigationStart页面onload时间： loadEventEnd - navigationStart 服务器部分优化要点后端可以对缓存、dns查询时间，链接时间，处理请求时间，响应时间等进行优化 前端部分优化要点前端可以对白屏时间，首屏时间，可交换时间，加载完成时间进行优化","categories":[],"tags":[{"name":"build_webApp","slug":"build-webApp","permalink":"http://yoursite.com/tags/build-webApp/"}],"keywords":[]},{"title":"程序媛(转)","slug":"女程序员的正能量","date":"2019-09-10T00:28:34.819Z","updated":"2019-03-13T06:49:07.718Z","comments":true,"path":"2019/09/09/女程序员的正能量/","link":"","permalink":"http://yoursite.com/2019/09/09/女程序员的正能量/","excerpt":"推荐国内最好的在线翻译平台 众成翻译","text":"推荐国内最好的在线翻译平台 众成翻译 【译】女程序员的正能量 推荐国内最好的在线翻译平台 众成翻译 原文链接：http://lea.verou.me/2015/12/my-positive-experience-as-a-woman-in-tech/ 虽说身为女性吐槽在技术圈里遇到的性别歧视之类话题能吸引更多的关注度，但是，如果没有人写点正能量的故事，过分消极的画风就会让越来越多的女性远离技术工作。 程序媛 如果我一开始就被人告知技术领域存在性别歧视，那我很可能会选择别的职业，毕竟我们不可能以一己之力打败成见。而对我来说幸运的是，在我从事喜爱的编程工作很长一段时间里，从来没有听说过性别歧视这回事儿。 我的事业至今为止带给我的只有快乐。的确，有的女性经历了许多不愉快的事，我们没法忽视这些问题，甚至遭受性别歧视有可能才是这个行业里面的大多数女性的真实现状。但是，正如任何问题都有两面性，也有许多像我一样的女性有着非常正能量的职业经历，我们总是被尊重而非歧视。这一面的积极的故事也应该被讲述出来，我们不能由于害怕被其他女性同胞认为我们自满、不努力争取更多的平等，结果刻意隐瞒这些经历。 我在生活中扮演着不同的角色。我是一名学生，一名演讲者，一位作家。我曾经在W3C工作，我开展和维护过许多成功的开源项目，而我现在在麻省理工从事计算机科学的研究。在这些不同的领域中，我从来没有由于我的性别而遭遇到不公平对待。这不是由于我对性别歧视不敏感，相反，我经常注意到一些非常细微的歧视行为1。我看到了很多社会中的性别歧视现象。然而，在我从事的行业里，我的性别从来不是什么问题，甚至反而能给我带来好处。 在我的开源代码仓库中，有许多程序员为我的项目贡献了代码，他们绝大多数都是男性。这些人从来没有因为我的性别而不那么尊敬我。我也从来没有觉得我的工作与男程序员相比被不那么认真对待。我的合作代码贡献者们不会因为我是女性而忽视我的意见，也不会因为我是女性，就不公平地吐槽我的代码。即使当我对某些技术不了解或者写了一个严重的bug的时候，我也从来不会被侮辱或责骂。社区对我是友好的，给了我足够的帮助和尊重。有时候我甚至觉得，正因为大家知道我是女性，所以反而更友好地对待我。 作为演讲者在讲台上，我没有得到过任何负面的反应。我的观点总是得到积极的反馈，不会因为我是女性而有什么问题。虽然偶尔我会收到一些关于我的颜值的奇怪的赞美，但这种事情也少有发生，即使有，也总是夹在具体话题内容的讨论中2。我从心里认为，作为女性演讲者的我必须要优秀，因为我不想让听众觉得女性讲师的能力不如男性讲师，但这并不是由于其他人观点影响而是我自己内心的选择。 我写的书，CSS Secrets3作为一本高级CSS教程获得了成功，在亚马逊平台上才几个月时间就已经获得了平均5颗星的综合评价。这本书在CSS类教程的畅销排行榜上稳列前五，在新书榜上也已经冲到了第一名的位置。我的性别并没有给我的书销售带来任何不利的影响(虽然我的名字Lea听起来比较中性，但书中有我的照片，所以读者不会不知道我是女性)。 作为学生，我从来没有感觉到任何一位教授歧视我的性别，即使我身在希腊——说得委婉一点——不那么重视性别平等的国家。 作为一名新手研究员，我对发论文还没有什么经验，所以我现在还没法分享这方面的心得。尽管如此，我依然收获到我的导师和同事们满满的尊重。虽然我的观点有时候大家不认同，但还是得到了认真对待和充分评估，我可以辩论和表达我的观点，这不会被视为强势和不理智。 我曾在W3C工作过，现在依然以CSS工作组的特邀专家身份参与其中。在这些角色里，我的女性身份似乎并没有任何问题。我一直觉得我的工作经验和技能被公平对待，我的观点被重视。事实上CSS工作组另一位最受尊重的成员也是女性：fantasai。 最后，以我在职业生涯中的多年经验，我总是可以谈妥任何我期望的报酬，尽管有时候有点难4，但我从来没有因为女性身份带来负面影响而错失过任何一次机会。 当今社会很少有公开的性别歧视，因为几乎没有超过10岁的人会公开承认他们认为女性不如男性。因此很难区分究竟哪些社会行为受到性别歧视影响。如果有人对你使坏，究竟是因为他们歧视女性还是因为他们本来就是人渣？如果有人批评你的工作，究竟是因为歧视你是女性还是因为真的有批评你的理由？有时候我们很难有最终结论，甚至那些对你不好的人自己也不知道。如果你质疑他们对你性别歧视，他们会全盘否认自己存在性别歧视行为，但其实在他们心里是真正存在着对女性的偏见。子曰，见贤思齐焉，见不贤而内自省。不要轻易下结论说你遇到了性别歧视，因为没有办法下定论，甚至连始作俑者自己都未必清楚内心是否有真的歧视女性，太多的似是而非。 也许，我不觉得我有遇到很多性别歧视是因为我宁愿相信那些对我不利的人本心并不是因为歧视我的性别。可能是受 Blackstone Formulation 5影响，我宁可忽视十次可能的性别歧视，也不愿意错误地将一次受到的不公平对待归为性别歧视问题。这可能是源于我的个性：我对自己无比自信，所以内心强大，以直抱怨，以德报德，没人能欺负我。然而我的大度和自信并不能让我忽略掉性别歧视和所期望的平等社会之间的巨大差距，所以我们应当为更多女性感受到正能量而喝彩（我不应该成为个例，对吗？）。 具有讽刺意味的是，在我职业生涯中偶遇的性别歧视，对方实际上将他的歧视行为视为对我好6。某一次我在拉斯维加斯的会议室里专注于我的slides，没有参与周围的任何谈话。突然，有个家伙在旁边爆了一句粗口fuck，然后转向我给我道歉。当时，我抬起头，环顾四周，有点小尴尬。我才意识到我是房间里唯一的女人，而那个人努力地让我觉得我与众不同，作为女人我被他像玻璃花一样“小心轻放”。抱歉，我当时的反应是脱口而出——我才不给你fuck ╮(╯▽╰)╭","categories":[],"tags":[{"name":"时间寄语","slug":"时间寄语","permalink":"http://yoursite.com/tags/时间寄语/"}],"keywords":[]},{"title":"前端开发者如何设置数据库","slug":"前端开发者如何配置数据库","date":"2019-09-10T00:28:34.807Z","updated":"2019-03-08T01:26:33.498Z","comments":true,"path":"2019/09/09/前端开发者如何配置数据库/","link":"","permalink":"http://yoursite.com/2019/09/09/前端开发者如何配置数据库/","excerpt":"前端开发者如何设置数据库MongoDB","text":"前端开发者如何设置数据库MongoDB 一、配置数据库1.通过mlab获取一个免费的数据库 2.注册后，在MongoDB的部属表中点击新建（我们用的就是这个免费的沙盒数 3.创建一个账户，点击数据库名称,然后点击数据库名称,然后点击用户，并添加数据库用户，写下之后要用到的用户名和密码 4.获取数据路的URL(在数据库页面的顶部，你能够看到一个 MongoDB URI),这个数据库的URL相当于网址。 通常情况下，MongoDB的URL如下：123mongodb://&lt;dbuser&gt;:&lt;dbpassword&gt;@&lt;host&gt;:&lt;port&gt;/&lt;dbname&gt;// 例如mongodb://admin:superSecretPassword@ds111885.mlab.com:11885/medium 二、设置服务器后端使用node从server.js 开始 123456789// init projectconst express = require('express');// the library we will use to handle requestsconst app = express(); // instantiate expressapp.use(require('cors')()); // allow Cross-domain requests// base routeapp.post('/:user', function(request, response)&#123; response.send(request.params.user);&#125;); 现在服务器可以响应每一个查询并显示查询的用户名 三、向数据库增加数据我们知道 user 是谁了，现在我们想存储一些关于他的信息。为了查询数据库，我们会使用 mongodb 库。你可以用以下两个方法安装： 1npm install mongodb –save 或者如果你使用 Glitch ，你可以切换到 package.json 文件并点击 Add package 按钮。我们加载 mongodb 库然后存储 MongoDB URI 到一个变量中: 12const mongodb = require('mongodb'); // load mongodbconst url = process.env.URL URI 是很敏感的信息——这是访问数据库所需的一切。最好把 URI 放到一个 .env 文件中，.env 文件中的信息对于其他人是不可见的。URI=mongodb://admin:PASSWORD@ds111885.mlab.com:11885/mediumGlitch 会自动从 .env 文件中加载变量到 process.env 变量。数据库的连接是异步的操作，所以我们需要像这样在回调中包装所有服务器设置： 1234567891011121314151617181920mongodb.MongoClient.connect(url, function(err, db)&#123; // create a db table of 'users' const collection = db.collection('users') // base route app.get('/:user', function (request, response) &#123; // handle db // insert collection.insertOne(&#123;...request.body, user : request.params.user &#125;, function(err) &#123; if (err)&#123; response.send(“An error occured”) &#125; else &#123; response.send(“All well”) &#125; &#125;); // listen for requests, the process.env.PORT is needed because // we are using glitch, otherwise you could have written 80 or whatever var listener = app.listen(process.env.PORT, function () &#123; console.log(‘Your app is listening on port ‘ + listener.address().port); &#125;);&#125;);","categories":[],"tags":[{"name":"MongoDB node","slug":"MongoDB-node","permalink":"http://yoursite.com/tags/MongoDB-node/"}],"keywords":[]},{"title":"利用css 函数calc()计算高度","slug":"利用css 函数calc()计算高度","date":"2019-09-10T00:28:34.791Z","updated":"2019-03-08T01:26:13.626Z","comments":true,"path":"2019/09/09/利用css 函数calc()计算高度/","link":"","permalink":"http://yoursite.com/2019/09/09/利用css 函数calc()计算高度/","excerpt":"利用css 函数calc()计算高度","text":"利用css 函数calc()计算高度 说明calc是英文单词calculate(计算)的缩写，是css3的一个新增的功能，你可以使用calc()给元素的border、margin、padding、font-size和width等属性设置动态值。calc()可以使用数学运算中的简单加（+）、减（-）、乘（*）和除（/）来解决问题，而且还可以根据单位如px,em,rem和百分比来转化计算。 语法：1calc() = calc(四则运算) 用于动态计算长度值注意：运算符需要保留一个空格，例如：width: calc(100% \b\b– 10px\b);任何长度都可以使用calc()函数进行计算 例子：比如三局平均分布的布局，中间间距为5像素。 12345678910*&#123;margin: 0; padding: 0;&#125;.col-3&#123; width: calc(100%/3 - 5px); float: left; background: #eee; height: 100px; margin-bottom: calc(5px*3 /2); font-size: 18px; &#125;.col-3:nth-child(3)&#123;margin-right: 0;&#125;","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}],"keywords":[]},{"title":"call、apply、 bind","slug":"写给新人的call、apply、bind","date":"2019-09-10T00:28:34.779Z","updated":"2019-03-08T01:25:39.007Z","comments":true,"path":"2019/09/09/写给新人的call、apply、bind/","link":"","permalink":"http://yoursite.com/2019/09/09/写给新人的call、apply、bind/","excerpt":"windowOS安装mysql5+ 解压缩版之教程","text":"windowOS安装mysql5+ 解压缩版之教程 call()语法： 1fun.call(thisArg[,args1[,args[,...]]]) thisArg: fun函数运行时指定的this值，可能的值为： 不传，或者传null、undefined、this指向window对象 传递另一个函数的函数名fun2,this指向fun2的引用 值为原始值（数字、字符串、布尔值），this会指向该原始值的自动包装对象，如String、Number、Boolean 传递一个对象，函数中的this指向这个对象例如： 12345function a () &#123; console.log(this);&#125;function b()&#123;&#125;a.call(b); // function b()&#123;&#125; 经常会看到这种使用情况： 1234function list() &#123; return Array.prototype.slice.call(argusments)&#125;list(1,2,3); // [1,2,3] 为什么会实现这样的功能将argument转成数组？首先，call了之后，this指向了所传进去的arguments,我们可以假设slice方法的内部是这样子的：创建一新数组，然后for循环遍历this,将this[i]一个个的赋值给新数组，最后返回该数组。因此也就可以理解能实现这样的功能了。 apply()语法： 123// Chrome 14 以及 Internet Explorer 9 仍然不接受类数组对象。// thisArg的可能值和call一样fun.apply(thisArg[, argsArray]) 例如：123var numbers = [5,6,2,3,7];var max = Math.max.apply(null, numbers);console.log(max); // 7 平时Math.max 只能这样子用：Math.max(5,6,2,3,7);利用apply的第二个参数是数组的特性，从而能够简便的从数组中找到最大值 bind语法： 1fun.bind(thisArg[,args1[,...]]) bind()方法会创建一个新函数,称为绑定函数bind是ES5新增的一个方法，不会执行对应的函数（call或apply会自执行对应的函数），而是返回对绑定函数的引用 当调用这个绑定函数时，thisArgs参数作为this,第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。简单地说，bind会产生一个新的函数，这个函数可以有预设的参数。 123456function list()&#123; return Array.prototype.slice.call(arguments);&#125;var lendingThirtysevenList = list.bind(undefined, 37);var list = lendingThirtysevenList (1,2,3);console.log(list); // [37,1,2,3] bind调用简单 把类数组换成真正的数组，bind能够更简单地使用： apply用法 12var slice = Array.prototype.slice;slice.apply(arguments); // 类似对象的方法那样调用 bind用法 1234var unboundSlice = Array.prototype.slice;var slice = Function.prototype.apply.bind(unboundSlice);// ...slice(arguments); // 直接调用，简单 三者的区别：相同之处：改变函数体内 this 的指向。不同之处： call、apply的区别：接受参数的方式不一样。bind：不立即执行。而apply、call 立即执行。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}],"keywords":[]},{"title":"window OS 下安装php 开发环境","slug":"window下安装php开发环境","date":"2019-09-10T00:28:34.779Z","updated":"2019-03-08T01:24:35.054Z","comments":true,"path":"2019/09/09/window下安装php开发环境/","link":"","permalink":"http://yoursite.com/2019/09/09/window下安装php开发环境/","excerpt":"windowOS安装mysql5+ 解压缩版之教程","text":"windowOS安装mysql5+ 解压缩版之教程 一、Apache因为Apache官网只提供源代码，如果要使用必须得自己编译，这里我选择第三方安装包Apache Lounge。 进入Apachelounge官方下载地址：http://www.apachelounge.com/download/首先下载并安装vc redist，这是Apache运行必需的一个组件。下载Apache解压版，将解压后的文件夹放在你想要安装的路径下。修改配置文件： Apache默认存在路径：“c:\\Apache24” 下（版本号可能不同）。如果跟你的安装路径不同，你需要打开Apach\\conf\\httpd.conf配置文件，将其中所有前面没有被”#”注释的”c:\\Apache24”、”c:\\Apache24\\htdocs”和”c:\\Apache24\\cgi-bin\\”改成对应的路径。 指定IP和端口：在httpd.conf找到”ServerName www.example.com:80&quot;，将前面的注释去掉，将&quot;www.example.com&quot;修改为&quot;localhost&quot;。如果你要修改端口，将这里&quot;80”和前面“Listen：80”中的80一起修改。 （可选）添加系统变量：将”Apache的安装路径\\bin”添加到Path中。验证安装是否成功：运行Apache的启动httpd.exe。在浏览器上输入localhost:80，如果不是无法访问那么Apache的配置便完成了。 二、PHP安装配置PHP 进入PHP下载地址http://windows.php.net/download下载最新线程安全版PHP zip压缩包，解压缩后放在想要安装的路径下。注意：下载的PHP VC版本不能比前面安装的vc redist版高。 进入PHP安装目录，复制一份php.ini-development改名为php.ini放到安装路径下，打开找到”extension_dir”，去掉注释符，将值改为”PHP安装路径\\ext” 在Apache中加载PHP 打开Apache的配置文件conf\\httpd.conf，找到LoadModule区域，在其后加入： LoadModule php7_module &quot;PHP安装路径\\php7apache2_4.dll&quot; # 在Apache中以module的方式加载PHP，“php7_module”中的“7”要和PHP的版本对应；此外，不同的PHP版本“php7apache2_4.dll”可能不同。 PHPIniDir &quot;PHP安装路径&quot; #告诉Apache PHP的安装路径 定义执行PHP模块的文件 查找 AddType application/x-gzip .gz .tgz，在其下一行添加代码：AddType application/x-httpd-php .php .html：声明.php和.html的文件能执行PHP程序。 测试：在 Apache安装路径\\htdocs下新建文件：test.php，里面编辑：&lt;?php phpinfo(); ?&gt;， 启动Apache， 在浏览器输入：localhost:80/test.php。 三、MySQL 安装：在https://dev.mysql.com/downloads/下载相应安装版本，根据自己的需求安装。在PHP中加载连接MySQL的程序集：在php.ini extension板块中增加一行extension=php_mysqli.dll。 说明：不同的PHP版本可能提供不同的连接mysq的程序集，去ext文件夹下看看PHP提供的是什么这里就写什么。不同的程序集可能在连接数据库的时候使用的函数也不一样。 测试：在test.php中编辑：&lt;?php $mysqli = mysqli_connect(“localhost”,”root”,”pwd”) or die(“cannt connet”); ?&gt;，启动数据库，重启Apache，在浏览器端查看，如果没有错误信息便配置正确了。","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}],"keywords":[]},{"title":"window下安装mysql解压缩版之教程","slug":"window os 安装解压缩版的mysql教程","date":"2019-09-10T00:28:34.767Z","updated":"2019-03-08T01:22:50.215Z","comments":true,"path":"2019/09/09/window os 安装解压缩版的mysql教程/","link":"","permalink":"http://yoursite.com/2019/09/09/window os 安装解压缩版的mysql教程/","excerpt":"windowOS安装mysql5+ 解压缩版之教程","text":"windowOS安装mysql5+ 解压缩版之教程 1.下载路径1https://dev.mysql.com/downloads/mysql/(或者自行去官网) 有账号登陆下载，没有账号：no thanks;just start my download 2.解压放到指定盘中1如笔者：D:\\mysql5.7 3.配置环境变量123找到系统变量MYSQL_HOME:D:\\mysql5.7在path 后面添加 ;%MYSQL_HOME%\\bin 4.在D:\\mysql5.7(注意根据自己的安装路径)目录下新建my.ini（mysql8+ 版本不需要此文件），并写入内容如下：123456789101112131415161718[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[mysqld]# 跳过root密码# skip-grant-tables# 设置3306端口port = 3306# 设置mysql的安装目录basedir=D:\\mysql5.7# 设置mysql数据库的数据的存放目录datadir=D:\\mysql5.7\\data #自己创建data目录# 允许最大连接数max_connections=200# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8#创建新表时将使用的默认存储引擎default-storage-engine=INNODB 亲爱的请注意:basedir和datadir，请根据自己的实际安装目录进行修改注意win10下这里的斜杠必须是两个斜杠，才能转义 5.管理员权限打开cmd，并进入到D:\\mysql5.7\\bin目录下初始化data目录，指令如下1mysqld --initialize --console # 首次输出初始化密码 安装服务1mysqld -install mysql5 # mysql5 是服务名称 ctrl + shifi + esc 可以查看 卸载服务1sc delete mysql5 # 出现问题时，可执行 安装完成后启动服务1net start mysql5 停止服务1net stop mysql5 服务启动成功后，可以登录客户端了1mysql -u root -p # 输入初始化时生成的密码 进入客户端，为了方便起见，找到user表的密码字段,可以将初始化密码更新为自定义密码","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}],"keywords":[]},{"title":"javascript的编程风格","slug":"js的编程风格","date":"2019-09-10T00:28:34.759Z","updated":"2019-03-08T01:20:45.923Z","comments":true,"path":"2019/09/09/js的编程风格/","link":"","permalink":"http://yoursite.com/2019/09/09/js的编程风格/","excerpt":"javascript的编程风格","text":"javascript的编程风格 “计算机科学只存在两个难题：缓存失效和命名。”——Phil Karlton一、基本的格式化 PascalCase 和 CamelCase 都表示驼峰命名 二者的区别： PascalCase以大写字母开始，而CamelCase 以小写字母开始 缩进层级：使用4个空格符作为一个缩进层级 语句结尾：JS语句要以分号结尾 行的长度：推荐将行的长度限制在80个字符 换行 通常会在运算符后换行，下一行会增加两个层级的缩进。12callFunc(document, window, \"some string value\", true, 123 navigator); 当给变量赋值时，第二行的位置应当和赋值运算符的位置保持对齐 12var result = something + anotherThing + somthingElse + anotherSomethingElse 空行在方法之间 在方法中的局部变量（local variable）和第一条语句之间 在多行或单行注释之前 在方法内的逻辑片段之间插入空行，提高可读性 命名变量和函数 变量：变量名应当总是遵守驼峰（Camel Case）命名法，并且命名前缀应当是名词 函数：函数名应当总是遵守驼峰（Camel Case）命名法，并且命名前缀应当是动词 常量: 使用大写字母和下划线来命名，下划线用以分割单词 var MAX_COUNT = 10; 构造函数：构造函数的命名遵照大驼峰命名法（Pascal Case） 直接量 字符串：单引号和双引号均可，推荐使用双引号。（便于在Java和JavaScript之间切换，Java只允许使用双引号） 多行字符使用字符串连接符（+）将字符串分成多份 数字不要省略小数点之前或之后的数字 禁止八进制直接量 12345678910// 不推荐的写法var price = .1;var price = 10.;var price = 010; // 八进制写法已经被弃用了// 推荐写法var price = 10.00;var price = 10;var num = 0xA2; // 十六制写法var num = 1e23; // 科学计数法 null应当使用null的场景 始化一个变量，这个变量可能被赋值成一个对象 一个已经初始化的变量比较，无论这个变量是否为一个对象 的参数期望是对象时，用作参数传入 的返回值期望是对象时，用作返回值传出 不当使用null的场景 不要使用null来检测是否传入了某个参数 不要用null来检测一个未初始化的变量 1234567891011// 不要用null来检测一个未初始化的变量var person;if (person != null) &#123; doSomething();&#125;// 不要使用null来检测是否传入了某个参数function doSomething(arg1,arg2,arg3,arg4) &#123; if (arg4 != null )&#123; doSomething(); &#125;&#125; undefined 避免在代码中使用undefined，可以有效的确保只有在一种情况下typeof才会返回&quot;undefined&quot;：当变量未声明时。如何可以，则将其赋值为null。 当变量初始值赋值为null，则表明这个变量最终很可能赋值为对象，typeof null 返回&quot;object&quot;，这样就可以和undefined区分开了 对接直接量 避免使用构造函数创建对象 二、注释单行注释 独占一行的注释，用来解释下一行的代码。这行注释之前总是有一个空行，且缩进层级与下一行代码一致。 在代码行的尾部注释。代码结束到注释之间至少有一个缩进。注释（包括之前的代码部分）不应当超过单行 最大字符数限制，如果超过了，就将这条注释放置于当前代码行的上方。 被注释掉的大段代码 多行注释 推荐Java风格的多行注释 使用注释 难于理解的代码 可能被误认为错误的代码 浏览器特性hack 推荐使用文档生成工具来为你的JavaScript生成文档。JavaScript代码注释必须符合你所用的工具支持的格式，很多文档生成工具都支持JavaDoc风格的文档注释。 文档注释 需要添加注释的内容 所有的方法 应当对方法、期望的参数及可能的返回值添加注释描述 所有的构造函数 应当对自定义类型和期望的参数添加注释描述 所有包含文档化方法的对象 如果一个对象包含一个或多个附带文档注释的方法，那么对这个对象也应该适当地针对文档生成工具添加文档注释 三、语句和表达式1.花括号的对齐方式所有的块语句都应当使用花括号12345678910111213141516// java 风格，推荐这种风格if (condition) &#123; doSomething();&#125; else &#123; doSomethingElse();&#125;// c#风格、不推荐这种风格，以避免错误的分号自动插入if (condition)&#123; doSomething();&#125;else&#123; doSomethingElse();&#125; 2.块语句间隔123456789101112// 在语句名、圆括号和左花括号之间没有空格if(condition)&#123; doSomething();&#125;// 在左圆括号和右边圆括号之后各自添加一个空格（推荐）if (condition) &#123; doSomething();&#125;// 在左圆括号后和右前各添加一个空格if ( condition ) &#123; doSomething();&#125; 3.swith 语句1&gt;.缩进1234567891011// java风格（推荐）switch (condition) &#123; case \"first\": // 代码 break; case \"second\": // 代码 break; default: // 代码&#125; 2&gt;. case语句的‘连续执行’1234567891011// 只要事是有意为之并且添加了注释，就可以使用case语句的连续执行switch (condition) &#123; case \"first\": // 代码 break; case \"second\": // 代码 break; default: // default 中没有逻辑&#125; 3&gt;. default1234567891011// 从语法结构角度考虑，即使default中什么也不做，也不应当省略defaultswitch (condition) &#123; case \"first\": // 代码 break; case \"second\": // 代码 break; default: // 代码&#125; 4.with 语句避免使用with语句在严格模式下(‘use strict’)，with语句是被明确禁止的，如果使用则报语法错误 5.for 循环Dojo编程风格指南明确指出可以使用continue和break推荐尽可能避免使用continue，但也没有理由完全禁止使用，应该根据代码可读性来决定。 6.for-in 循环for-in 循环是用来遍历对象属性的，避免用它来遍历数组所有的for-in 循环必须使用hasOwnProperty()方法过滤触实例属性123456for (var prop in object) &#123; if (object.hasOwnProperty(prop)) &#123; console.log('Property name is' + prop); console.log('Property value is' + object[prop]); &#125; &#125; 三、变量和函数运算符1.变量声明注意：变量声明的提升123456789101112function doSomethingWithItems(items)&#123; for (var i = 0, len = items.length; i &lt; len; i++) &#123; doSomething(item[i]); &#125;&#125;// 等价于以下代码function doSomethingWithItems(items)&#123; var i, len; for (i = 0, len = items.length; i &lt; len; i++) &#123; doSomething(item[i]); &#125;&#125; 2.函数声明注意：函数声明的提升 函数不应该出现在语句块之内 函数声明应该在条件语句的外部使用12345678910// 这段代码在不同的浏览器中运行的结果不尽相同if (condition) &#123; function doSomething() &#123; alert('hi'); &#125;&#125; else &#123; function doSomething() &#123; alert('Yo'); &#125;&#125; 3.函数调用间隔推荐风格：在函数名和左括号之间没有空格doSomething(item); 1&gt;. 立即调用函数 将函数用一对圆括号包裹起来1234567// 将函数用一对圆括号包裹起来 var value = (function ()&#123; // 函数体 return &#123; message: 'Hi' &#125;&#125;)(); 2&gt;.严格模式‘use strict’;推荐尽量使用严格模式尽量不要在全局作用域中使用严格模式如果希望在多个函数中应用严格模式可以使用立即执行函数 123456789(function() &#123; 'use strict'; function doSometing() &#123; // 代码 &#125; function doSomethingElse() &#123; // 代码 &#125;&#125;)(); 3&gt;.相等==和!=比较会发生强制类型转换推荐使用===和!==进行比较尽量避免使用eval()函数尽量避免使用原始包装类型创建对象 12345678// 不好的做法（应该尽量避免）eval(\"alert('hi')\");var muFunc = new Function('alert('Hi')');setTimeout( 'document.body.style.background=\"red\"',50);setInterval('document.title=\"it is now\"' + (new Date()),1000);var name = new String('Nicholas');var auther = new Boolean(true);var count = new Number(10);","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}],"keywords":[]},{"title":"javascript语法基础系列之操作符","slug":"javascript语法基础系列之操作符","date":"2019-09-10T00:28:34.751Z","updated":"2019-03-08T01:20:25.648Z","comments":true,"path":"2019/09/09/javascript语法基础系列之操作符/","link":"","permalink":"http://yoursite.com/2019/09/09/javascript语法基础系列之操作符/","excerpt":"javascript语法基础系列之操作符","text":"javascript语法基础系列之操作符 一、其他基本类型转换为Number类型1.null转化成Number123var ret = Number(null);console.log(ret); // 0console.log(typeOf ret); //number 2.undefined 转化成Number1console.log(Number(undefined)); // NaN 3.boolean转成Number12console.log(Number(true));console.log(Number(false)); 4.String转成Number Number() 1.如果字符串中存在除了数字和小数点以外的其他字符，则转换失败，值为NaN 2.加减号在头表示正负号 3.开头有空白字符可以过滤 12345678910111213// string -&gt; number(Number())console.log(Number('123')); // 123console.log(Number('+123')); // 123console.log(Number('-123')); // -123console.log(Number(' 123')); // 123console.log(Number('12.3')); // 12.3console.log(Number(' ')); // 0console.log(Number('12+3')); // NaNconsole.log(Number('12-3')); // NaNconsole.log(Number('a123')); // NaNconsole.log(Number('12 3')); // NaNconsole.log(Number('12..')); // NaN parseInt() 1.将接收到的数据（一般都是字符串）转化成整数 2.转换规则：从第一个非空白字符（空格、换行、tab）开始转换，直到遇到一个非数字字符为止。 3.如果转化失败，结果为NaN 4.从第一个非空字符开始，如果第一个字符不是数字或者正负号，parseInt()就会返回NaN，因此，parseInt()转换空字符结果为NaN，但是Number返回0 12345678910111213//string -&gt;number(parseInt())console.log(parseInt('123')); // 123console.log(parseInt('+123')); // 123console.log(parseInt('-123')); // -123console.log(parseInt(' 123')); // 123console.log(parseInt('12.3')); // 12console.log(parseInt(' ')); // NaNconsole.log(parseInt('12+3')); // 12console.log(parseInt('12-3')); // 12console.log(parseInt('a123')); // NaNconsole.log(parseInt('12 3')); // 12console.log(parseInt('12..')); // 12 parseFloat() 1.将接收到的数据（一般都是字符串）转成浮点数 2.遇到的第一个小数点有效，第二个小数点就无效了 123456// string -&gt; number(parseFloat())console.log(parseFloat('12.3')); // 12.3console.log(parseFloat('12..3')); // 12console.log(parseFloat(' 12.3')); // 12.3console.log(parseFloat('12.3+123')); // 12.3console.log(parseFloat(' ')); // NaN 二、其他基本类型转为String类型1.null转化成String12// null -&gt; stringconsole.log('hello' +null); //hellonull 2.undefined转化成String123var str = undefined + '';console.log(str); // undefinedconsole.log(typeof str) // string 3.boolean转化成String123// boolean -&gt; stringconsole.log(true.toString()); // 'true'console.log(typeof true.toString()); // string 3.number转化成String1234// number -&gt; stringvar num = 10;console.log('' + 1); // 1console.log(num.toString()); // 10 三.其他基本类型转换为Boolean类型12345678// 绝大多数转成布尔值，结果都为true 以下这六种情况转为boolean结果为false console.log(Boolean(0)); // false console.log(Boolean('')); // false console.log(Boolean(fasle)); // false console.log(Boolean(NaN)); // false console.log(Boolean(undefined)); // false console.log(Boolean(null)); // false 四、prompt(“ “) prompt()接收外部的数据，默认是字符串类型 有时需要将其转化成整数 var age = parseInt(prompt(“请输入年龄”)); 五、算数运算符和算数运算表达式 1.表达式：由变量、常量和运算符组成的式子 2.如何阅读表达式 功能：进行相关的运算 值：相关运算之后得到的值 3.算数运算符 +-*/、%(取余数) *（乘）a.如果操作数都是数值，则执行常规的乘法运算，如果结果超过JS数值范围，则返回Infinity或者-Infinityb.NaN参与乘法运算，则结果返回NaNc.Infinity0，返回NaNd.Infinity与非0操作数运算时，结果返回Infinity或者-Infinity。取决于有符号操作数的符号。e.Infinity Infinity，结果是Infinityf.如果有一个操作数不是数值，那么在参与运算前会先对操作数执行Number()将其转化为数值，再应用上面的规则123456789// * 乘法console.log(2*3); // 6console.log(NaN*3); // NaNconsole.log(Inifnity*0); // NaNconsole.log(Infinity*2); // Infinityconsole.log(Infinity*(-2)); // -Infinityconsole.log(Infinity*Infinity); // Infinityconsole.log(Infinity*(-Infinity));// -Infinityconsole.log(\"2\"*3); // 6 /（除）a.如果操作数都是数值，则执行常规的除法运算，如果结果超过JS数值范围，则返回Infienter code herenenter code hereity或者-Infinity b.NaN参与除法运算，则结果返回NaN c.Ienter code herenfinity / Infinity，结果为NaN d.0 / 0， 结果为NaN e.如果是非0的有限数被0除，则结果是Infinity或者-Infinity，取决于有符号操作数的符号enter code here` f.如果是Infinity被任何非0 整数值除，则结果是Infinity或者-Infinity g.如果有一个操作数不是数值，那么在参与运算前会先对操作数执行Number()将其转化为数值，再应用上面的规则12345678910// /除法console.log(5/3); // 1.6666666console.log(NaN/3); // NaNconsole.log(Infinity/Infinity); // NaNconsole.log(0/0); // NaNconsole.log(2/0); // Infinityconsole.log((-2)/0);//-Infinityconsole.log(Infinity/2); //Infinityconsol`enter code here`e.log(Infinity/(-2)); //-Infinityconsole.log('5'/3); //1.66666 % （取余）a.如果enter code here操作数都是数值，则执行常规的取余运算b.如果被除数是无穷大值，而除数是有限大值，结果为NaNc.如果被除数是有限大值，除数是0，结果为NaNd.被除数是0，结果为0e.如果有一个操作数不是数值，那么在参与运算前会先对操作数执行Number()将其转化为数值，再应用上面的规则123456// % 取余console.log(5%3); // 2console.log(Infinity % 3); //NaNconsole.log(3%0); // NaNconsole.log(0 % 2); // 0console`enter code here`.log('7'%3); //1 +（加）a.如果操作数都是数值，则执行常规的加法运算b.如果有一个操作数是NaN，则返回NaNc.Infinity + Infinity = Infinityd.(-Infinity) + (-Infinity) = -Infinitye.Infinity + (-Infinity) = NaNf.两个都是字符串，则拼接字符串g.一个数值，一个字符串，则现将数值转为String类型，然后拼接字符串12345678// + 加法console.log(5+3); // 8console.log(NaN + 3); //NaNconsole.log(Infinity + Infinity); // Infinityconsole.log((-Infinity) + (-Infinity)); // -Infinityconsole.log(Infinity + (-Infinity)); //NaNconsole.log('hello ' + 'world'); // hello worldconsole.log('hello ' + 2017); // hello 2017 -减a.如果操作数都是数值，则执行常规的减法运算b.如果有一个操作数是NaN，则返回NaNc.Infinity - Infinity = NaNd.(-Infinity) - (-Infinity) = NaNe.Infinity - (-Infinity) = Infinityf.-Infinity - Infinity = -Infinity 1234567// - 减法 console.log(5 - 2); // 3 console.log(NaN -3); // NaN console.log(Infinity - Infinity); // NaN console.log(-Infinity - (-Infinity)); // NaN console.log(Infinity - (-Infinity)); // Infinity console.log(-Infinity - Infinity); // Infinity 4.算术运算表达式 变量1 算数运算符 变量2 5.功能：进行相关的数学运算，不能改变变量的值 6.值：相关数学运算之后的结果 六、自增自减运算符1.自增 自增运算符 ++ 自增运算表达式 变量 ++ 后++，先取值再加1，表达式的值是变量+1之前的值 ++ 变量，先++，先加1再取值，表达式的值是变量+1之后的值 功能：两种都是实现变量的值自动加1 2.自减 自减运算符 – 自减运算表达式 变量– 后–，先取值再减1，表达式的值是变量减1之前的值 –变量 先–，先减1再取值，表达式的值是变量减1之后的值 功能：两种都是实现变量的值自动减1 七、赋值运算符和赋值运算表达式赋值运算符 =赋值运算表达式 变量 = 表达式功能：实现对变量的赋值操作值 复合运算符 += a+=1 === a=a+1 -= a-=1 === a=a-1 = a=1 === a=a*1 /= a/=1 === a=a/1 %= a%=1 === a=a%1 赋值运算结束之后，变量的值 八、关系运算符和关系运算表达式 关系运算符 &gt;、&gt;=、&lt;=、 == 只比较数值，不比较类型。比较之前会进行类型统一 === 数值和类型都要相等才可 关系运算表达式： 表达式1 关系运算符 表达式2 功能： 计算表达式1和表达式2的关系值 值： 如果关系成立，值为真，否则值为假 注意: 关系运算符不能连用。例如 1 &lt;= num &lt;= 5 会存在语法错误 九、逻辑运算符 逻辑与（&amp;&amp;）有一个条件为假，则结果为假 逻辑或（||）有一个条件为真，则结果为真 逻辑非（!）取非运算 十、三目运算和三目运算符 三目运算符 三目运算表达式： 表达式 ? 表达式1 : 表达式2 功能：计算”表达式”的值，如果”表达式”的值为真，则计算表达式1的 值，否则计算表达式2的值 值：如果”表达式”的值为真，则取表达式1的计算值作为结果，否则取表 达式2的计算值作为结果","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}],"keywords":[]},{"title":"javascript 语法基础系列之Object","slug":"javascript语法基础系列之Object","date":"2019-09-10T00:28:34.747Z","updated":"2019-03-08T01:20:13.043Z","comments":true,"path":"2019/09/09/javascript语法基础系列之Object/","link":"","permalink":"http://yoursite.com/2019/09/09/javascript语法基础系列之Object/","excerpt":"javascript语法基础系列之Object","text":"javascript语法基础系列之Object 对象的定义JS中的所有事物都是对象,对象是属性和方法的集合，而类又是对象的抽象集合JS 自带很多内部对象：String Date Array等对象的创建，属性及方法的使用方法 1234// 声明式创建var o = &#123;&#125;;// 构造函数创建var o = new Object(); 空对象的判断如果只是判断对象未 null 或 undefined 1234var obj; if (!obj)&#123; console.log('对象为空');&#125; 如果是判断对象没有任何可枚举属性 1234var obj;JSON.stringify(obj) == '&#123;&#125;';// 大部分情况 可用 for...in 遍历看枚举属性，包括prototype 中的（继承来的）Oject.keys(obj) 只遍历自有的可枚举属性 注意：不要用 JSON.parse(str) == {}; 因为对象的值是引用类型的，引用地址不同就不相等但是对象的属性也可以通过设置enumerable = false 为不可枚举的，那么通过上面的方法就没法判断对象是否具有某个属性了 对象的相等判定一般比较对象的相等都是比较不为空的两个对象的相等 1&#123;&#125; == &#123;&#125;; // false 对象是引用类型的 引用地址不同就不相等 所以，一般我们比较两个对象是否相等是都是比较它们是否具有相同的属性和方法，以及它们对应的值是否相等，而不是通过 ‘==’ 来比较 对象属性的顺序顺序和你的添加顺序无关，ES6 Map()支持有序的对象，不同的浏览器排序的规则也不相同，因此想跨浏览器最好使用数组","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}],"keywords":[]},{"title":"javascript语法基础系列之字符串基本用法","slug":"javascripty语法基础系列之字符串基本用法","date":"2019-09-10T00:28:34.739Z","updated":"2019-03-08T01:19:43.254Z","comments":true,"path":"2019/09/09/javascripty语法基础系列之字符串基本用法/","link":"","permalink":"http://yoursite.com/2019/09/09/javascripty语法基础系列之字符串基本用法/","excerpt":"javascript语法基础系列之字符串基本用法","text":"javascript语法基础系列之字符串基本用法 字符串 有两种形式的字符串: 基本类型、对象类型（临时对象） 注意：字符串所有的方法看上去是返回一个修改后的字符串，实际上返回的是一个新的字符串值 123456// 字符串 基本类型 Stringvar str1 = 'Hello World';console.log(typeof str1);// 字符串 对象类型 Objectvar str2 = new String('Hello World');console.log(typeof str2); 对象类型的字符串封装了一些属性及方法，而基本类型则没有可以直接用基本类型字符串调用字符串对象封装的属性及方法，无须手动转换 字符串的长度字符串中的length是只读属性，不可更改按各国标注字符来计算长度 12345// 按各国标注字符串来计算长度var str = \"实现伟大的中国梦\";console.log(str.length);// 获取对应下标处的字符console.log(str[3]); // 大 字符串的常用方法1.charAt(index) 功能：获取对应下标处的字符 参数：下标 返回值：获取到的字符，没有字符则返回空字符串 1234var str = \"what color do yu lile\";console.log(str.charAt(3)); // tconsole.log(str.charAt(30)); // 空字符串(“”)console.log(typeof str.charAt(30)); // string 2.charCodeAt(index) 功能：获取对应下标处的字符编码 参数：下标 返回值：获取到的字符编码(0-65535),没有对应 的下标则返回NaN 1234var str = \"what color do yu lile\";console.log(str.charAt(3)); // 116console.log(str.charAt(30)); // NaNconsole.log(typeof str.charAt(30)); // number 3.String.fromCharCode(ASCII码) 功能：获取ASCII码对应的字符 1234// 参数：ASCII// 返回值：对应的字符var charStr = String.fromCharCode(117);console.log(charStr); // u 4.toLowerCase() toUpperCase() 功能: 字符串的大小写转换 返回值: 转换后的字符串 注意：不会改变原字符串 123456789var str = 'hello';// 全部转换为大写console.log(str.toUpperCase()); // HELLO// 不会更改原有字符串console.log(str); // hello// 全部转换为小写console.log(str.toLowerCase()); // hello// 不会更改原有字符串console.log(str); // hello 5.==, === 判断相等 == 只比较值相等，不对类型进行比比较 比较之前会先进行类型统一 === 要求值和类型均相等 1234console.log(1 == \"1\"); // trueconsole.log(1 == true); // trueconsole.log(1 === \"1\"); // falseconsole.log(1 === \"1\"); // false 6. localeCompare() 功能：字符串比较大小 规则：两个字符串从下标为0的字符开始比较 如果谁的ASCII码值大，那么谁大,如果相等继续比较后面的字符，当两个字符不想等时停止比较，此时谁的ASCII码值大谁就大 返回值： 1– 前面字符串大于后面的字符串 -1– 前面的字符串小于后面的字符串 0 – 前面的字符串等于后面的字符串12345678910vat str1 = 'abcd';var str2 = 'abdd';var retVal = str1.localCompare(str2);if (retVal &gt; 0)&#123; console.log(str1 + '&gt;' + str2);&#125; else if (retVal &lt; 0)&#123; console.log(str1 + '&lt;' + str2);&#125; else &#123; console.log(str1 + '==' + str2);&#125; 7.indexof(searchValuem, fromindex) 功能：从左至右查找第一次出现的字符串 参数：要查找的字符串 返回值：子串第一次出现的下标，如果没有子字符串，则返回-1 8. lastIndexOf(searchValue, fromindex) 功能：从右至左查找第一次出现的字符串 参数： searchValue：要查找的字符串 fromindex：可选参数，表示从指定下标处开始往后查找 返回值: 子串第一次出现的下标，如果没有子字符串，则返回-1 123456va str = \"Tom is a good man, Tom is a nice man\";// 从左至右查找第一次出现'is'字符串的下标console.log(str.indexof('is')); // 4// 从右至左查找第一次出现'is'字符串的下标console.log(str.lastIndexof('is')); // 23 9.replace(oldStr, newStr) 默认只能替换第一次出现的oldStr 通过正则表达式可以实现全部替换 10.substring(start,stop) 定义：substring()方法用于提取字符串中介于两个指定下标之间的字符 参数 start：必须。一个非负的整数，要提取的子串的第一个字符在原字符中的位置 end：可选。一个非负的整数，要提取的子串的最后一个字符在原字符中的位置+1 如果省略该参数，那么返回的子串会一直截取到原字符串的末尾 返回值：一个新的字符串，该字符串值包含 stringObject 的一个子字符串，其内容是从 start 处到 stop-1 处的所有字符，其长度为 stop 减 start。 注意： 如果start与stop相等，那么该方法返回的就是一个空串（即长度为0的字符串） 如果start比stop大，那么该方在提取字符串之前会先交换两个参数 11.substr(start,length) 定义：substr() 方法可在字符串中抽取从 start 下标开始的指定数目的字符。 参数： start：必需。要抽取的字串的起始下标，必须是数值，如果是负数，那么该参数声明从字符串的尾部开始的位置算起，也就是说，-1 指字符串中最后一个字符，-2指倒数第二个字符，依次类推 length：可选。字符串中的字符数，必须是数值，如果省略了该参数，那么返回从原字符串开始位置到结尾的字符串。 返回值： 一个新的字符串，包含从 原字符串的 start（包括 start 所指的字符） 处开始的 length 个字符。如果没有指定 length，那么返回的字符串包含从 start 到原字符串的结尾的字符。 注意：substring() &amp; sunstr() 均不会改变原有的字符串stringObject.split(separator, howmany); 定义：split() 方法用于把一个字符串分割成字符串数组 参数： separator 必须。字符串或正则表达式，从该参数指定的位置分割stringObject。 howmany 可选。该参数可指定返回数组的最大长度。如果设置了该参数,整个字符串都会被分割，不考虑它的长度。 返回值：一个字符串数组 注意：如果吧把空字符串(‘’)用作separator，那么 身体stringObject 中的每个字符之间都会被分割 12.concat() 用于将一个多个字符串拼接起来 13.trim() 这个方法会创建一个字符串的副本，删除前缀及后缀的所有空格，然后返回结果 14.模式匹配1234567var text = \"testing:1,2,3\"; // 实力文本var pattern = /\\d+/g; // 匹配所有的的包含一个或多个的实例pattern.test(text); // true : 匹配成功text.search(pattern); // 9 首次匹配成功的位置text.match(pattern); // ['1', '2', '3'] 所有匹配组成的数组text.replace(patten, \"#\"); // \"testint:# # #\"text.split(/D+/); // [\"\", \"1\", \"2\", \"3\"] : 用非数字字符截取字符串 math 对象12345678910111213141516171819// 四舍五入console.log(Math.round(4.5)); // 5// 向上取整console.log(Math.ceil(31.)); // 4// 向下取整console.log(Math.floor(3.9)); // 3// 取最大值console.log(Math.max(4,4,6,76,89,31)); // 89// 取最小值console.log(Math.min(3,4,7,99,0)); // 0// 取绝对值console.log(Math.abs(-10)); // 10// x的y 次方console.log(Math.pow(2,3)); // 8// 开平方console.log(Math.sqrt(25)); // 5// 生成一个0-1之间的随机数console.log(Math.random()); // 0-1之间的随机数","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}],"keywords":[]},{"title":"javascript语法基础系列之基本语句","slug":"javascripty语法基础系列之基本语句","date":"2019-09-10T00:28:34.739Z","updated":"2019-03-08T01:19:25.375Z","comments":true,"path":"2019/09/09/javascripty语法基础系列之基本语句/","link":"","permalink":"http://yoursite.com/2019/09/09/javascripty语法基础系列之基本语句/","excerpt":"javascript语法基础系列之基本语句","text":"javascript语法基础系列之基本语句 if 语句if-else 语句if-else-if 语句 条件语句：123if (表达式) &#123; 语句&#125; 注意：可以嵌套，嵌套不要超过6层，一般也就三层 每个else都是对他上面所有表达式的否定 switch 语句 和 break语句while语句do-while do-while 注意：语句至少执行一次 for 和 for-in语句 用来枚举对象的属性 如果要迭代的对象是null或者是undefined，那么抛出异常 break语句break专门用来跳出switch语句和循环语句的 break后面的代码是不会被执行的 break只跳出距离它最近的那一次循环或switch continue语句 用来跳过本次循环，继续下一次循环的，通常用在for循环内部 死循环 条件始终为真，循环永远不会结束","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}],"keywords":[]},{"title":"javascript语法基础系列之基本概念","slug":"javascripty语法基础系列之基本概念","date":"2019-09-10T00:28:34.727Z","updated":"2019-03-08T01:19:11.190Z","comments":true,"path":"2019/09/09/javascripty语法基础系列之基本概念/","link":"","permalink":"http://yoursite.com/2019/09/09/javascripty语法基础系列之基本概念/","excerpt":"javascript语法基础系列之基本概念","text":"javascript语法基础系列之基本概念 JS 简介javascript 内容的引入 如何在静态页面上做出如下动态特效： 1、亲切的欢迎讯息 2、漂亮的数字钟 3、有广告效果的跑马灯及简易的选举 4、轮流播放的图片 5、对客户端数据进行验证 javascript 是什么东东？ JavaScript主要用于HTML的页面，嵌入在HTML的源码中。 JavaScript是因特网上最流行的脚本语言，它存在于全世界所有的Web浏览器中，能够增强用户与Web站点和Web应用程序之间的交互。 JS是弱类型语言，没有类型声明，它的变量不必具有一个明确的类型。 JS是脚本语言。换句话说，能够用来编程的并且直接执行源代码的语言，就是脚本语言。 JS也是解释性的语言。何为解释性语言？是在运行的时候将程序直接翻译成机器语言。 JS是一种基于对象（Object）和事件驱动（Event Driven）并具有安全性能的脚本语言，可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。 HTML5的出现更是突出了JavaScript的重要性，例如HTML5的绘图支持、本地存储、离线应用、客户端通信等，都大量使用了JavaScript。 javascript 的历史？ 网景公司在上个世纪的1995年，凭借其Navigator浏览器，成为Web时代开启时最著名的第一代互联网公司。由于网景公司希望能在静态的HTML页面添加一些动态的效果，于是叫Brendan Eich这哥们在两周之内设计出了JavaScript语言。为什么起名叫JavaScript？原因是当时Java语言非常红火，所以网景公司希望借Java的名气来推广，但事实上，JavaScript除了语法上有点像Java，其他部分基本上没啥关系。就像雷锋与雷峰塔的关系。 javascript的特点 1、简单性：它是基于Java基本语句和控制流之上的简单而紧凑的设计，是学习Java的好过渡，而且，它的变量类型是采用弱类型，未采用严格的数据类型。 2、安全性：JS不允许访问本地硬盘，不能将数据存入到服务器上，不允许对网络文档进行修改和删除，只能通过浏览器实现信息浏览和动态交互，从而有效的防止数据的丢失。 3、动态性：JS可以直接对用户或客户输入做出响应，无须经过Web程序。它对用户的响应通过以事件驱动的方式进行，即由某种操作动作引发响应的事件响应，如：点击鼠标、移动窗口、选择菜单等。 4、跨平台：JS依赖浏览器本身，与操作环境无关。只要能运行浏览器 的计算机，并安装了支持JS的浏览器就可以正确执行，从而实现了“编写一次，走遍天下”的梦想。 javascroipt 的组成 JavaScript是由ECMAScript、文档对象模型（Document Object Model： DOM）、浏览器对象模型（Browser Object Model：BOM）三部分构成，其核心是ECMAScript，它描述了该语言的语法和基本对象；DOM描述了处理网页内容的方法和接口，通过DOM，可以访问所有的HTML元素，连同它们所包含的文本和属性，可以对其中的内容进行修改和删除，同时也可以创建新的元素；BOM描述了与浏览器进行交互的方法和接口，BOM提供了独立于内容而与浏览器窗口进行交互的对象，例如可以移动，调整浏览器窗口大小的window对象，可以用于导航的location对象和history对象，可以获取浏览器，操作系统与用户屏幕信息的navigator与screen对象，可以使用document作为访问HTML文档的入口，管理框架的frames对象等。 JS 注释1234// 单行注释/* * 多行注释 */ JS的引入方式 1.外部的js代码 在标签里面src=””;中添加链接 注：如果链接了外部JS文件，script标签内部的JS代码就不会执行了 2.内部添加JS代码 直接将js语句写在 标签内部 注：script 标签可以有多个，将按顺序执行 JS的输出方式 1.页面输出 1document.write(\"sunck is a nice man\"); // document可以在页面中输出标签的内容 2.控制台输出 1console.log(\"sunck is a good man\"); // 只能将标签以字符串的形式输出 3.提示框输出 1alert(\"sunck is a handsome man\"); // 只能将标签以字符串的形式输出 JS 标识符 1.含义：一串字符串（字符串未必是标识符） 2.作用：用来给变量函数等命名的 3.规则： · 由字母，数字，下划线和$组成 · 不能以数字开头 · 不能是JS中的关键字和保留字 · 区分大小写 · 遵循驼峰原则（funName）第一个首字母小写，后面单词字母大写 · 见名知意 4.同一命名空间 JS数据类型基本数据类型 1.数字（Number） 含义：包括浮点型和整型 浮点型—就是该数值中必须有以为小数点并且小数点后面必须有以为数字 由于浮点数值的内存空间是保存整数值的两倍， 所以js会不失时机的把浮点型数转换为整型。 小数点后面没数值或1.0会被保存为整数 特殊的数字类型 NaN: 表示不是一个数字，其实他是一个特殊的数字 当运算符错误的时候，一般会得到NaN NaN 具有传染性，即NaN参与任何运算，结果都为NaN NaN 与任何值都不相等 Infinity: 数值超过了js可以表示的范围，是一个特殊的数字 Infinity 与其他数据类型进行操作运算，结果还是Infinity 数字除以0得到Infinity 2.字符串（String） 含义：多个字符的有序序列，双引号和单引号引起来的都是字符串 特点： 两个字符串相加，实际上是两个字符串拼接 两个字符串相加，是拼接而不是运算，其他运算结果为 NaN,表示计算错误 字符串加数字，首先将数字转化为响应的字符串 然后再参与运算。 同样不支持-、*、+、/等其他运算 3.布尔值（Boolean） 包括false 和 true 通常用在流程控制语句，选择判断语句 false值 数字0 NaN ‘’,空字符串 false undefined null 除了false值就是true 值 4.undefined 如果使用一个未定义的变量，会得到一个undefinedde 值，当定义了一个变量未初始化， 默认的也会给它初始化成undefined的值 5.Null 代表什么都没有 注意：Null和undefined最大的区别是如果变量值为null 说明变量是存在的，只不过它的值是空值null 非基本数据类型变量和常量 变量 含义：是程序可操作的内存空间 程序运行期间是可以改变的 作用：存储数据 定义：var 变量名 存储方式：变量名 = 表达式 常量 含义：程序运行期间是不可以改变的 JS数据类型查看符typeof、instanceof、tostring查看方式 typeOf 变量名 isNaN()函数 和 isFinite() 函数 isNaN() 判断一个数是否为NaN的唯一方式， 如果是NaN则返回true,否则返回false 12console.log(NaN == NaN); // falseconsole.log(isNaN(NaN)); // true isFinite() 如果是NaN或者Infinity返回false,否则返回true 123console.log(isFinite(Infinity)); // falseconsole.log(isFinite(NaN)); // falseconsole.log(isFinite(1)); // true","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}],"keywords":[]},{"title":"javascript语法基础系列之Date用法","slug":"javascripty语法基础系列之Date用法","date":"2019-09-10T00:28:34.719Z","updated":"2019-03-08T01:18:59.935Z","comments":true,"path":"2019/09/09/javascripty语法基础系列之Date用法/","link":"","permalink":"http://yoursite.com/2019/09/09/javascripty语法基础系列之Date用法/","excerpt":"javascript语法基础系列之Date用法","text":"javascript语法基础系列之Date用法 了解时间格里尼治时间（GTM） 是英国郊区格林尼治天文台的时间，因为地球自转的问题，每个时区的时间是不一样的。格林尼治天文台所处的是经度为零的地方，世界上一些重大的时间都是采用的格林尼治时间。 世界标准时间（UTC） 世界标准时间（UTC） Date JS中的Date类型是由早期Java.util.Date类型基础之上构建的，所以保存的是距离1970年1月1日0时的毫秒数来存储时间的。 创建1.用Date()函数创建(字符串类型) var nowDate = Date(); 得到是当前时间 是字符串类型123var nowDate = Date();console.log(nowDate); // Tue Oct 10 2018 09:57console.log(typeof nowDate); // string 2.使用构造函数（对象类型） (1).不使用参数，得到当前时间 12var nowDate = new Date();console.log(typeof nowDate) // object (2). 使用参数 参数是一个表示时间的字符串1234567891011121314//月、日、年、时、分、秒// 2017-07-08 09：05：08 == 2017-07-08 9：5：8// == 2017/7/8 9：5：8var date = new Date(&apos;2017/7/8 09：05：08&apos;);console.log(date); // Web Oct 11 2017 10:11:34// 省掉 时、分、秒 默认为0（默认是标准时间）var date = new Date(&apos;2017/10/10&apos;);console.log(date); // Web Oct 10 2017 00:00:00// 省掉日默认为1日var date = new(&apos;2017/10&apos;);console.log(date); // Web Oct 01 2017 00:00:00// 省掉月默认为1月var date = new Date(&apos;2017&apos;);console.log(date); // Web Jan 01 2017 08:00:00 参数是年、月、时、分、秒、毫秒 a.年必须写的，月是从0开始，日是从1开始的 b.如果月份超过11，则年份自动增加 c.如果日超过当月应有的天数，则月份自动增加 d.时、分、秒、毫秒都是如此123// 参数是年、月、日、时、分、秒、毫秒var date = new Date(2017,05,11,08,30,55);console.log(date); // Sun Jun 11 2017 08:30:55 参数是一个数字 得到的是距离1970年1月1日0时参数毫秒之后的时间 注意：对应北京时间需要加8小时12var date = new(1508802220603);console.log(date); // Wed Oct 11 2017 14:10:20 GWT Date对象的方法Get1234567891011121314151617181920// 获取当前时间var date = new Date();// 获取年var year = date.getFullYear();// 获取月var month = date.getMonth();// 获取日var Date = date.getDate();// 获取星期var day = date.getDay();// 获取时var hour = date.getHours();// 获取分var minute = date.getMinutes();// 获取秒var seconds = date.getSeconds();// 获取毫秒var millSecond = date.getMillSeconds();// 获取当前时间距离 1970年1月1日0时的毫秒数var dutation = date.getTime(); Set123456789101112131415161718var date = new Date();// 设置年var Year = date.setFullYear(2017);// 设置月 月是从0开始 如果大于等于12，年份增加var Month = date.setMonth(10);// 设置日 如果日大于当月应有的天数，月增加var Date = date.setDate();// 设置星期 注意星期一般不设置// 设置时 如果时大于23 日增加var Hour = date.setHours(08);// 设置分钟 如果分钟大于59 时增加var Minute = date.setMinutes(54);// 设置秒 如果秒大于 59 分增加var Second = date.setSeconds(55);// 设置毫秒 如果毫秒大于999 秒增加var MillSecond = date.setMillseconds(666);// 设置距离1970年1月1日0时毫秒数var duration = date.setTime(1507703240504); 转字符串12345678// 包含年月日时分秒var date = new Date();// 包含年于日时分秒var str1 = date.toLocalString();// 包含年月日var str2 = date.toLocalDateString();// 包含时分秒var str3 = date.toLocalTimeString(); Date 对象间的运算 两个时间对象相减，得到的时两个对象间相差的毫秒数","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}],"keywords":[]},{"title":"Hexo 基本命令","slug":"hello-world","date":"2019-09-10T00:28:34.715Z","updated":"2019-03-08T01:18:27.455Z","comments":true,"path":"2019/09/09/hello-world/","link":"","permalink":"http://yoursite.com/2019/09/09/hello-world/","excerpt":"Hexo 基本命令","text":"Hexo 基本命令 Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}],"keywords":[]},{"title":"git基本命令及其用法","slug":"git基本指令","date":"2019-09-10T00:28:34.715Z","updated":"2019-03-13T06:54:42.522Z","comments":true,"path":"2019/09/09/git基本指令/","link":"","permalink":"http://yoursite.com/2019/09/09/git基本指令/","excerpt":"使用git前需要做相关配置","text":"使用git前需要做相关配置 查看git配置的基本指令123git config --list # 显示配置信息列表git config --global user.name 'hongtanhao'git cinfig --global user.emil 'antartec@outlook.com' git使用ssh密钥git支持https和git两种传输协议，github分享链接时会有两种协议可选：git使用https协议，每次pull, push都会提示要输入密码，使用git协议，然后使用ssh密钥，这样免去每次都输密码的麻烦 初次使用git的用户要使用git协议大概需要三个步骤： 步骤一，生成密钥对大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。首先你要确认一下本机是否已经有一个公钥。SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。查看：12$ cd ~/.ssh$ ls 若没有，可以用ssh-keygen 来创建1$ ssh-keygen -t rsa -C 'antartec@outlook.com' 步骤二，设置远程仓库（本文以github为例）上的公钥 查看你生成的公钥 cat ~/.ssh/id_rsa.pub 登陆你的github帐户。点击你的头像，然后 Settings -&gt; 左栏点击 SSH and GPG keys -&gt; 点击 New SSH key 然后你复制上面的公钥内容，粘贴进“Key”文本域内。 title域，自己随便起个名字。 点击 Add key。完成以后，验证下这个key是不是正常工作： ssh -T git@github.com如果，看到： Hi xxx! You&#39;ve successfully authenticated, but GitHub does not # provide shell access. 恭喜你，你的设置已经成功了。 步骤三，把git的 remote url 修改为git协议 使用命令 git remote -v 查看你当前的 remote url $ git remote -vorigin https://github.com/someaccount/someproject.git (fetch)origin https://github.com/someaccount/someproject.git (push) 上面是http协议，若想设置为ssh协议： git remote set-url origin git@github.com:someaccount/someproject.git","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}],"keywords":[]},{"title":"get 请求中特殊字符的处理","slug":"get 请求中特殊字符的处理","date":"2019-09-10T00:28:34.703Z","updated":"2019-03-08T01:17:32.350Z","comments":true,"path":"2019/09/09/get 请求中特殊字符的处理/","link":"","permalink":"http://yoursite.com/2019/09/09/get 请求中特殊字符的处理/","excerpt":"get 请求中特殊字符的处理","text":"get 请求中特殊字符的处理 例子：在get 请求参数中如果包括&amp;符号，在发送请求时就被当做参数的分隔符处理比如请求参数1var url = \"xxx?name=aaa&amp;bbb\" 期望的请求参数应该是 name = “aaa&amp;&amp;bbb”实际的请求参数会变成 name = “aaa” 和 bbb = 处理方法在拼接参数的时候，使用enwxxxcode-styleURLComponent()进行手动转义 1var url = \"xxx?name=\" + enwxxxcode-styleURLComponent(\"aaa&amp;bbb\") 特殊字符的含义 字符 特殊字符的含义 URL + URL中加号表示空格 %2B 空格 URL中的加号可以用空格或编码 %20 / 分割目录和子目录 %2F ？ 分割实际的URL和参数 %3F % 指定特殊字符 %25 # 表示书签 %23 &amp;#038； URL中指定的参数间的分隔符 %26 = URL中指定参数的值 %3D","categories":[],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}],"keywords":[]},{"title":"weex + vue2.0 开发android/iOS 应用之配置环境","slug":"weex + vue2.0 开发Android和iOS 应用","date":"2019-09-10T00:28:34.691Z","updated":"2019-04-22T07:45:33.240Z","comments":true,"path":"2019/09/09/weex + vue2.0 开发Android和iOS 应用/","link":"","permalink":"http://yoursite.com/2019/09/09/weex + vue2.0 开发Android和iOS 应用/","excerpt":"weex + vue2.0 开发android/iOS 应用之配置环境","text":"weex + vue2.0 开发android/iOS 应用之配置环境 一、安装java运行环境（JDK）检测本机操作系统是否已经安装了jdk1java -v 若，没安装过，下载JDK,安装成功后并且配置系统环境变量 二、安装nodejs安装完成后，检测是否安装成功1node -v 三、安装weex、weexpack、webpack1npm install weex weexpack webpack -g 四、初始化项目目录1weex init/create weeex-demo 根据提示选择依赖库，等工程目录创建完成后，1234cd weex-demonpm installnpm run buildnpm run start 可以在浏览器查看项目初始效果 五、添加Android/iOS SDK 支持原生app1weex platform add android # 增加安卓sdk 六、安装Android Studio 首次打开 as， 需要在setting 中配置jdk和sdk Show Package Details Android SDK Build Tools Android Support Repository安装完成后，配置gradle，导入刚创建的项目，便可进行原生开发、打包.apk等 七、调试1.方法一12weex debug your_weex.vue # 调试单个页面weex debug your/path -e App.vue # 调试整个工程 执行调试命令后，会将指定的文件打包成 JSBundle，并启动一个 weex Devtool 服务（http://localhost:8088可访问，如下图），同时将 JSBundle 文件传递至该服务跟路径下的weex文件夹内（http://localhost:8088/weex/App.js，实际是下图右边二维码的的内容）。 2.方法二1weex your_weex.vue 此时本地同时启动一个watch的服务器用于检查代码变更，自动重新构建 JSBundle，视觉同步刷新。 上图看到的效果即为H5页面的效果，我们一般在整个单页编写完成后在使用 Weex Playground App 扫码查看真机效果，或者你也可以在编写的同时使用真机观察代码的运行效果，每次重新构建包到重绘的速度还是很快的。 但前提是你要保证，你的手机和电脑的连在同一个局域网下，并且使用IP访问。 八、打包熟悉 React Native 的人都知道， React Native 的发布实际上就是发布一个 JSBundle，Weex 也是这样，但不同的是，Weex 将工程进行分包，发布多个 JSBundle。因为 Weex 是单页独立开发的，每个页面都将通过 Weex 打包器将 vue/we 页面打包成一个单独的 JSBundle，这样的好处在于减少单个 bundle 包的大小，使其变的足够小巧轻量，提高增量更新的效率。123npm run build # 仅打包weex build iso # 打包 + 构建weex run iso # 打包 + 构建 +运行 以上三种均会触发 Weex 对工程进行打包。在我们执行了以上打包命令后，所有的工程文件将被单独打成一个独立的 JSBundle，如下：index.vue ==&gt; index.jshome.vue ==&gt; home.jstopit.vue ==&gt; topic.jsshop.vue ==&gt; shop.js打包后的 JSBundle 有两种格式12345# 由.vue文件打包出来的包格式（简写），使用 vue 2.0 语法编写// &#123; \"framework\": \"Vue\"&#125; /******/ (function(modules) &#123; ......./******/ &#125;) 12345# 由.we文件打包出来的包格式（简写），使用 weex 语法编写// &#123; \"framework\": \"Weex\" &#125;/******/ (function(modules) &#123; ......./******/ &#125;) 不同的头部是要告诉使用什么语法解析此JSBundle。 至此，我们准备「热更新的包」就已经准备完毕了，接下就是发包执行了 九、发包打包后的 JSBundle 一般发布到发包服务器上，客户端从服务器更新包后即可在下次启动执行新的版本，而无需重新下载 app，因为运行依赖的 WeexSDK 已经存在于客户端了，除非新包依赖于新的 SDK，这也是热更新的基本原理。1234【WeexSDK】包括【JS Framework】JSBundle 的执行环境【JS-Native Bridge】中间件或者叫通讯桥梁，也叫【Weex Runtime】【Native Render Engine】解析 js 端发出的指令做原生控件布局渲染 十、执行Weex 的 iOS 和 Android 客户端的【JSFramework】中都会运行一个 JavaScript 引擎，来执行 JS bundle，同时向各端的渲染层发送规范化的指令，调度客户端的渲染和其它各种能力。iOS 下选择了 JavaScriptCore 内核，而在 Android 下选择了 UC 提供的 v8 内核（RN两端都是JavaScriptCore 内核）。 JSBundle 被 push 到客户端后就会在 JSFramework 中执行，最终输出三端可读性的 VNode 节点，数据结构简化如下：1234567891011121314151617181920212223242526&#123; tag: 'div', data: &#123; staticStyle: &#123; justifyContent: 'center' &#125; &#125;, children: [&#123; tag: 'text', data: &#123; staticClass: 'txt' &#125;, context: &#123; $options: &#123; style: &#123; freestyle: &#123; textAlign: 'center', fontSize: 200 &#125; &#125; &#125; &#125;, children: [&#123; tag: '', text: '文字' &#125;] &#125;]&#125; 有了统一的 VNode 节点，各端即可根据自己的方法解析渲染原生UI了，之前的所有操作都是一致的，包括文件格式、打包编译过程、模板指令、组件的生命周期、数据绑定等。 然而由于目标执行环境不同（浏览器和 Weex 容器），在渲染真实原生 UI 的时候调用的接口也不同。 Vnode —DOM api —&gt; WebVnode —Native DOM API Weex此过程发生在【Weex SDK】的【Weex Runtime】中。 最总【Weex Runtime】发起渲染指令callNative({…})有RenderEngine完成渲染 总结一下 Weex 文件分包打包成单个 JSBundle 文件 发布到发包服务器上，通过热更新 push 到用户的客户端 交由【Weex SDK】执行解析 SDK 中的【JS Framework】执行 Bundle 脚本生成 Virtual DOM Virtual DOM 经由各端执行环境【Weex Runtime】解析翻译成执行指令 【Native RenderEngine】接收到指令后执行渲染操作，作出渲染出完整的界面","categories":[],"tags":[{"name":"weex","slug":"weex","permalink":"http://yoursite.com/tags/weex/"}],"keywords":[]},{"title":"在ubuntu系统中部署tomcat服务器","slug":"在linux操作系统中部署tomcat服务器","date":"2019-09-10T00:28:34.679Z","updated":"2019-07-22T07:08:21.952Z","comments":true,"path":"2019/09/09/在linux操作系统中部署tomcat服务器/","link":"","permalink":"http://yoursite.com/2019/09/09/在linux操作系统中部署tomcat服务器/","excerpt":"在ubuntu系统中部署tomcat服务器，使用https协议通信","text":"在ubuntu系统中部署tomcat服务器，使用https协议通信 使用远程管理软件XShell上传文件到Linux服务器上 首先连接上一台Linux主机 输入rz命令，看是否已经安装了lrzsz，如果没有安装则执行yum -y install lrzsz （或apt install lrzsz） 命令进行安装。 安装成功后，输入rpm命令确认是否正确安装rpm -qa lrzsz 使用 rz -y命令进行文件上传，此时会弹出上传的窗口： 选择要上传的文件，点击确定即可将本地文件上传到Linux上，如图表示成功上传文件 使用ls命令可以看到文件已经上传到了当前目录下 Ubuntu 18.04安装JDK并配置环境变量 官网下载jdk下载链接http://www.oracle.com/technetwork/java/javase/downloads/index.html可以根据自己的系统进行下载 进行解压sudo tar -zxvf jdk-8u171-linux-x64.tar.gz 则解压到了当前目录下，解压后可以把解压文件移动到自己想要放的目录下，使用mv命令 sudo mv jdk1.8.0_171 /usr/lib/xxx 进行配置使用全局设置方法，它是所有用户的共用的环境变量命令如下：$sudo gedit ~/.bashrc / (view ~/.bashrc)然后把如下命令复制到最底部 export JAVA_HOME=/home/wind/ub_server/java/jdk1.8.0_211export JRE_HOME=${JAVA_HOME}/jreexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/libexport PATH=${JAVA_HOME}/bin:$PATHexport JAVA_HOME=后面要填写自己解压后的jdk的路径血的教训：：请千万注意路径后面不能有空格，否则就不能生效 生效~/.bashrc文件命令如下：$sudo source ~/.bashrc 测试是否安装成功java -version 查看版本号是否改变 在Ubuntu16.04下安装mysql 首先执行下面三条命令： 123sudo apt-get install mysql-serversudo apt install mysql-clientsudo apt install libmysqlclient-dev 安装成功后可以通过下面的命令测试是否安装成功： 1sudo netstat -tap | grep mysql 可以通过如下命令进入mysql服务 1mysql -uroot -p你的密码 现在设置mysql允许远程访问，首先编辑文件/etc/mysql/mysql.conf.d/mysqld.cnf： 1sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf 注释掉bind-address = 127.0.0.1：保存退出 在mysql环境下执行授权命令(授权给远程任何电脑登录数据库)：输入下面的命令进行开启： 1grant all on *.* to root@'%' identified by '123456' with grant option; 回车后刷新配置flush privileges; 然后执行quit命令退出mysql服务，执行如下命令重启mysql：service mysql restart 现在 在windows下可以使用navicat远程连接ubuntu下的mysql服务 以上如果出现问题： 问题:远程连接mysql数据库出现错误:2003-can’t connect to MYSQL server on ‘’(10060)解决方案：打开阿里云控制台,在实例安全组中添加3306端口 https证书配置（没解决实际问题） Ubuntu上CA证书的配置可以通过工具ca-certificates来方便的进行。该工具默认是随Ubuntu安装的，如果没有可以通过下面的命令来安装： 1sudo apt-get install ca-certificates 需要安装CA证书我们只需要将其放在”/usr/share/ca-certificates”目录或其子目录下，ca-certificates工具就能自动扫描到。为了不与其它根证书混淆，我们创建一个子目录名为”extra”: 1sudo mkdir /usr/share/ca-certificates/extra 然后将待安装的证书 CASHLibCACert.crt (需要下载)拷贝到刚刚创建的目录下：sudo cp _amanda.org.cn.crt /usr/share/ca-certificates/extra/amanda.org.cn.crt（注意这里的证书是.crt的扩展名） 接下来让ca-certificates工具帮我们安装CA证书：sudo dpkg-reconfigure ca-certificates 选择”Yes”，我们能看到待安装的CA证书已经被扫描到了，选中它（点空格键）然后选”OK”就行了。 那么安装的CA证书在哪里呢，Ubuntu把所有的证书都放在”/etc/ssl/certs”目录下，包括CA证书和普通的证书。来看看刚刚安装好的证书CASHLibCACert.pem就是CA证书。 我们安装的时候证书扩展名是.crt，安装后扩展名变为了.pem。这两者的内容其实是一样的。CASHLibCACert.pem就是CA证书。 我们安装的时候证书扩展名是.crt，安装后扩展名变为了.pem。.crt证书是按base64编码的，如果.pem也采用base64编码，那么这两者是可以通用的。在本例中，CA证书的内容在安装前后没有变化。普通证书是指除CA之外的证书，真正用来做身份认证或签名的证书。相对而言，CA证书用来验证普通证书的可信性。 普通证书没有特别的安装步骤，放在任意可以访问的目录下就可以了。当然也可以拷贝到Ubuntu的证书目录下，跟刚刚安装的CA证书在同一目录——”/etc/ssl/certs”","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}],"keywords":[]},{"title":"spring aop原理分析","slug":"spring aop原理分析","date":"2019-09-10T00:28:34.667Z","updated":"2019-07-22T07:11:11.581Z","comments":true,"path":"2019/09/09/spring aop原理分析/","link":"","permalink":"http://yoursite.com/2019/09/09/spring aop原理分析/","excerpt":"AOP（Aspect-OrientedProgramming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。","text":"AOP（Aspect-OrientedProgramming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。 什么是aop AOP（Aspect-OrientedProgramming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。 而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。 使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。” AOP使用场景AOP用来封装横切关注点，具体可以在下面的场景中使用: Authentication 权限 Caching 缓存 Context passing 内容传递 Error handling 错误处理 Lazy loading 懒加载 Debugging 调试 logging, tracing, profiling and monitoring 记录跟踪 优化 校准 Performance optimization 性能优化 Persistence 持久化 Resource pooling 资源池 Synchronization 同步 Transactions 事务 Transactions 事务 方面（Aspect）：一个关注点的模块化，这个关注点实现可能另外横切多个对象。事务管理是J2EE应用中一个很好的横切关注点例子。方面用Spring的 Advisor或拦截器实现。 连接点（Joinpoint）: 程序执行过程中明确的点，如方法的调用或特定的异常被抛出。 通知（Advice）: 在特定的连接点，AOP框架执行的动作。各种类型的通知包括“around”、“before”和“throws”通知。通知类型将在下面讨论。许多AOP框架包括Spring都是以拦截器做通知模型，维护一个“围绕”连接点的拦截器链。Spring中定义了四个advice: BeforeAdvice, AfterAdvice, ThrowAdvice和DynamicIntroductionAdvice 切入点（Pointcut）: 指定一个通知将被引发的一系列连接点的集合。AOP框架必须允许开发者指定切入点：例如，使用正则表达式。 Spring定义了Pointcut接口，用来组合MethodMatcher和ClassFilter，可以通过名字很清楚的理解， MethodMatcher是用来检查目标类的方法是否可以被应用此通知，而ClassFilter是用来检查Pointcut是否应该应用到目标类上 引入（Introduction）: 添加方法或字段到被通知的类。 Spring允许引入新的接口到任何被通知的对象。例如，你可以使用一个引入使任何对象实现 IsModified接口，来简化缓存。Spring中要使用Introduction, 可有通过DelegatingIntroductionInterceptor来实现通知，通过DefaultIntroductionAdvisor来配置Advice和代理类要实现的接口 目标对象（Target Object）: 包含连接点的对象。也被称作被通知或被代理对象。POJO AOP代理（AOP Proxy）: AOP框架创建的对象，包含通知。 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理 织入（Weaving）: 组装方面来创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。 如何使用Spring AOP可以通过配置文件或者编程的方式来使用Spring AOP。 配置可以通过xml文件来进行，大概有四种方式： 配置ProxyFactoryBean，显式地设置advisors, advice, target等 配置AutoProxyCreator，这种方式下，还是如以前一样使用定义的bean，但是从容器中获得的其实已经是代理对象 通过aop:config来配置 通过&lt;aop: aspectj-autoproxy&gt;来配置，使用AspectJ的注解来标识通知及切入点 也可以直接使用ProxyFactory来以编程的方式使用Spring AOP，通过ProxyFactory提供的方法可以设置target对象, advisor等相关配置，最终通过 getProxy()方法来获取代理对象具体使用的示例可以google. 这里略去 Spring AOP代理对象的生成Spring提供了两种方式来生成代理对象: JDKProxy和Cglib，具体使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定。默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理。下面我们来研究一下Spring如何使用JDK来生成代理对象，具体的生成代码放在JdkDynamicAopProxy这个类中，直接上相关代码：123456789101112131415*** &lt;ol&gt;* &lt;li&gt;获取代理类要实现的接口,除了Advised对象中配置的,还会加上SpringProxy, Advised(opaque=false)* &lt;li&gt;检查上面得到的接口中有没有定义 equals或者hashcode的接口* &lt;li&gt;调用Proxy.newProxyInstance创建代理对象* &lt;/ol&gt;*/public Object getProxy(ClassLoader classLoader) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Creating JDK dynamic proxy: target source is \" +this.advised.getTargetSource()); &#125; Class[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised); findDefinedEqualsAndHashCodeMethods(proxiedInterfaces); return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);&#125; 下面的问题是，代理对象生成了，那切面是如何织入的？ 我们知道InvocationHandler是JDK动态代理的核心，生成的代理对象的方法调用都会委托到InvocationHandler.invoke()方法。而通过JdkDynamicAopProxy的签名我们可以看到这个类其实也实现了InvocationHandler，下面我们就通过分析这个类中实现的invoke()方法来具体看下Spring AOP是如何织入切面的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public Object invoke(Object proxy, Method method, Object[] args) throwsThrowable &#123; MethodInvocation invocation = null; Object oldProxy = null; boolean setProxyContext = false; TargetSource targetSource = this.advised.targetSource; Class targetClass = null; Object target = null; try &#123; //eqauls()方法，具目标对象未实现此方法 if (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method))&#123; return (equals(args[0])? Boolean.TRUE : Boolean.FALSE); &#125; //hashCode()方法，具目标对象未实现此方法 if (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method))&#123; return newInteger(hashCode()); &#125; //Advised接口或者其父接口中定义的方法,直接反射调用,不应用通知 if (!this.advised.opaque &amp;&amp;method.getDeclaringClass().isInterface() &amp;&amp;method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123; // Service invocations onProxyConfig with the proxy config... return AopUtils.invokeJoinpointUsingReflection(this.advised,method, args); &#125; Object retVal = null; if (this.advised.exposeProxy) &#123; // Make invocation available ifnecessary. oldProxy = AopContext.setCurrentProxy(proxy); setProxyContext = true; &#125; //获得目标对象的类 target = targetSource.getTarget(); if (target != null) &#123; targetClass = target.getClass(); &#125; //获取可以应用到此方法上的Interceptor列表 List chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method,targetClass); //如果没有可以应用到此方法的通知(Interceptor)，此直接反射调用 method.invoke(target, args) if (chain.isEmpty()) &#123; retVal = AopUtils.invokeJoinpointUsingReflection(target,method, args); &#125; else &#123; //创建MethodInvocation invocation = newReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain); retVal = invocation.proceed(); &#125; // Massage return value if necessary. if (retVal != null &amp;&amp; retVal == target &amp;&amp;method.getReturnType().isInstance(proxy) &amp;&amp;!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123; // Special case: it returned\"this\" and the return type of the method // is type-compatible. Notethat we can't help if the target sets // a reference to itself inanother returned object. retVal = proxy; &#125; return retVal; &#125; finally &#123; if (target != null &amp;&amp; !targetSource.isStatic()) &#123; // Must have come fromTargetSource. targetSource.releaseTarget(target); &#125; if (setProxyContext) &#123; // Restore old proxy. AopContext.setCurrentProxy(oldProxy); &#125; &#125;&#125; 主流程可以简述为：获取可以应用到此方法上的通知链（Interceptor Chain）,如果有,则应用通知,并执行joinpoint; 如果没有,则直接反射执行joinpoint。而这里的关键是通知链是如何获取的以及它又是如何执行的，下面逐一分析下。 首先，从上面的代码可以看到，通知链是通过Advised.getInterceptorsAndDynamicInterceptionAdvice()这个方法来获取的,我们来看下这个方法的实现:123456789public List&lt;Object&gt;getInterceptorsAndDynamicInterceptionAdvice(Method method, Class targetClass) &#123; MethodCacheKeycacheKey = new MethodCacheKey(method); List&lt;Object&gt;cached = this.methodCache.get(cacheKey); if(cached == null) &#123; cached= this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(this, method, targetClass); this.methodCache.put(cacheKey,cached); &#125; returncached;&#125; 可以看到实际的获取工作其实是由AdvisorChainFactory. getInterceptorsAndDynamicInterceptionAdvice()这个方法来完成的，获取到的结果会被缓存。 下面来分析下这个方法的实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 /** * 从提供的配置实例config中获取advisor列表,遍历处理这些advisor.如果是IntroductionAdvisor, * 则判断此Advisor能否应用到目标类targetClass上.如果是PointcutAdvisor,则判断 * 此Advisor能否应用到目标方法method上.将满足条件的Advisor通过AdvisorAdaptor转化成Interceptor列表返回. */publicList getInterceptorsAndDynamicInterceptionAdvice(Advised config, Methodmethod, Class targetClass) &#123; // This is somewhat tricky... we have to process introductions first, // but we need to preserve order in the ultimate list. List interceptorList = new ArrayList(config.getAdvisors().length); //查看是否包含IntroductionAdvisor boolean hasIntroductions = hasMatchingIntroductions(config,targetClass); //这里实际上注册一系列AdvisorAdapter,用于将Advisor转化成MethodInterceptor AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance(); Advisor[] advisors = config.getAdvisors(); for (int i = 0; i &lt;advisors.length; i++) &#123; Advisor advisor = advisors[i]; if (advisor instanceof PointcutAdvisor) &#123; // Add it conditionally. PointcutAdvisor pointcutAdvisor= (PointcutAdvisor) advisor; if(config.isPreFiltered() ||pointcutAdvisor.getPointcut().getClassFilter().matches(targetClass)) &#123; //TODO: 这个地方这两个方法的位置可以互换下 //将Advisor转化成Interceptor MethodInterceptor[]interceptors = registry.getInterceptors(advisor); //检查当前advisor的pointcut是否可以匹配当前方法 MethodMatcher mm =pointcutAdvisor.getPointcut().getMethodMatcher(); if (MethodMatchers.matches(mm,method, targetClass, hasIntroductions)) &#123; if(mm.isRuntime()) &#123; // Creating a newobject instance in the getInterceptors() method // isn't a problemas we normally cache created chains. for (intj = 0; j &lt; interceptors.length; j++) &#123; interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptors[j],mm)); &#125; &#125; else &#123; interceptorList.addAll(Arrays.asList(interceptors)); &#125; &#125; &#125; &#125; else if (advisor instanceof IntroductionAdvisor)&#123; IntroductionAdvisor ia =(IntroductionAdvisor) advisor; if(config.isPreFiltered() || ia.getClassFilter().matches(targetClass)) &#123; Interceptor[] interceptors= registry.getInterceptors(advisor); interceptorList.addAll(Arrays.asList(interceptors)); &#125; &#125; else &#123; Interceptor[] interceptors =registry.getInterceptors(advisor); interceptorList.addAll(Arrays.asList(interceptors)); &#125; &#125; return interceptorList;&#125; 这个方法执行完成后，Advised中配置能够应用到连接点或者目标类的Advisor全部被转化成了MethodInterceptor.接下来我们再看下得到的拦截器链是怎么起作用的。 1234567if (chain.isEmpty()) &#123; retVal = AopUtils.invokeJoinpointUsingReflection(target,method, args);&#125; else &#123; //创建MethodInvocation invocation = newReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain); retVal = invocation.proceed();&#125; 从这段代码可以看出，如果得到的拦截器链为空，则直接反射调用目标方法，否则创建MethodInvocation，调用其proceed方法，触发拦截器链的执行，来看下具体代码1234567891011121314151617181920212223242526272829303132333435public Object proceed() throws Throwable &#123; // We start with an index of -1and increment early. if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size()- 1) &#123; //如果Interceptor执行完了，则执行joinPoint return invokeJoinpoint(); &#125; Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex); //如果要动态匹配joinPoint if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) &#123; // Evaluate dynamic method matcher here: static part will already have // been evaluated and found to match. InterceptorAndDynamicMethodMatcher dm = (InterceptorAndDynamicMethodMatcher)interceptorOrInterceptionAdvice; //动态匹配：运行时参数是否满足匹配条件 if (dm.methodMatcher.matches(this.method, this.targetClass,this.arguments)) &#123; //执行当前Intercetpor returndm.interceptor.invoke(this); &#125; else &#123; //动态匹配失败时,略过当前Intercetpor,调用下一个Interceptor return proceed(); &#125; &#125; else &#123; // It's an interceptor, so we just invoke it: The pointcutwill have // been evaluated statically before this object was constructed. //执行当前Intercetpor return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this); &#125;&#125;","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}],"keywords":[]}]}